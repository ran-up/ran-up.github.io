<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ranup前端笔记汇总</title>
  
  <subtitle>一个前端小白的苦闷路程</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-18T13:28:26.197Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ranup</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>let与const与var整理</title>
    <link href="http://example.com/2022/10/17/let%E4%B8%8Econst%E4%B8%8Evar%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2022/10/17/let%E4%B8%8Econst%E4%B8%8Evar%E6%95%B4%E7%90%86/</id>
    <published>2022-10-17T13:15:39.000Z</published>
    <updated>2022-10-18T13:28:26.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise知识点"><a href="#Promise知识点" class="headerlink" title="Promise知识点"></a>Promise知识点</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>Promise</code> 是一个 <code>ECMAScript 6</code> 提供的<strong>类</strong>，目的是更加优雅地书写<strong>复杂</strong>的<strong>异步</strong>任务。</p><p><strong>Safari 9 和 Edge 13 及以下不兼容</strong></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>**<code>语法</code>**：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造 Promise 对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 要做的事情...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 <code>Promise</code> 中只有<strong>一个参数</strong>，该参数是一个<strong>函数</strong>。</p><p>这个函数在构造之后会直接被<strong>异步运行</strong>，所以我们称之为<strong>起始函数</strong>。该函数可以传入两个参数 <code>resolve</code> 和 <code>reject</code>。</p><p><code>resolve</code> 和 <code>reject</code> 都是函数，前者是<strong>运行成功</strong>时调用的函数，后者是<strong>运行出错</strong>时调用的函数。</p><p>在 <code>Promise</code> 类中还有三个方法：</p><ul><li>**<code>.then()</code>**：正常执行的序列（是异步执行的）</li><li>**<code>.catch()</code>**：异常处理的序列</li><li>**<code>.finally()</code>**：最后一定会执行的序列。</li></ul><p>我们还可以在<code> then()</code>方法中，使用 <code>throw </code>来自定义错误，从而提交到 <code>catch </code>方法中输出定义的错误。</p><p>**<code>注意</code>**：</p><ul><li><code>resolve 和 reject</code> 的作用域只有起始函数，在其他序列当中不能使用；</li><li><code>resolve 和 reject </code>并不能够使起始函数停止运行，别忘了 <code>return</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是：&quot;</span> + <span class="number">111</span>)</span><br><span class="line">        <span class="comment">// 调用 resolve 传入参数 222</span></span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">222</span>)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是：&quot;</span>, value)</span><br><span class="line">        <span class="comment">// 内部使用 reutrn 返回值，传给下一个 then 方法当参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">333</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是：&quot;</span>, value)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;我定义一个错误&quot;</span></span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    &#125;).<span class="title function_">finally</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是都会执行的fanilly方法&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">我是：111</span></span><br><span class="line"><span class="comment">我是： 222</span></span><br><span class="line"><span class="comment">我是： 333</span></span><br><span class="line"><span class="comment">我定义一个错误</span></span><br><span class="line"><span class="comment">我是都会执行的fanilly方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">4</span></span><br><span class="line">        <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">        <span class="comment">// 错误直接调用 reject 去 catch 输出错误</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="title function_">reject</span>(<span class="string">&quot;除数不能为0&quot;</span>)</span><br><span class="line">        <span class="comment">// 这种方法也可以</span></span><br><span class="line">        <span class="comment">// if (b == 0) throw (&quot;除数不能为0&quot;)</span></span><br><span class="line">        <span class="comment">// 条件成立则调用 resolve 并传入参数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">resolve</span>(a / b)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value) <span class="comment">// 输出：2</span></span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h2><p>异步函数（<code>async function</code>）是 ECMAScript 2017 (ECMA-262) 标准的规范，几乎被所有浏览器所支持，除了 Internet Explorer。</p><p>在异步函数中可以使用 <code>await</code> 指令，而在其后<strong>必须</strong>跟着一个 <code>Promise</code> 类，当 <code>Promise</code> 运行时异步函数就会暂停，直至它运行结束后才会继续运行。</p><p>其实异步函数实际上原理与 <code>Promise</code> 原生 API 的机制是<strong>一模一样</strong>的，只不过更便于程序员阅读。</p><p>当我们需要对<strong>异常进行处理</strong>的时候可以使用 <code>try-catch</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是正确的&quot;</span>) <span class="comment">// 执行 resolve</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;我是故意出错的&quot;</span> <span class="comment">// 执行 reject</span></span><br><span class="line">                <span class="comment">// 这种写法也可以</span></span><br><span class="line">                <span class="comment">// reject(&quot;我是故意出错的&quot;)</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">asyncFunc</span>()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">我是正确的</span></span><br><span class="line"><span class="comment">我是故意出错的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li><code>resolve 和 reject</code> 的作用域只有<strong>起始函数</strong>，在其他序列当中不能使用；</li><li><code>resolve 和 reject </code>并不能够使起始函数停止运行，别忘了 <code>return</code>；</li><li><code>then、catch 和 finally </code>序列顺序可以颠倒，但一般使用 <code>then-catch-finally</code> 的顺序编写程序；</li><li><code>then</code> 块默认会<strong>向下顺序</strong>执行，<code>return</code> 是不能中断的，可以通过 <code>throw</code> 来跳转至 <code>catch</code> 实现中断。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Promise知识点&quot;&gt;&lt;a href=&quot;#Promise知识点&quot; class=&quot;headerlink&quot; title=&quot;Promise知识点&quot;&gt;&lt;/a&gt;Promise知识点&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="es6" scheme="http://example.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/10/11/hello-world/"/>
    <id>http://example.com/2022/10/11/hello-world/</id>
    <published>2022-10-11T09:06:05.424Z</published>
    <updated>2022-10-11T09:06:05.424Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
