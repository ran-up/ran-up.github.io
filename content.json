{"meta":{"title":"ranup前端笔记汇总","subtitle":"一个前端小白的苦闷路程","description":"这里是一些前端方面的笔记，知识共享，持续更新","author":"ranup","url":"http://ran-up.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-12-27T17:38:35.751Z","updated":"2024-12-27T17:38:35.751Z","comments":false,"path":"/404.html","permalink":"http://ran-up.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2024-12-27T17:38:35.774Z","updated":"2024-12-27T17:38:35.774Z","comments":false,"path":"books/index.html","permalink":"http://ran-up.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2024-12-27T17:38:35.774Z","updated":"2024-12-27T17:38:35.774Z","comments":false,"path":"about/index.html","permalink":"http://ran-up.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2024-12-27T17:38:35.775Z","updated":"2024-12-27T17:38:35.775Z","comments":true,"path":"links/index.html","permalink":"http://ran-up.github.io/links/index.html","excerpt":"","text":""},{"title":"项目介绍","date":"2024-12-27T17:38:35.776Z","updated":"2024-12-27T17:38:35.776Z","comments":false,"path":"repository/index.html","permalink":"http://ran-up.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-12-27T17:38:35.775Z","updated":"2024-12-27T17:38:35.775Z","comments":true,"path":"categories/index.html","permalink":"http://ran-up.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-12-27T17:38:35.776Z","updated":"2024-12-27T17:38:35.776Z","comments":false,"path":"tags/index.html","permalink":"http://ran-up.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"nuxt简易实战oppo官网","slug":"SSR/nuxt/nuxt简易实战oppo官网","date":"2025-02-12T16:36:16.000Z","updated":"2025-02-23T15:12:58.672Z","comments":true,"path":"2025/02/13/SSR/nuxt/nuxt简易实战oppo官网/","link":"","permalink":"http://ran-up.github.io/2025/02/13/SSR/nuxt/nuxt%E7%AE%80%E6%98%93%E5%AE%9E%E6%88%98oppo%E5%AE%98%E7%BD%91/","excerpt":"","text":"ssr 实战oppo 官网，实现了 OPPO 专区、OnePlus 专区、智能硬件、详情页 的内容。 服务、登录、注册 只实现了简单的页面跳转实现。 OPPO 专区 轮播图下的那 8 个 分类可以点击跳转到 详情页，其他两个页面的不行。 另外封装了 useFetch 进行数据请求，并且做了数据备份，即使后面的 api 失效了，会自动使用本地数据。 项目演示 项目技术 vue3 nuxt3 element-plus TypeScript pinia scss normalize.css 项目目录 assets css global.scss – 全局的样式重置 variables.scss – 全局变量 cus-font&#x2F; – iconfont 文件 images saveImg&#x2F; – 备份图片 components appFooter.vue – 尾部组件 appHeader.vue – 头部组件 baseContent.vue – 统一管理组件 categoryGrid.vue – 分类信息内容组件 categorySection.vue – 分类信息组件 categoryTitle.vue – 分类信息的名称组件 gridItem.vue – 分类信息的小 i tem 组件 navbar.vue – 导航组件 search.vue – 搜索框组件 swiper.vue – 轮播图组件 tabCategory.vue – 分类组件 layouts default.vue – 默认布局 empty.vue – 空布局，登录、注册、404 等组件使用 pages […slug].vue – 404 组件 category-detail.vue – 分类详情 index.vue – 主页、OPPO 专区 intelligent.vue – 智能硬件 login.vue – 登录 one-plus.vue – OnePlus 专区 oppo-service.vue – 服务 register.vue – 注册 plugins element-plus.client.js – ElementPlus 中文化配置 public&#x2F; – 静态目录，可以直接使用该目录下的图片 service saveData&#x2F; – 备份的 api 数据 detailInfo.ts – 详情信息 homeInfo.ts – OPPO 专区 homeIntelligentInfo.ts – 智能硬件 onePlusInfo.ts – OnePlus 专区 detail.ts – 详情页 的接口请求 home.ts – 首页等三个页面的 接口请求 index.ts – useFetch() 接口封装 store detail.ts – 详情页类型定义 home.ts – 首页类型定义与 pinia 使用 utils reqUnite.ts – 请求数据和设置备用数据的抽离代码 app.vue nuxt.config.ts package-lock.json package.json README.md tsconfig.json 项目搭建 创建项目：npx nuxi init oppo-nuxt 安装依赖：npm i 初始化 css：npm i normalize.css 安装 sass 与 element-plus：npm i sass element-plus @element-plus/nuxt // 新建 plugins/element-plus.client.js// 配置 element-plus 中文化import ElementPLus from &#x27;element-plus&#x27;import &#123; zhCn &#125; from &#x27;element-plus/es/locale/index.mjs&#x27;// import zhCn from &#x27;element-plus/es/locale/lang/zh-cn&#x27;export default defineNuxtPlugin(nuxtApp =&gt; &#123; return nuxtApp.vueApp.use(ElementPLus, &#123; locale: zhCn &#125;)&#125;) 修改 nuxt.config.ts 配置： export default defineNuxtConfig(&#123; css: [&#x27;normalize.css&#x27;, &#x27;element-plus/dist/index.css&#x27;], modules: [&#x27;@element-plus/nuxt&#x27;], plugins: [&#x27;@/plugins/element-plus.client.js&#x27;]&#125;) 在 app.vue 中测试上面的配置是否生效 &lt;template&gt; &lt;div class=&quot;page&quot;&gt; &lt;el-button type=&quot;primary&quot;&gt;默认&lt;/el-button&gt; &lt;el-button type=&quot;success&quot;&gt;成功&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot;&gt;.page &#123; border: 1px solid red; background: skyblue;&#125;&lt;/style&gt; 终端运行：npm run dev 查看结果，背景颜色、border 生效，表明 sass 生效；div 盒子紧靠页面左边，表明 normalize.css 生效；button 样式和 element-plus 的效果一样，表明其生效。 配置 SCSS编写公共样式数据assets/css/variables.scss 公共样式文件。 $contentWidth: 1248px; // 内容宽$appHeaderHeight: 36px; // app header 的高度$navBarHeight: 84px; // 导航栏高度 68 + 16// logo$logoWidth: 250px;$logoHeight: 50px;$swiperHeight: 480px; // 轮播图高$categoryBarHeight: 120px; // 分类栏高// 商品图片$imgWidth: 130px;$imgHeight: 150px;$gridItemHeight: 300px; // 商品图片 item 高度// appFooter$appFooterTop: 82px;$appFooterCenter: 360px;$appFooterBottom: 58px;// 字体$fontSize16: 16px;$fontSize15: 15px;$fontSize14: 14px;$fontSize12: 12px;// 字体颜色$textTitleColor: #000; // 标题字体颜色$textSubColor: #535353; // 导航字体颜色$textRedColor: rgb(246, 52, 52); // 红色字体$priceColor: #f34141; // 价格字体颜色// 背景颜色$bgColor: #fff; // 白色背景$bgGrayColor: #fafafa; // 灰色背景// 背景精灵图 -- 没有这张图片@mixin bgSpride() &#123; background-image: url(&#x27;@/assets/images/spride.png&#x27;); background-repeat: no-repeat;&#125;// 水平居中的 flex@mixin normalFlex($direction: row, $content: space-between) &#123; display: flex; flex-direction: $direction; justify-content: $content;&#125;// 粘性定位@mixin elementSticky($top: 0px, $z: 100) &#123; postion: sticky; top: $top; z-index: $z;&#125;// 鼠标hover@mixin hoverEffect() &#123; transition: all 0.2s linear; transform: translateY(-3px); box-shadow: 0 4px 8px 0 rgb(0 0 0 / 10%);&#125;// 单行字体省略@mixin textEllipsis() &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;// 多行文字省略@mixin textMultiEllipsis($line: 2) &#123; overflow: hidden; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: $line;&#125;/* 调试专用 */// boder@mixin border($color: red) &#123; border: 1px solid $color;&#125; 编写全局样式assets/css/global.scss 全局样式文件 // @use &#x27;@/assets/css/variables.scss&#x27; as *; // nuxt.config.ts 配置自动导入@import &#x27;normalize.css&#x27;;@import &#x27;element-plus/dist/index.css&#x27;;.wrapper &#123; margin: 0 auto; width: $contentWidth;&#125;body &#123; font-size: $fontSize14; color: #333;&#125;ul,li &#123; margin: 0; padding: 0;&#125;ul &#123; list-style: none;&#125;a &#123; text-decoration: none; font-size: 12px;&#125; 修改配置文件在 nuxt.config.ts 文件添加 .scss 文件的自动导入配置。 export default defineNuxtConfig(&#123; compatibilityDate: &#x27;2024-11-01&#x27;, devtools: &#123; enabled: true &#125;, // css: [&#x27;normalize.css&#x27;, &#x27;element-plus/dist/index.css&#x27;], // 在 assets/css/global.scss 中导入了 css: [&#x27;@/assets/css/global.scss&#x27;], vite: &#123; css: &#123; preprocessorOptions: &#123; scss: &#123; additionalData: &#x27;@use &quot;@/assets/css/variables.scss&quot; as *;&#x27; &#125; &#125; &#125; &#125;, modules: [&#x27;@element-plus/nuxt&#x27;], plugins: [&#x27;@/plugins/element-plus.client.js&#x27;]&#125;) 测试修改 app.vue 文件 &lt;template&gt; &lt;div class=&quot;wrapper bg&quot;&gt;Page: index&lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.bg &#123; background-color: $bgGrayColor; @include border();&#125;&lt;/style&gt; 编写默认布局layouts&#x2F;default.vue新建 components/appHeader.vue、components/appFooter.vue 文件。 &lt;template&gt; &lt;div&gt; &lt;app-header /&gt; &lt;slot&gt;&lt;/slot&gt; &lt;app-footer /&gt; &lt;/div&gt;&lt;/template&gt; app.vue&lt;template&gt; &lt;NuxtLayout&gt; &lt;NuxtPage /&gt; &lt;/NuxtLayout&gt;&lt;/template&gt; 编写头部将 iconfont 内容复制到 assets 目录，这里的 iconfongt 文件夹叫 cus-font 目录。修改 nuxt.config.ts。 css: [&#x27;@/assets/css/global.scss&#x27;, &#x27;@/assets/cus-font/iconfont.css&#x27;] 修改 components/appHeader.vue。 &lt;template&gt; &lt;div class=&quot;app-header&quot;&gt; &lt;div class=&quot;wrapper content&quot;&gt; &lt;div class=&quot;content-left&quot;&gt; &lt;nuxt-link class=&quot;link&quot; to=&quot;/&quot;&gt; &lt;span&gt;OPPO官网&lt;/span&gt; &lt;/nuxt-link&gt; &lt;nuxt-link class=&quot;link&quot; to=&quot;/&quot;&gt; &lt;span&gt;一加官网&lt;/span&gt; &lt;/nuxt-link&gt; &lt;/div&gt; &lt;div class=&quot;content-right&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;link download&quot;&gt; &lt;span&gt;下载 OPPO 商城APP&lt;/span&gt; &lt;div class=&quot;app&quot;&gt; &lt;img class=&quot;ecode&quot; src=&quot;@/assets/images/ecode.png&quot; alt=&quot;OPPO&quot; /&gt; &lt;div class=&quot;name&quot;&gt;扫码下载 OPPO 商城 App&lt;/div&gt; &lt;/div&gt; &lt;/a&gt; &lt;NuxtLink to=&quot;/login&quot; class=&quot;link&quot;&gt; &lt;i class=&quot;iconfont icon-user&quot;&gt;&lt;/i&gt; &lt;span&gt;登录&lt;/span&gt; &lt;/NuxtLink&gt; &lt;NuxtLink to=&quot;/register&quot; class=&quot;link&quot;&gt; &lt;span&gt;注册&lt;/span&gt; &lt;/NuxtLink&gt; &lt;a href=&quot;#&quot; class=&quot;link&quot;&gt; &lt;i class=&quot;iconfont icon-shoppingcart&quot;&gt;&lt;/i&gt; &lt;span&gt;购物车 &lt;/span&gt; &lt;span&gt;(0)&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;defineOptions(&#123; name: &#x27;AppHeader&#x27; &#125;)&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.app-header &#123; height: $appHeaderHeight; background-color: #000; @include elementSticky(0, 110); .link span &#123; opacity: 0.8; // 字体变暗 &#125; .content &#123; /* @include border(); */ height: 100%; @include normalFlex(); &amp;-left &#123; @include normalFlex(row, flex-start); align-items: center; .link &#123; margin-right: 24px; cursor: pointer; &#125; &#125; &amp;-right &#123; @include normalFlex(row, flex-end); align-items: center; .link &#123; padding: 0 14px; border-right: 1px solid #fff; &#125; .link:last-child &#123; border-right: none; &#125; i &#123; margin-right: 6px; &#125; .icon &#123; &amp;-user &#123; font-size: 12px; &#125; &amp;-shoppingcart &#123; font-size: 15px; &#125; &#125; .download &#123; position: relative; &amp;:hover .app &#123; display: block; &#125; .app &#123; display: none; position: absolute; top: 25px; left: 0; padding: 8px; min-width: 146px; box-shadow: 0 4px 8px 0 rgb(0 0 0 / 10%); z-index: 10000; &#125; .ecode &#123; width: 140px; height: 140px; margin-bottom: 4px; &#125; .name &#123; color: #000; &#125; &#125; &#125; &#125;&#125;&lt;/style&gt; 编写尾部将图片f-icon1到5 放到 public&#x2F;images 目录下，方便直接使用。编写 components/appFooter.vue文件。 &lt;template&gt; &lt;div class=&quot;app-footer&quot;&gt; &lt;div class=&quot;wrapper content&quot;&gt; &lt;div class=&quot;content-top&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;top-item&quot; v-for=&quot;item in footerIcons&quot; :key=&quot;item.id&quot;&gt; &lt;img :src=&quot;item.picStr&quot; :alt=&quot;item.title&quot; /&gt; &lt;div&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;content-center&quot;&gt; &lt;div class=&quot;center-item&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a class=&quot;first&quot; href=&quot;&quot;&gt;OPPO&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Find N 全新折叠旗舰&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO Find X5 Pro&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO Find X5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO Reno9 Pro+&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO Reno9 Pro&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO Reno9&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO Reno8&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO K10x&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO K10&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;center-item&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a class=&quot;first&quot; href=&quot;&quot;&gt;一加&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;一加 Ace Pro&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;一加 Ace&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;一加 Ace 竞速版&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;一加 10 Pro&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;一加手表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;一加 Buds Pro&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;一加 Buds Z2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;center-item&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a class=&quot;first&quot; href=&quot;&quot;&gt;智能硬件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO Watch 3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO 手环 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO Watch 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO Pad&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO Pad Air&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO Enco X2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO Enco Air2 Pro&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;OPPO Enco Air2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;connect&quot;&gt; &lt;img src=&quot;@/assets/images/phone.svg&quot; alt=&quot;phone&quot; /&gt; &lt;span&gt;在线客服&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;content-bottom&quot;&gt; &lt;div class=&quot;bottom-item&quot;&gt; &lt;a href=&quot;&quot;&gt; © 2004-2022 OPPO 版权所有粤ICP备14056724号&lt;/a&gt; &lt;span&gt;|&lt;/span&gt;&lt;a href=&quot;&quot;&gt;隐私政策&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;a href=&quot;&quot;&gt;用户使用协议&lt;/a&gt; &lt;span&gt;|&lt;/span&gt;&lt;a href=&quot;&quot;&gt;资质证照&lt;/a&gt;&lt;span&gt;|&lt;/span&gt;&lt;a href=&quot;&quot;&gt;知识产权&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;bottom-item&quot;&gt; &lt;img class=&quot;police&quot; src=&quot;@/assets/images/police.png&quot; alt=&quot;police&quot; /&gt; &lt;a href=&quot;#&quot;&gt;粤公安网备 44190002001939号&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;interface IFooterIcon &#123; id: number picStr: string title: string&#125;defineProps(&#123; footerIcons: &#123; type: Array&lt;IFooterIcon&gt;, default: () =&gt; [ &#123; id: 100, picStr: &#x27;/images/f-icon1.svg&#x27;, // 需要将图片放在public目录 title: &#x27;全国联保&#x27; &#125;, &#123; id: 100, picStr: &#x27;/images/f-icon2.svg&#x27;, title: &#x27;7天无理由退货&#x27; &#125;, &#123; id: 100, picStr: &#x27;/images/f-icon3.svg&#x27;, title: &#x27;官方换货保障&#x27; &#125;, &#123; id: 100, picStr: &#x27;/images/f-icon4.svg&#x27;, title: &#x27;满69元包邮&#x27; &#125;, &#123; id: 100, picStr: &#x27;/images/f-icon5.svg&#x27;, title: &#x27;900+ 家售后网点&#x27; &#125; ] &#125;&#125;)defineOptions(&#123; name: &#x27;AppFooter&#x27; &#125;)&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.app-footer &#123; padding-top: 42px; .content-top &#123; padding-bottom: 40px; @include normalFlex(); height: $appFooterTop; border-bottom: 1px solid rgba(0, 0, 0, 0.12); .top-item &#123; @include normalFlex(column, center); align-items: center; gap: 8px 0; font-size: 17px; color: rgba(0, 0, 0, 0.7); &#125; &#125; .content-center &#123; position: relative; margin: 42px 0; @include normalFlex(row, flex-start); height: $appFooterCenter; border-bottom: 1px sold rgba(0, 0, 0, 0.12); .center-item &#123; margin-right: 30px; a &#123; margin-bottom: 12px; line-height: 35px; white-space: nowrap; font-size: 17px; color: #535353; opacity: 0.8; &#125; .first &#123; opacity: 1; color: rgba(0, 0, 0, 0.87); &#125; &#125; .connect &#123; position: absolute; top: 0; right: 0; width: 173px; height: 51px; @include normalFlex(row, center); align-items: center; gap: 0 10px; font-size: 15px; color: #fff; background-color: #000; border-radius: 26px; cursor: pointer; &#125; &#125; .content-bottom &#123; margin-bottom: 30px; height: $appFooterBottom; .bottom-item &#123; margin-top: 14px; margin-right: 3px; font-size: 12px; color: #acabb0; a &#123; margin: 0 6px; color: #acabb0; &#125; .police &#123; /* position: relative; top: 4px; */ vertical-align: middle; &#125; &#125; &#125;&#125;&lt;/style&gt; 配置 SEO// nuxt.config.tsapp: &#123; head: &#123; meta: [ &#123; name: &#x27;description&#x27;, content: &#x27;OPPO专区，官方正品，最新最全的OPPO手机产品以及配件在线抢购！&#x27; &#125;, &#123; name: &#x27;keywords&#x27;, content: &#x27;OPPO商城，OPPO专区, OPPO手机，OPPO配件，OPPO, OPPO官网商城&#x27; &#125; ], link: [&#123; rel: &#x27;icon&#x27;, type: &#x27;image/x-icon&#x27;, href: &#x27;/logo.png&#x27; &#125;], noscript: [&#123; children: &#x27;Javascript is required&#x27; &#125;] &#125; &#125;, 配置 slug 页面slug 页面就是 404 页面。新建 pages/[...slug].vue &lt;template&gt; &lt;el-empty :image-size=&quot;200&quot; description=&quot;暂无此页面&quot; /&gt;&lt;/template&gt;&lt;script setup&gt;definePageMeta(&#123; name: &#x27;emptyPage&#x27;, layout: &#x27;empty&#x27;&#125;)&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.el-empty &#123; width: 100vw; height: 100vh; @include normalFlex(column, center); align-items: center;&#125;::v-deep(.el-empty__description p) &#123; font-size: 26px !important;&#125;&lt;/style&gt; 空布局layouts/empty.vue，给不显示 header 和 footer 的页面使用。通过 definePageMeta(&#123;layout: &#39;empty&#39;&#125;) 使用。 &lt;template&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/template&gt; 登录注册这里登录注册就不详细编写了，有个页面就可以，主要是熟悉 nuxt 的编写流程那些。 登录pages/login.vue &lt;script setup lang=&quot;ts&quot;&gt;definePageMeta(&#123; layout: &#x27;empty&#x27; &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt;Page: login&lt;/div&gt;&lt;/template&gt; 注册pages/register.vue &lt;script setup lang=&quot;ts&quot;&gt;definePageMeta(&#123; layout: &#x27;empty&#x27; &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt;Page: register&lt;/div&gt;&lt;/template&gt; 编写主页剩下内容因为主页现在剩下的内容在其他两个页面时可以复用的，所以采用组件可复用形式。 下面的组件内容，均是请求完数据后的代码数据，这里不展示静态的代码结构。 编写顺序： 导航。 统一组件：轮播图、分类、单个分类信息。 OnePlus 专区、智能硬件：复用统一组件 首页的导航设置其点击跳转到详情页 修改默认布局layouts/default.vue。这里将导航放置到默认布局中，能够让使用默认布局的页面直接复用。 &lt;template&gt; &lt;div&gt; &lt;!-- 头部 --&gt; &lt;app-header /&gt; &lt;!-- 导航 --&gt; &lt;navbar :navbars=&quot;homeInfoStore.navbars&quot; /&gt; &lt;slot&gt;&lt;/slot&gt; &lt;!-- 尾部 --&gt; &lt;app-footer /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; getHomeInfoReq &#125; from &#x27;~/service/home&#x27;import &#123; useHomeInfoStore &#125; from &#x27;~/store/home&#x27;import type &#123; Categorys, Navbars &#125; from &#x27;~/store/home&#x27;import homeInfoSave from &#x27;~/service/saveData/homeInfo&#x27;// 首页和默认布局中都获取了首页数据。// 首页和其余页面的切换都需要重新获取首页数据// 不同的是，默认布局只在详情页才进行获取首页数据。const homeInfoStore = useHomeInfoStore() // pinia 仓库// 在详情页刷新时请求首页数据if (homeInfoStore.banners.length === 0) &#123; const &#123; data &#125; = await getHomeInfoReq() // 请求首页数据 // 错误处理 const errorSolve = () =&gt; &#123; // client 和 server 需要分开处理 if (import.meta.client) &#123; ElMessage.error(&#x27;获取首页数据失败，使用备份数据&#x27;) &#125; else &#123; console.log(&#x27;获取首页数据失败，使用备份数据&#x27;) &#125; // 使用备份数据 const homeInfo = ref(homeInfoSave.data) // 更新pinia仓库数据 homeInfoStore.updateNavbar(homeInfo.value.navbars as Navbars) homeInfoStore.updateBanner(homeInfo.value.banners) homeInfoStore.updateCategory(homeInfo.value.categorys as unknown as Categorys) &#125; // 接口请求失败则使用备份数据 if (!data.value) &#123; errorSolve() &#125; else &#123; const &#123; code, data: curData &#125; = data.value if (code === 200) &#123; // 更新pinia仓库数据 homeInfoStore.updateNavbar(curData.navbars) homeInfoStore.updateBanner(curData.banners) homeInfoStore.updateCategory(curData.categorys) &#125; else &#123; // 返回数据失败则使用备份数据 errorSolve() &#125; &#125;&#125;&lt;/script&gt; 编写导航导航组件components/navbar.vue &lt;template&gt; &lt;div class=&quot;navbar&quot;&gt; &lt;div class=&quot;wrapper content&quot;&gt; &lt;!-- logo --&gt; &lt;NuxtLink to=&quot;/&quot; class=&quot;content-left&quot;&gt; &lt;!-- logo图片 --&gt; &lt;img src=&quot;/logo.png&quot; class=&quot;logo&quot; alt=&quot;&quot; /&gt; &lt;!-- logo title，设置有助于 SEO--&gt; &lt;!-- 设置 z-index 将其设置到页面外 --&gt; &lt;h1 class=&quot;title&quot;&gt;OPPO官网&lt;/h1&gt; &lt;/NuxtLink&gt; &lt;ul class=&quot;content-center&quot;&gt; &lt;template v-if=&quot;navbars.length &gt; 0&quot;&gt; &lt;li :class=&quot;&#123; active: item.title === curTabName &#125;&quot; @click=&quot;changeTabHandler(item.title as string)&quot; v-for=&quot;item in navbars&quot; :key=&quot;item.id&quot; &gt; &lt;NuxtLink class=&quot;link&quot; :to=&quot;getPathName(item.title as string)&quot;&gt; &#123;&#123; item.title &#125;&#125; &lt;/NuxtLink&gt; &lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; &lt;!-- 搜索框组件 --&gt; &lt;search class=&quot;content-right&quot;&gt;&lt;/search&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import type &#123; INavbar &#125; from &#x27;~/store/home&#x27;defineProps(&#123; navbars: &#123; type: Array&lt;INavbar&gt;, default: () =&gt; [] &#125;&#125;)const route = useRoute()const paths: any = reactive(&#123; OPPO专区: &#x27;/&#x27;, OnePlus专区: &#x27;/one-plus&#x27;, 智能硬件: &#x27;/intelligent&#x27;, 服务: &#x27;/oppo-service&#x27;&#125;)const curTabName = ref&lt;string&gt;(&#x27;OPPO专区&#x27;)// 切换tabconst changeTabHandler = (tabName: string) =&gt; &#123; curTabName.value = tabName&#125;// 获取路径// 这里需要根据传递的title获取具体的路径，通过函数调用，所以返回的一个函数const getPathName = computed(() =&gt; &#123; return (title: string) =&gt; &#123; return paths[title] || &#x27;/&#x27; &#125;&#125;)// 页面加载完成后，根据当前路径激活当前 tabonMounted(() =&gt; &#123; const curPath = route.path // 遍历 paths，找到当前路径对应的 tabName for (const [key, value] of Object.entries(paths)) &#123; if (value === curPath) &#123; curTabName.value = key break &#125; &#125;&#125;)&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.navbar &#123; @include elementSticky(36px); height: $navBarHeight; border-bottom: 1px solid rgba(0, 0, 0, 0.06); background-color: #fff; z-index: 99; .content &#123; @include normalFlex(row, flex-start); align-items: center; height: 100%; &amp;-left &#123; display: inline-block; width: $logoWidth; height: $logoHeight; .logo &#123; height: 100%; &#125; .title &#123; margin: 0; height: 0; text-indent: -999px; &#125; &#125; &amp;-center &#123; @include normalFlex(); margin-left: 60px; width: 530px; .link &#123; opacity: 0.55; font-size: 14px; color: #000; &amp;:hover &#123; opacity: 1; &#125; &#125; .active .link &#123; opacity: 1; &#125; &#125; &amp;-right &#123; margin-left: 50px; &#125; &#125;&#125;&lt;/style&gt; 获取数据首页的数据包含：菜单、轮播图、分类。 封装 useFetchservice/index.ts import type &#123; AsyncData, UseFetchOptions &#125; from &#x27;#app&#x27;// 网络请求地址const BASE_URL = &#x27;http://codercba.com:9060/oppo-nuxt/api&#x27;export type methodType = &#x27;GET&#x27; | &#x27;POST&#x27; // 请求方式// 响应数据接口export interface IResponseResult&lt;T&gt; &#123; code: number data: T&#125;class RXRequest &#123; request&lt;T&gt;( url: string, method: methodType, data?: any, options?: UseFetchOptions&lt;T, any, any&gt; ): Promise&lt;AsyncData&lt;T, any&gt;&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const newOptions: UseFetchOptions&lt;T, any, any&gt; = &#123; baseURL: BASE_URL, method: method || &#x27;GET&#x27;, ...options &#125; if (method === &#x27;GET&#x27;) &#123; newOptions.query = data &#125; else &#123; newOptions.body = data &#125; useFetch&lt;T&gt;(url, newOptions as any) .then(res =&gt; &#123; resolve(res as AsyncData&lt;T, any&gt;) &#125;) .catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125; get&lt;T&gt;(url: string, data?: any, options?: UseFetchOptions&lt;T, any, any&gt;) &#123; return this.request&lt;T&gt;(url, &#x27;GET&#x27;, data, options) &#125; post&lt;T&gt;(url: string, params?: any, options?: UseFetchOptions&lt;T, any, any&gt;) &#123; return this.request&lt;T&gt;(url, &#x27;POST&#x27;, params, options) &#125;&#125;export default new RXRequest() 请求首页数据service/home.ts。这里的 ts 类型在 store/home.ts 中编写的。可以先写 any，然后再根据请求的数据来编写 ts 类型。 import RXRequest from &#x27;./index&#x27;import type &#123; IResponseResult &#125; from &#x27;./index&#x27;import type &#123; IHomeInfo &#125; from &#x27;@/store/home&#x27;// 首页（OPPO专区）数据请求export const getHomeInfoReq = () =&gt; &#123; return RXRequest.get&lt;IResponseResult&lt;IHomeInfo&gt;&gt;(&#x27;/home/info&#x27;, &#123; type: &#x27;oppo&#x27; &#125;)&#125;// OnePlus专区数据请求export const getHomeOnePlusInfoReq = () =&gt; &#123; return RXRequest.get&lt;IResponseResult&lt;IHomeInfo&gt;&gt;(&#x27;/home/info&#x27;, &#123; type: &#x27;onePlus&#x27; &#125;)&#125;// 智能硬件数据请求export const getHomeIntelligentInfoReq = () =&gt; &#123; return RXRequest.get&lt;IResponseResult&lt;IHomeInfo&gt;&gt;(&#x27;/home/info&#x27;, &#123; type: &#x27;intelligent&#x27; &#125;)&#125; 配置 pinia这里我们采用 pinia 保存数据。 安装：npm i pinia @nuxt/pinia 配置 nuxt.config.ts： export default defineNuxtConfig(&#123; modules: [&#x27;@pinia/nuxt&#x27;]&#125;) 保存首页数据store/home.ts import &#123; defineStore &#125; from &#x27;pinia&#x27;// navbar 接口export interface INavbar &#123; id?: string | number title?: string type?: string | number showName?: number url?: string jsonUrl?: string clickUrl?: string jsonClickUrl?: string beginAt?: null endAt?: null seq?: number labelDetailss?: [] link?: string isLogin?: number moduleCode?: string rows?: number cols?: number maxProductNum?: number&#125;// banner 接口export interface IBanner &#123; id?: string | number picStr?: string link?: string&#125;// activityList 接口export interface IActivityList &#123; type?: string | number activityInfo?: string&#125;// activityList 类型export type activityList = IActivityList[]// productDetailss 接口export interface IProductDetailss &#123; id?: string | number skuId?: number title?: string secondTitle?: string thirdTitle?: string url?: string jsonUrl?: string video?: string seq?: number configKeyLattice?: number latticeIndex?: number configProductType?: number goodsSpuId?: number goodsSpuName?: string isShowIcon?: number topIcon?: string cardType?: number backColor?: string liveInfoJson?: null businessInfoJson?: null priceInfo?: &#123; originalPrice?: string price?: string marketPrice?: string buyPrice?: string prefix?: string suffix?: string currencyTag?: string &#125; price?: number originalPrice?: null categoryId?: number link?: string isLogin?: number marketPrice?: string nameLabel?: null imageLabel?: null extendList?: null heytapInfo?: null activityList?: activityList placeholderLabel?: &#123; type?: number | string activityInfo?: string &#125; vipDiscounts?: null nameLabelWidth?: null nameLabelHeight?: null pricePrefix?: string priceSuffix?: null goodsTopCategoryId?: number goodsTopCategoryName?: string goodsCategoryId?: number goodsCategoryName?: string skuName?: string cardInfoType?: null liveUrl?: null storage?: null seckill?: null rankInfo?: null businessLink?: string sellPoints?: null commentCount?: null commentRate?: null interenve?: boolean productDetailLabelss?: any[]&#125;// productDetailss 类型export type ProductDetailss = IProductDetailss[]// category 接口export interface ICategory &#123; id?: string | number picStr?: string title?: string type?: string | number url?: string moduleCode?: string productDetailss?: ProductDetailss link?: string&#125;export type Navbars = INavbar[] // navbars 类型export type Banners = IBanner[] // banners 类型export type Categorys = ICategory[] // categorys 类型// homeInfo 接口export interface IHomeInfo &#123; navbars: Navbars banners: Banners categorys: Categorys&#125;export const useHomeInfoStore = defineStore(&#x27;homeInfo&#x27;, &#123; state: (): IHomeInfo =&gt; (&#123; navbars: [], // 导航数据 banners: [], // 轮播图数据 categorys: [] // 分类数据 &#125;), actions: &#123; // 更新导航数据 updateNavbar(payload: Navbars) &#123; this.navbars = payload &#125;, // 更新轮播图数据 updateBanner(payload: Banners) &#123; this.banners = payload &#125;, // 更新分类数据 updateCategory(payload: Categorys) &#123; this.categorys = payload &#125; &#125;&#125;) 统一管理组件OPPO 专区、OnePlus 专区、智能硬件中均存在 轮播图、分类、单个分类信息，且结构类似，所以将这几个部分单独在一个组件中进行引用，后续直接单独引用这一个组件即可。 components/baseContent.vue。这个组件包含主页剩下的所有组件，方便在后面两个页面的引入。 &lt;template&gt; &lt;div&gt; &lt;!-- 轮播图 --&gt; &lt;swiper :banners=&quot;banners&quot; /&gt; &lt;!-- 分类导航 --&gt; &lt;tab-category :categorys=&quot;categorys&quot; /&gt; &lt;!-- 分类详情 --&gt; &lt;template v-for=&quot;category in categorys&quot; :key=&quot;category.id&quot;&gt; &lt;!-- 单个分类详情 --&gt; &lt;category-section :category=&quot;category&quot; /&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import type &#123; IBanner, ICategory &#125; from &#x27;~/store/home&#x27;defineProps(&#123; banners: &#123; type: Array&lt;IBanner&gt;, default: () =&gt; [] &#125;, categorys: &#123; type: Array&lt;ICategory&gt;, default: () =&gt; [] &#125;&#125;)&lt;/script&gt; 修改主页pages/index.vue &lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;!-- 页面统一管理组件 --&gt; &lt;base-content :banners=&quot;homeInfoStore.banners&quot; :categorys=&quot;homeInfoStore.categorys&quot; class=&quot;wrapper&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; getHomeInfoReq &#125; from &#x27;~/service/home&#x27;import &#123; useHomeInfoStore &#125; from &#x27;~/store/home&#x27;import type &#123; Categorys, Navbars &#125; from &#x27;~/store/home&#x27;import homeInfoSave from &#x27;~/service/saveData/homeInfo&#x27;// 首页和默认布局中都获取了首页数据。// 首页和其余页面的切换都需要重新获取首页数据// 不同的是，默认布局只在详情页才进行获取首页数据。const homeInfoStore = useHomeInfoStore() // pinia 仓库const &#123; data &#125; = await getHomeInfoReq() // 请求首页数据// 错误处理const errorSolve = () =&gt; &#123; // client 和 server 需要分开处理 if (import.meta.client) &#123; ElMessage.error(&#x27;获取首页数据失败，使用备份数据&#x27;) &#125; else &#123; console.log(&#x27;获取首页数据失败，使用备份数据&#x27;) &#125; // 使用备份数据 const homeInfo = ref(homeInfoSave.data) // 更新pinia仓库数据 homeInfoStore.updateNavbar(homeInfo.value.navbars as Navbars) homeInfoStore.updateBanner(homeInfo.value.banners) homeInfoStore.updateCategory(homeInfo.value.categorys as unknown as Categorys)&#125;// 接口请求失败则使用备份数据if (!data.value) &#123; errorSolve()&#125; else &#123; const &#123; code, data: curData &#125; = data.value if (code === 200) &#123; // 更新pinia仓库数据 homeInfoStore.updateNavbar(curData.navbars) homeInfoStore.updateBanner(curData.banners) homeInfoStore.updateCategory(curData.categorys) &#125; else &#123; // 返回数据失败则使用备份数据 errorSolve() &#125;&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.home &#123; background-color: $bgGrayColor;&#125;&lt;/style&gt; 编写轮播图components/swiper.vue &lt;template&gt; &lt;div class=&quot;swiper&quot;&gt; &lt;el-carousel height=&quot;480px&quot; trigger=&quot;click&quot; indicator-position=&quot;none&quot; @change=&quot;changeHandler&quot; :active-index=&quot;activeIndex&quot; &gt; &lt;el-carousel-item v-for=&quot;item in banners&quot; :key=&quot;item.id&quot;&gt; &lt;img class=&quot;pic-str&quot; :src=&quot;item.picStr&quot; alt=&quot;OPPO&quot; /&gt; &lt;/el-carousel-item&gt; &lt;/el-carousel&gt; &lt;!-- 指示器 --&gt; &lt;ul class=&quot;dots&quot;&gt; &lt;li class=&quot;dot&quot; v-for=&quot;(item, index) in banners&quot; :key=&quot;item.id&quot; :class=&quot;&#123; active: index === activeIndex &#125;&quot; &gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import type &#123; IBanner &#125; from &#x27;~/store/home&#x27;defineProps(&#123; banners: &#123; type: Array&lt;IBanner&gt;, default: () =&gt; [] &#125;&#125;)const activeIndex = ref&lt;number&gt;(0)const changeHandler = (index: number) =&gt; &#123; activeIndex.value = index&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.swiper &#123; position: relative; padding-top: 36px; .pic-str &#123; width: 100%; height: 100%; border-radius: 10px; &#125; .dots &#123; position: absolute; bottom: 0; left: 0; @include normalFlex(row, center); align-items: center; gap: 0 10px; width: 100%; height: 40px; .dot &#123; opacity: 0.8; width: 10px; height: 10px; background-color: #fff; border-radius: 10px; box-sizing: border-box; cursor: pointer; &#125; .active &#123; opacity: 1; width: 12px; height: 12px; background-color: transparent; border: 1px solid #fff; &#125; &#125;&#125;&lt;/style&gt; 编写分类components/tabCategory.vue &lt;template&gt; &lt;div class=&quot;tab-category wrapper&quot;&gt; &lt;template v-for=&quot;item in categorys&quot; :key=&quot;item.id&quot;&gt; &lt;!-- 这里跳转详情页只在 OPPO专区（首页）的分类中进行跳转，其他页面不需要跳转 --&gt; &lt;NuxtLink :to=&quot;$route.path === &#x27;/&#x27; ? `/category-detail?type=$&#123;item.type&#125;` : &#x27;&#x27;&quot;&gt; &lt;div class=&quot;category-item&quot;&gt; &lt;img class=&quot;pic-str&quot; :src=&quot;item.picStr&quot; alt=&quot;OPPO&quot; /&gt; &lt;div class=&quot;title&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/NuxtLink&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import type &#123; ICategory &#125; from &#x27;~/store/home&#x27;defineProps(&#123; categorys: &#123; type: Array&lt;ICategory&gt;, default: () =&gt; [] &#125;&#125;)&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.tab-category &#123; margin-top: 40px; @include normalFlex(); align-items: center; .category-item &#123; @include normalFlex(column, center); align-items: center; cursor: pointer; .pic-str &#123; width: 80px; height: 80px; &#125; .title &#123; margin-top: 16px; max-width: 120px; text-align: center; font-size: 16px; color: #000; /* @include border(); */ &#125; &#125;&#125;&lt;/style&gt; 编写单个分类信息这里将每个分类内容的 titile 和 内容 拆分为各自单独的组件，内容后面可以在详情页复用。 分类主页components/categorySection.vue &lt;template&gt; &lt;!-- 分类信息存在才展示这个页面，没有不展示 --&gt; &lt;div class=&quot;category-section&quot; v-if=&quot;(category?.productDetailss ?? []).length &gt; 0&quot;&gt; &lt;!-- 分类标题 --&gt; &lt;category-title :title=&quot;category?.title&quot; /&gt; &lt;!-- 分类item，包含大图介绍和小的item --&gt; &lt;category-grid :categoryUrl=&quot;category?.url&quot; :productDetailss=&quot;category?.productDetailss&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import type &#123; ICategory &#125; from &#x27;~/store/home&#x27;interface prop &#123; category?: ICategory&#125;const &#123; category &#125; = defineProps&lt;prop&gt;()&lt;/script&gt; 分类 titlecomponents/categoryTitle.vue &lt;template&gt; &lt;div class=&quot;category-title&quot;&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;defineProps(&#123; title: String &#125;)&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.category-title &#123; h2 &#123; margin: 0 0 24px 0; padding-top: 60px; font-size: 24px; font-weight: 500; &#125;&#125;&lt;/style&gt; 分类内容主页components/categoryGrid.vue &lt;template&gt; &lt;div class=&quot;category-grid wrapper&quot;&gt; &lt;!-- 详情页不展示分类介绍图片 --&gt; &lt;!-- 可以在详情页传入空置或者使用布尔类型直接判断 --&gt; &lt;div class=&quot;category-grid-item first&quot; v-if=&quot;categoryUrl.length &gt; 0&quot;&gt; &lt;img :src=&quot;categoryUrl&quot; alt=&quot;OPPO&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;category-grid-item&quot; v-for=&quot;productDetail in productDetailss&quot; :key=&quot;productDetail.id&quot; &gt; &lt;!-- 单个item信息 --&gt; &lt;grid-item :productDetail /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import type &#123; IProductDetailss &#125; from &#x27;~/store/home&#x27;defineProps(&#123; productDetailss: &#123; type: Array&lt;IProductDetailss&gt;, default: () =&gt; [] &#125;, // 大图片，占两个位置，40%的宽度 categoryUrl: &#123; type: String, default: &#x27;&#x27; &#125;&#125;)&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.category-grid &#123; @include normalFlex(row, flex-start); flex-wrap: wrap; /* 使其与上面的内容对齐 */ width: $contentWidth + 18px; .category-grid-item &#123; margin-bottom: 18px; padding-right: 18px; width: 20%; height: $gridItemHeight; box-sizing: border-box; background-color: $bgGrayColor; cursor: pointer; &#125; .first &#123; width: 40%; img &#123; width: 100%; height: 100%; transition: all 0.2s linear; &amp;:hover &#123; @include hoverEffect(); &#125; &#125; &#125;&#125;&lt;/style&gt; 单个 itemcomponents/gridItem.vue &lt;template&gt; &lt;div class=&quot;grid-item&quot;&gt; &lt;div class=&quot;item-img&quot;&gt;&lt;img class=&quot;img&quot; :src=&quot;productDetail.url&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;item-title&quot;&gt;&#123;&#123; productDetail.title &#125;&#125;&lt;/div&gt; &lt;div class=&quot;item-labels&quot;&gt; &lt;!-- 没有活动内容的显示&#x27;敬请期待&#x27; --&gt; &lt;template v-if=&quot;(productDetail.activityList ?? []).length &gt; 0&quot;&gt; &lt;span class=&quot;label&quot; v-for=&quot;item in productDetail.activityList&quot; :key=&quot;item.type&quot;&gt; &#123;&#123; item.activityInfo &#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;span class=&quot;label&quot; v-else&gt;敬请期待&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;item-price&quot;&gt; &lt;span class=&quot;prefix&quot;&gt; &#123;&#123; productDetail.priceInfo?.prefix &#125;&#125;&#123;&#123; productDetail.priceInfo?.currencyTag &#125;&#125; &lt;/span&gt; &lt;!-- 没有提供价格则显示&#x27;暂无报价&#x27; --&gt; &lt;span class=&quot;price&quot;&gt;&#123;&#123; productDetail.priceInfo?.buyPrice || &#x27;暂无报价&#x27; &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import type &#123; IProductDetailss &#125; from &#x27;~/store/home&#x27;interface prop &#123; productDetail: IProductDetailss&#125;const &#123; productDetail &#125; = defineProps&lt;prop&gt;()&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.grid-item &#123; background-color: #fff; text-align: center; border-radius: 8px; transition: all 0.2s linear; &amp;:hover &#123; @include hoverEffect(); &#125; .item-img .img &#123; margin-top: 14px; margin-bottom: 7px; width: $imgWidth; height: $imgHeight; &#125; .item-title &#123; margin-top: 2px; padding: 0 20px; font-size: 15px; font-weight: 500; text-align: center; @include textEllipsis(); &#125; .item-labels &#123; @include normalFlex(row, center); align-items: center; height: 45px; /* @include border(); */ .label &#123; display: inline-block; margin: 0 4px 4px 0; padding: 1px 2px; color: $priceColor; font-size: 13px; border: 1px solid $priceColor; &#125; &#125; .item-price &#123; padding-bottom: 40px; .prefix &#123; color: $priceColor; font-size: 13px; &#125; .price &#123; line-height: 1; color: $priceColor; font-size: 20px; &#125; &#125;&#125;&lt;/style&gt; OnePlus 专区pages/one-plus.vue &lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;!-- 页面统一管理组件 --&gt; &lt;base-content :banners=&quot;homeInfoStore.banners&quot; :categorys=&quot;homeInfoStore.categorys&quot; class=&quot;wrapper&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; getHomeOnePlusInfoReq &#125; from &#x27;~/service/home&#x27;import &#123; useHomeInfoStore &#125; from &#x27;~/store/home&#x27;import type &#123; Categorys, Navbars &#125; from &#x27;~/store/home&#x27;import homeOnePlusInfoSave from &#x27;~/service/saveData/onePlusInfo&#x27;const homeInfoStore = useHomeInfoStore() // pinia 仓库const &#123; data &#125; = await getHomeOnePlusInfoReq() // 请求数据// 错误处理const errorSolve = () =&gt; &#123; // client 和 server 需要分开处理 if (import.meta.client) &#123; ElMessage.error(&#x27;获取OnePlus专区数据失败，使用备份数据&#x27;) &#125; else &#123; console.log(&#x27;获取OnePlus专区数据失败，使用备份数据&#x27;) &#125; // 使用备份数据 const homeOnePlusInfo = ref(homeOnePlusInfoSave.data) // 更新pinia仓库数据 homeInfoStore.updateNavbar(homeOnePlusInfo.value.navbars as Navbars) homeInfoStore.updateBanner(homeOnePlusInfo.value.banners) homeInfoStore.updateCategory(homeOnePlusInfo.value.categorys as unknown as Categorys)&#125;// 接口请求失败则使用备份数据if (!data.value) &#123; errorSolve()&#125; else &#123; const &#123; code, data: curData &#125; = data.value if (code === 200) &#123; // 更新pinia仓库数据 homeInfoStore.updateNavbar(curData.navbars) homeInfoStore.updateBanner(curData.banners) homeInfoStore.updateCategory(curData.categorys) &#125; else &#123; // 返回数据失败则使用备份数据 errorSolve() &#125;&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.home &#123; background-color: $bgGrayColor;&#125;&lt;/style&gt; 智能硬件pages/intelligent.vue &lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;!-- 页面统一管理组件 --&gt; &lt;base-content :banners=&quot;homeInfoStore.banners&quot; :categorys=&quot;homeInfoStore.categorys&quot; class=&quot;wrapper&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; getHomeIntelligentInfoReq &#125; from &#x27;~/service/home&#x27;import &#123; useHomeInfoStore &#125; from &#x27;~/store/home&#x27;import type &#123; Categorys, Navbars &#125; from &#x27;~/store/home&#x27;import homeIntelligentInfoSave from &#x27;~/service/saveData/homeIntelligentInfo&#x27;const homeInfoStore = useHomeInfoStore() // pinia 仓库const &#123; data &#125; = await getHomeIntelligentInfoReq() // 请求数据// 错误处理const errorSolve = () =&gt; &#123; // client 和 server 需要分开处理 if (import.meta.client) &#123; ElMessage.error(&#x27;获取智能硬件数据失败，使用备份数据&#x27;) &#125; else &#123; console.log(&#x27;获取智能硬件数据失败，使用备份数据&#x27;) &#125; // 使用备份数据 const homeIntelligentInfo = ref(homeIntelligentInfoSave.data) // 更新pinia仓库数据 homeInfoStore.updateNavbar(homeIntelligentInfo.value.navbars as Navbars) homeInfoStore.updateBanner(homeIntelligentInfo.value.banners) homeInfoStore.updateCategory(homeIntelligentInfo.value.categorys as unknown as Categorys)&#125;// 接口请求失败则使用备份数据if (!data.value) &#123; errorSolve()&#125; else &#123; const &#123; code, data: curData &#125; = data.value if (code === 200) &#123; // 更新pinia仓库数据 homeInfoStore.updateNavbar(curData.navbars) homeInfoStore.updateBanner(curData.banners) homeInfoStore.updateCategory(curData.categorys) &#125; else &#123; // 返回数据失败则使用备份数据 errorSolve() &#125;&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.home &#123; background-color: $bgGrayColor;&#125;&lt;/style&gt; 服务pages/oppo-service.vue。服务只是一个简单的页面，并没有做相关的代码编写。 &lt;template&gt; &lt;div&gt;Page: oppo-service&lt;/div&gt;&lt;/template&gt; 详情pages/category-detail.vue &lt;template&gt; &lt;div class=&quot;oppo-detail&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;el-tabs class=&quot;oppo-tabs&quot; v-model=&quot;activeName&quot;&gt; &lt;template v-for=&quot;item in detailData&quot; :key=&quot;item?.id&quot;&gt; &lt;el-tab-pane :label=&quot;item?.title&quot; :name=&quot;item?.title&quot;&gt; &lt;category-grid :categoryUrl=&quot;&#x27;&#x27;&quot; :product-detailss=&quot;item?.productDetailss&quot; /&gt; &lt;/el-tab-pane&gt; &lt;/template&gt; &lt;/el-tabs&gt; &lt;el-divider&gt; &lt;span class=&quot;no-more&quot;&gt;没有更多&lt;/span&gt; &lt;/el-divider&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; getDetailReq &#125; from &#x27;~/service/detail&#x27;import detailInfoSave from &#x27;~/service/saveData/detailInfo&#x27;import type &#123; oppoType &#125; from &#x27;~/service/detail&#x27;import type &#123; IProductDetailss &#125; from &#x27;~/store/detail&#x27;const route = useRoute()const &#123; data &#125; = await getDetailReq(route.query.type as oppoType)const detailData = reactive&lt;IProductDetailss&gt;(&#123;&#125;) // 详情数据const activeName = ref(&#x27;&#x27;)// 错误处理const errorSolve = () =&gt; &#123; // client 和 server 需要分开处理 if (import.meta.client) &#123; ElMessage.error(&#x27;获取详情数据失败，使用备份数据&#x27;) &#125; else &#123; console.log(&#x27;获取详情数据失败，使用备份数据&#x27;) &#125; // 使用备份数据 const detailInfo = ref(detailInfoSave.data) Object.assign(detailData, detailInfo.value) activeName.value = detailInfo.value[0].title as string&#125;if (!data.value) &#123; errorSolve()&#125; else &#123; const &#123; code, data: curData &#125; = data.value if (code === 200) &#123; Object.assign(detailData, curData) activeName.value = curData[0].title as string &#125; else &#123; errorSolve() &#125;&#125;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.oppo-detail &#123; padding: 8px 0 60px 0; background-color: $bgGrayColor; .oppo-tabs &#123; :deep(.el-tabs__header) &#123; background-color: #fff; &#125; :deep(.el-tabs__nav-wrap) &#123; padding: 0 52px; height: 48px; /* 底部线 */ &amp;::after &#123; background-color: #fff; &#125; /* 按钮 */ .el-tabs__nav-prev, .el-tabs__nav-next &#123; width: 48px; .el-icon, svg &#123; width: 25px; height: 25px; &#125; svg &#123; position: relative; top: 10px; &#125; &#125; .el-tabs__active-bar &#123; background-color: $priceColor; &#125; &#125; :deep(.el-tabs__item) &#123; position: relative; padding-top: 5px; opacity: 0.6; height: 48px; font-weight: 400; &amp;:hover, &amp;.is-active &#123; color: $priceColor; &#125; &#125; &#125; .no-more &#123; opacity: 0.5; font-size: 18px; color: #343a40; &#125;&#125;&lt;/style&gt; 提取代码前面看到主页的三个页面都有一段类似的 JS 代码，功能是去请求当前页的数据和配置备用数据。 我们就可以将这部分代码抽取出来，将其封装为一个工具函数，在需要使用的页面进行调用和传参即可。 工具函数utils/reqUnite.ts import type &#123; IResponseResult &#125; from &#x27;~/service&#x27;import type &#123; Banners, Categorys, IHomeInfo, Navbars &#125; from &#x27;~/store/home&#x27;// dataSave 类型为 any 是不想去重新调整数据的类型export default function reqUnite( homeInfoStore: &#123; updateNavbar: (navbars: Navbars) =&gt; void updateBanner: (banners: Banners) =&gt; void updateCategory: (categorys: Categorys) =&gt; void &#125;, data: Ref&lt;IResponseResult&lt;IHomeInfo&gt;&gt;, dataSave: any) &#123; // 错误处理 const errorSolve = () =&gt; &#123; // client 和 server 需要分开处理 if (import.meta.client) &#123; ElMessage.error(&#x27;获取首页数据失败，使用备份数据&#x27;) &#125; else &#123; console.log(&#x27;获取首页数据失败，使用备份数据&#x27;) &#125; // 使用备份数据 const save = ref(dataSave.data) // 更新pinia仓库数据 homeInfoStore.updateNavbar(save.value.navbars as Navbars) homeInfoStore.updateBanner(save.value.banners) homeInfoStore.updateCategory(save.value.categorys as unknown as Categorys) &#125; // 接口请求失败则使用备份数据 if (!data.value) &#123; errorSolve() &#125; else &#123; const &#123; code, data: curData &#125; = data.value if (code === 200) &#123; // 更新pinia仓库数据 homeInfoStore.updateNavbar(curData.navbars) homeInfoStore.updateBanner(curData.banners) homeInfoStore.updateCategory(curData.categorys) &#125; else &#123; // 返回数据失败则使用备份数据 errorSolve() &#125; &#125;&#125; 修改主页相关代码OPPO 专区import &#123; getHomeInfoReq &#125; from &#x27;~/service/home&#x27;import homeInfoSave from &#x27;~/service/saveData/homeInfo&#x27;import &#123; useHomeInfoStore &#125; from &#x27;~/store/home&#x27;// 首页和默认布局中都获取了首页数据。// 首页和其余页面的切换都需要重新获取首页数据// 不同的是，默认布局只在详情页才进行获取首页数据。const homeInfoStore = useHomeInfoStore() // pinia 仓库const &#123; data &#125; = await getHomeInfoReq() // 请求首页数据reqUnite(homeInfoStore, data, homeInfoSave) // 统一处理请求数据 OnePlus 专区import &#123; getHomeOnePlusInfoReq &#125; from &#x27;~/service/home&#x27;import &#123; useHomeInfoStore &#125; from &#x27;~/store/home&#x27;import homeOnePlusInfoSave from &#x27;~/service/saveData/onePlusInfo&#x27;const homeInfoStore = useHomeInfoStore() // pinia 仓库const &#123; data &#125; = await getHomeOnePlusInfoReq() // 请求数据reqUnite(homeInfoStore, data, homeOnePlusInfoSave) // 统一处理请求数据 智能硬件import &#123; getHomeIntelligentInfoReq &#125; from &#x27;~/service/home&#x27;import &#123; useHomeInfoStore &#125; from &#x27;~/store/home&#x27;import homeIntelligentInfoSave from &#x27;~/service/saveData/homeIntelligentInfo&#x27;const homeInfoStore = useHomeInfoStore() // pinia 仓库const &#123; data &#125; = await getHomeIntelligentInfoReq() // 请求数据","categories":[{"name":"SSR","slug":"SSR","permalink":"http://ran-up.github.io/categories/SSR/"}],"tags":[{"name":"nuxt","slug":"nuxt","permalink":"http://ran-up.github.io/tags/nuxt/"}]},{"title":"nuxt初体验","slug":"SSR/nuxt/nuxt初体验","date":"2025-01-29T09:40:41.000Z","updated":"2025-02-15T04:03:09.320Z","comments":true,"path":"2025/01/29/SSR/nuxt/nuxt初体验/","link":"","permalink":"http://ran-up.github.io/2025/01/29/SSR/nuxt/nuxt%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"","text":"基础概念SSR：Server side Render，服务器端渲染。 SPA：Client side Render，客户端渲染。 新建项目命令：npx nuxi init &lt;project-name&gt; 创建项目报错新建项目运行报错信息： Failed to download template from registry: Failed to download https://raw.githubusercontent.com/nuxt/starter/templates/templates/v3.json: TypeError: fetch failed 原因：DNS 对 Nuxt 服务器域名会解析失败 解决办法：在 hosts 文件中直接将主机映射到对应 IP 上。 步骤： 去 查询IP 的网址查询 raw.githubusercontent.com 的 IP 地址。 windows 将 上面的信息添加到 hosts 文件中。 windows 的路径：C:\\Windows\\System32\\drivers\\etc Mac 的路径：&#x2F;etc&#x2F;hosts 185.199.108.133 raw.githubusercontent.com# 185.199.109.133 raw.githubusercontent.com# 185.199.110.133 raw.githubusercontent.com# 185.199.111.133 raw.githubusercontent.com 重新打开一个终端进行项目创建。如果不成功则注释掉换下一个 ip 映射测试。我这里第三个成功了。 目录结构 pages&#x2F; – 目录是可选的， 如果不存在，则不包含 vue-router 依赖。 如果存在，请使用 &lt;NuxtPage&gt; 组件 &lt;template&gt; &lt;div&gt; &lt;NuxtLayout&gt; &lt;NuxtPage/&gt; &lt;/NuxtLayout&gt; &lt;/div&gt;&lt;/template&gt; 由于 &lt;NuxtPage&gt; 在内部使用的是 Vue 的 &lt;Suspense&gt; 组件，因此无法将其设置为根组件。 内置组件因为这些组件名称与本机 HTML 元素匹配，所以它们在模板中必须大写。 欢迎页面组件&lt;NuxtWelcome&gt; 欢迎页面组件，该组件是 @nuxt&#x2F;ui 的一部分。 页面占位组件&lt;NuxtPage&gt; 是 Nuxt 自带的页面占位组件。是对 &lt;router-view&gt; 的封装。 页面布局组件&lt;NuxtLayout&gt; 是 Nuxt 自带的页面布局组件，可以将多个页面共性东西抽取到 Layout 布局中。比如：每个页面的页眉和页脚组件，这些具有共性的组件我们是可以写到一个 Layout 布局中。 &lt;NuxtLayout&gt; 是使用 &lt;slot&gt; 组件来显示页面中的内容。 &lt;NuxtLayout&gt; 有两种使用方式： 默认布局 在 layouts 目录下新建默认的布局组件，比如：layouts/default.vue。 然后在 app.vue 中通过 &lt;NuxtLayout&gt; 内置组件来使用。 自定义布局 在 layouts 文件夹下新建 Layout 布局组件，比如: layouts/custom-layout.vue。 然后在 app.vue中给 &lt;NuxtLayout&gt; 内置组件指定 name 属性的值为：custom-layout。 也支持在页面中使用 definePageMeta 宏函数来指定 layout 布局。 默认布局目录结构 layouts default.vue pages detail.vue index.vue app.vue layouts&#x2F;default.vue&lt;template&gt; &lt;div&gt; &lt;div class=&quot;base header&quot;&gt;header&lt;/div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;div class=&quot;base footer&quot;&gt;footer&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.base &#123; width: 100%; height: 80px; line-height: 80px; text-align: center; font-size: 20px;&#125;.header &#123; background-color: red; &#125;.footer &#123; background-color: skyblue; &#125;&lt;/style&gt; app.vue&lt;template&gt; &lt;NuxtLayout&gt; &lt;div&gt; &lt;NuxtLink to=&quot;/&quot;&gt; &lt;button&gt;Home&lt;/button&gt; &lt;/NuxtLink&gt; &lt;NuxtLink to=&quot;/detail&quot;&gt; &lt;button&gt;detail&lt;/button&gt; &lt;/NuxtLink&gt; &lt;/div&gt; &lt;NuxtPage&gt;&lt;/NuxtPage&gt; &lt;/NuxtLayout&gt;&lt;/template&gt;&lt;style&gt;a &#123; margin-right: 10px; &#125;button &#123; cursor: pointer; &#125;.router-link-active button &#123; color: red; &#125;&lt;/style&gt; pages&#x2F;index.vue&lt;template&gt; &lt;div&gt;Page: index&lt;/div&gt;&lt;/template&gt; pages&#x2F;detail.vue&lt;template&gt; &lt;div&gt;Page: detail&lt;/div&gt; &lt;/template&gt; 自定义布局目录结构 layouts custom.vue default.vue pages detail.vue index.vue login.vue app.vue pages&#x2F;detail.vue 和 pages&#x2F;index.vue 内容和上面的默认布局内容一样 layouts&#x2F;custom.vue&lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; layouts&#x2F;default.vue&lt;template&gt; &lt;div&gt; &lt;div class=&quot;base header&quot;&gt; &lt;div class=&quot;header-content&quot;&gt; &lt;h1&gt;header&lt;/h1&gt; &lt;div&gt; &lt;NuxtLink to=&quot;/&quot;&gt;&lt;button&gt;Home&lt;/button&gt;&lt;/NuxtLink&gt; &lt;NuxtLink to=&quot;/detail&quot;&gt;&lt;button&gt;detail&lt;/button&gt;&lt;/NuxtLink&gt; &lt;/div&gt; &lt;div class=&quot;login-btn&quot; @click=&quot;loginHandler&quot;&gt;登录&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;div class=&quot;base footer&quot;&gt;footer&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const loginHandler = () =&gt; &#123; navigateTo(&#x27;/login&#x27;) &#125;&lt;/script&gt;&lt;style scoped&gt;.base &#123; width: 100%; height: 80px; line-height: 80px; text-align: center; font-size: 20px;&#125;.header &#123; background-color: red; &#125;.header-content &#123; margin: 0 auto; width: 1200px; height: 100%; display: flex; justify-content: space-between; align-items: center;&#125;.header-content .login-btn &#123; cursor: pointer; color: #eee;&#125;.header-content .login-btn:hover &#123; color: #333; &#125;.footer &#123; background-color: skyblue; &#125;&lt;/style&gt; layouts&#x2F;login.vue&lt;script setup&gt;definePageMeta(&#123; layout: &#x27;custom&#x27; &#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;div style=&quot;margin-bottom: 30px&quot;&gt;Page: login&lt;/div&gt; &lt;NuxtLink to=&quot;/&quot;&gt;go Home page&lt;/NuxtLink&gt; &lt;/div&gt;&lt;/template&gt; app.vue&lt;template&gt; &lt;NuxtLayout&gt; &lt;NuxtPage&gt;&lt;/NuxtPage&gt; &lt;/NuxtLayout&gt;&lt;/template&gt;&lt;style&gt;a &#123; margin-right: 10px; &#125;button &#123; cursor: pointer; &#125;.router-link-active button &#123; color: red; &#125;&lt;/style&gt; 注意这里将 导航移动到 default 页面是因为，login 页面的内容也是显示到 &lt;NuxtPage&gt; 组件中，如果继续放在这里，那么在 login 页面中也会显示之前的导航信息。 当然也可以不这样，直接判断信息在 app.vue 中隐藏菜单信息。 通过 $route.path === &#39;/login&#39; 来动态显示 通过 $route.meta.layout !== &#39;custom&#39; 来动态显示 … 方式一 &lt;template&gt; &lt;NuxtLayout&gt; &lt;div :style=&quot;&#123; display: $route.path === &#x27;/login&#x27; ? &#x27;none&#x27; : &#x27;block&#x27; &#125;&quot;&gt; &lt;NuxtLink to=&quot;/&quot;&gt;&lt;button&gt;Home&lt;/button&gt;&lt;/NuxtLink&gt; &lt;NuxtLink to=&quot;/detail&quot;&gt;&lt;button&gt;detail&lt;/button&gt;&lt;/NuxtLink&gt; &lt;/div&gt; &lt;NuxtPage&gt;&lt;/NuxtPage&gt; &lt;/NuxtLayout&gt;&lt;/template&gt;&lt;style&gt;a &#123; margin-right: 10px;&#125;button &#123; ursor: pointer; .router-link-active button &#123; olor: red; &lt;/style&gt; 方式二 &lt;template&gt; &lt;NuxtLayout&gt; &lt;div v-if=&quot;$route.meta.layout !== &#x27;custom&#x27;&quot;&gt; &lt;NuxtLink to=&quot;/&quot;&gt;&lt;button&gt;Home&lt;/button&gt;&lt;/NuxtLink&gt; &lt;NuxtLink to=&quot;/detail&quot;&gt;&lt;button&gt;detail&lt;/button&gt;&lt;/NuxtLink&gt; &lt;/div&gt; &lt;NuxtPage&gt;&lt;/NuxtPage&gt; &lt;/NuxtLayout&gt;&lt;/template&gt;&lt;style&gt;a &#123; margin-right: 10px;&#125;button &#123; ursor: pointer; .router-link-active button &#123; olor: red; &lt;/style&gt; 客户端渲染组件基础&lt;ClientOnly&gt; 该组件中的默认插槽内容只在客户端渲染。 &lt;template&gt; &lt;div&gt; &lt;ClientOnly&gt;&lt;div&gt;我只会在客户端渲染&lt;/div&gt;/ClientOnly&gt; &lt;div&gt; &lt;h1&gt;Home Page&lt;/h1&gt; &lt;p&gt;Home page content goes here&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; fallback 属性可以给 &lt;ClientOnly&gt; 组件添加 fallback 属性，该属性的内容在组件还未加载出来之前进行占位和提示。 &lt;ClientOnly fallback=&quot;正在加载...&quot;&gt;&lt;div&gt;我只会在客户端渲染&lt;/div&gt;&lt;/ClientOnly&gt; fallback-tag 属性fallback-tag 属性可以修改 fallback 中内容的 HTML 标签。它默认是 &lt;span&gt; 标签，我们可以使用 fallback-tag 来设置其标签。 &lt;ClientOnly fallback-tag=&quot;div&quot; fallback=&quot;正在加载...&quot;&gt; 插槽用法&lt;ClientOnly&gt; 组件中的默认插槽的内容只会在客户端渲染，而 fallback 插槽中的内容只在服务器端渲染。 &lt;ClientOnly&gt; &lt;div&gt;客户端中显示&lt;/div&gt; &lt;template #fallback&gt; &lt;div&gt;服务器端中显示&lt;/div&gt; &lt;/template&gt;&lt;/ClientOnly&gt; 页面导航组件NuxtLink 组件&lt;NuxtLink&gt; 是 Nuxt 内置组件，是对 RouterLink 的封装，用来实现页面的导航。 NuxtLink 组件属性： to —- 支持路由路径、路由对象、URL href —- to 的别名 active-class —- 激活连接的类名 target —- 和 a 标签的 target 一样，指定何种方式显示新页面 … 外部链接会加上 rel&#x3D;”noopener noreferrer”，表示不携带 opener 和 referrer 信息。也可以手动指定 external，当然只要是外部连接就会自动添加上 rel&#x3D;”noopener noreferrer”。 &lt;template&gt; &lt;div&gt; &lt;div class=&quot;page&quot;&gt; &lt;NuxtLink to=&quot;/&quot;&gt;首页&lt;/NuxtLink&gt; &lt;NuxtLink to=&quot;/home&quot;&gt;home&lt;/NuxtLink&gt; &lt;!-- href 是 to 的别名 --&gt; &lt;NuxtLink href=&quot;/detail&quot; replace&gt;detail index 有 replace&lt;/NuxtLink&gt; &lt;NuxtLink to=&quot;/detail/2&quot; active-class=&quot;active-red&quot;&gt;detail [id]&lt;/NuxtLink&gt; &lt;!-- &lt;NuxtLink to=&quot;/user-admin?username=123&amp;password=123123&quot;&gt;user-[type]&lt;/NuxtLink&gt; --&gt; &lt;NuxtLink :to=&quot;&#123; path: &#x27;/user-admin&#x27;, query: &#123; username: 123, password: 123123 &#125; &#125;&quot;&gt; user-[type] &lt;/NuxtLink&gt; &lt;!-- 外部链接会加上 rel=&quot;noopener noreferrer&quot; 不携带 opener 和 referrer 信息 --&gt; &lt;!-- 也可以手动指定 external，当然外部连接会自动添加上 rel=&quot;noopener noreferrer&quot; --&gt; &lt;NuxtLink to=&quot;https:www.jd.com&quot; external target=&quot;_blank&quot;&gt;京东&lt;/NuxtLink&gt; &lt;/div&gt; &lt;NuxtPage&gt;&lt;/NuxtPage&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.page &#123; display: flex; gap: 0 20px;&#125;.active-red &#123; color: red;&#125;&lt;/style&gt; navigateTo 函数还可以使用编程导航 navigateTo 函数。通过编程导航可以轻松实现动态导航，但动态导航不利于 SEO。 navigateTo 函数在服务器端和客户端都可以使用，也可以用于插件、中间件等，还可以直接用来执行页面导航。 navigateTo(to, options) 函数： to —- 可以是纯字符串、外部 URL、路由对象。 options —- 导航配置，可选。 replace —- false（默认）、true，为 true 时替换当前路由页面 external —- false（默认）、true，不允许导航到外部链接，true 则允许。 redirectCode —- 数字，重定向代码 … &lt;template&gt; &lt;div&gt; &lt;div class=&quot;page&quot;&gt; &lt;button @click=&quot;goToPage(&#x27;/&#x27;)&quot;&gt;首页&lt;/button&gt; &lt;button @click=&quot;goToPage(&#x27;/home&#x27;)&quot;&gt;home&lt;/button&gt; &lt;button @click=&quot;goToPage(&#123; path: &#x27;/detail/3&#x27;, query: &#123; username: 123, password: 123123 &#125; &#125;)&quot; &gt; detail &lt;/button&gt; &lt;button @click=&quot;goToPage(&#x27;https://www.jd.com&#x27;)&quot;&gt;京东&lt;/button&gt; &lt;/div&gt; &lt;NuxtPage&gt;&lt;/NuxtPage&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const goToPage = url =&gt; &#123; if (/^http/i.test(url)) &#123; // 这里不加 external 是跳不过去的 // return navigateTo(url, &#123; external: true &#125;) return navigateTo(url, &#123; open: &#123; target: &#x27;_blank&#x27;, // 窗口特性，设置窗口大小 windowFeatures: &#123; width: 600, height: 500 &#125; &#125; &#125;) &#125; navigateTo(url)&#125;&lt;/script&gt;&lt;style&gt;.page &#123; display: flex; gap: 0 20px;&#125;&lt;/style&gt; abortNavigation 函数中止导航，并显示可选的错误消息。 abortNavigation(Error | string) Error —- 错误对象 string —- 错误字符串 useRouter除了可以通过 navigateTo 函数来实现编程导航，也可以使用 useRouter ( 或 Options API 的 this.$router )。 back —- 页面返回，router.go(-1) forward —- 页面前进，router.go(1) go —- 页面返回或前进 push —- 建议用 navigateTo replace — 建议用 navigateTo beforeEach —- 路由守卫钩子，每次导航前执行 afterEach —- 路由守卫钩子，每次导航后执行 useRouter 与 navigateTo假如现在有两个页面 pages/index.vue、pages/lazy.vue 我们在 lazy 组件中设置路由跳转到 index 组件中，以此对比 useRouter 和 navigateTo 的区别。 // pages/index.vueuseRouter().push(&#x27;/lazy&#x27;) // 页面有很明显的切换过程// 页面直接在服务端渲染时就切换完毕了，在浏览器中无明显的切换过程navigateTo(&#x27;/lazy&#x27;)// 下面的 111 会在浏览器中输出useRouter().push(&#x27;/lazy&#x27;)console.log(&#x27;111&#x27;)// 下面的 111 会在编辑器终端输出navigateTo(&#x27;/lazy&#x27;)console.log(&#x27;111&#x27;) SEO 组件&lt;Title&gt;, &lt;Base&gt;, &lt;NoScript&gt;, &lt;Style&gt;, &lt;Meta&gt;, &lt;Link&gt;, &lt;Body&gt;, &lt;Html&gt; and &lt;Head&gt; &lt;Head&gt; 和 &lt;Body&gt; 可以接受嵌套的 Meta 标记（出于美观原因），但这不会影响嵌套的 Meta 标记在最终 HTML 中的呈现位置。 nuxt.config.js关闭 ssrssr: false 关闭 SSR，开启 SPA。值：false&#x2F;true，true 为默认值。 运行时配置// nuxt.config.tsruntimeConfig: &#123; count: 1, // 只能在服务端访问 public: &#123; // 两端都可以访问 baseURL: &#x27;localhost:8080&#x27; &#125;&#125;// app.vueconst runtimeConfig = useRuntimeConfig()console.log(runtimeConfig.count)console.log(runtimeConfig.public.baseURL) 路由为哈希模式服务器的路由只能是 history 模式，客户端的路由可以是 history 或 hash 模式。 若需要将路由模式切换为 hash 模式，只能在 SPA 模式下才能启用哈希模式，也就是说需要将 SSR 关闭后再进行设置。启动后，URL 永远不会发送到服务器，并且不支持 SSR。 解释一下 为什么说URL永远不会发送到服务器，并且不支持SSR？ 总结：SSR 的核心是 在服务器生成完整的 HTML 内容，如果使用 Hash 模式则无法知道客户端实际需要渲染的路由。因为在 Hash 模式下，URL 的路径会被 # 符号分隔，# 前的部分会发送到服务器，# 后的部分会留在客户端。这会导致服务器永远接收的都是根路径，无法知道前端具体的路由，导致无法正确进行服务端渲染。 # 符号最初设计用于 页面内锚点跳转，前端框架通过监听 hashchange 事件动态更新页面内容，无需像服务器发起新请求。 export default defineNuxtConfig(&#123; ssr: false, // 关闭 SSR，开启 SPA router: &#123; options: &#123; hashMode: true // 路由为 hash 模式 &#125; &#125;&#125;) runtimeConfig vs app.config它们都用于应用程序公开变量。 runtimeConfig：定义环境变量。运行时需要指定的私有或公有 token。 app.config：定义公共变量。在构建时确定的公共 token、网站配置。 全局样式 在 app.vue 文件中编写 在外部文件中编写（推荐） 在 assets&#x2F;style 中编写全局样式，如 global.css。 去 nuxt.config 中的 css 选型中进行配置 // assets/styles/global.css -- 全局样式body &#123; background-color: pink;&#125;// nuxt.config.js -- css 配置export default defineNuxtConfig(&#123; css: [&#x27;@/assets/styles/global.css&#x27;]&#125;) 也可以使用 SCSS。 // assets/styles/main.scss$primary-bg: skyblue;$primary-font: 20px; // app.vue&lt;template&gt; &lt;div class=&quot;page&quot;&gt; &lt;h1&gt;Home Page&lt;/h1&gt; &lt;p&gt;Home page content goes here&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot;&gt;@use &#x27;@/assets/styles/main.scss&#x27; as main;.page &#123; background-color: main.$primary-bg; font-size: main.$primary-font;&#125;&lt;/style&gt; // nuxt.config.js -- css 配置export default defineNuxtConfig(&#123; css: [&#x27;@/assets/styles/global.css&#x27;, &#x27;@/assets/styles/main.scss&#x27;]&#125;) 上面的是手动导入 scss 文件，我们可以配置使其自动导入。 修改 app.vue 和 nuxt.config.js 的代码。 // app.vue&lt;template&gt; &lt;div class=&quot;page&quot;&gt; &lt;h1&gt;Home Page&lt;/h1&gt; &lt;p&gt;Home page content goes here&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot;&gt;.page &#123; background-color: $primary-bg; font-size: $primary-font;&#125;&lt;/style&gt; // nuxt.config.js -- css 配置export default defineNuxtConfig(&#123; css: [&#x27;@/assets/styles/global.css&#x27;], vite: &#123; css: &#123; preprocessorOptions: &#123; scss: &#123; additionalData: &#x27;@use &quot;@/assets/styles/main.scss&quot; as *;&#x27; // 这里配置后就不需要在上面的 css 选项中再配置了 &#125; &#125; &#125; &#125;&#125;) 这种就会在 .scss 和 使用了 lange&#x3D;”scss” 的文件的首行自动添加导入设置的 .scss 文件配置。 判断目前是什么端方法一在 nuxt.config.ts 中的 runtimeConfig 中随便写点代码，然后去控制台输出，看哪个端的控制端有内容。 // nuxt.config.tsruntimeConfig: &#123; isServer: true&#125;// app.vueconst runtimeConfig = useRuntimeConfig()if (runtimeConfig.isServer) &#123; console.log(&#x27;server 端&#x27;)&#125; 方法二// app.vueif (import.meta.server) &#123; console.log(&#x27;服务端&#x27;)&#125; else &#123; console.log(&#x27;客户端&#x27;)&#125; 资源导入图片资源public 目录：静态资源的公共服务器，可以直接通过 URL 访问。如：/images/xx.png。 assets 目录： 存放样式表、字体等，可以使用 @/assets 等路径访问目录中的内容。 &lt;template&gt; &lt;div class=&quot;page&quot;&gt; &lt;div&gt; &lt;h2&gt;public&lt;/h2&gt; &lt;div&gt; &lt;h3&gt;通过img标签引入&lt;/h3&gt; &lt;img src=&quot;/public/星空.jpg&quot; alt=&quot;&quot; /&gt; &lt;img src=&quot;@/public/星空.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;通过背景引入&lt;/h3&gt; &lt;div class=&quot;public-bg public-bg1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;public-bg public-bg2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;h2&gt;assets&lt;/h2&gt; &lt;div&gt; &lt;h3&gt;通过img标签引入&lt;/h3&gt; &lt;img src=&quot;@/assets/images/R-C.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;通过背景引入&lt;/h3&gt; &lt;div class=&quot;assets-bg&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.page &#123; display: flex; gap: 0 50px;&#125;img &#123; margin: 10px; width: 200px;&#125;.public-bg &#123; display: inline-block; margin: 10px; width: 200px; height: 110px; background-size: contain;&#125;.public-bg1 &#123; background-image: url(/public/星空.jpg);&#125;.public-bg2 &#123; background-image: url(@/public/星空.jpg);&#125;.assets-bg &#123; margin: 10px; width: 200px; height: 110px; background-image: url(@/assets/images/R-C.jpg); background-size: contain;&#125;&lt;/style&gt; 字体图标可以将字体图标文件放在 assets 目录中，通过 @/assets 等路径进行获取。之后在 nuxt.config.js 的 css 选项中配置让其全局生效。 // nuxt.config.js -- css 配置export default defineNuxtConfig(&#123; css: [&#x27;@/assets/iconfont/iconfont.css&#x27;], // 字体图标&#125;) 新建页面nuxt 项目的页面在 pages 目录下创建。nuxt 会根据该目录的目录结构和其文件名自动生成对应的路由。 可以使用命令来便捷创建页面。 npx nuxi add page xxx —- 创建页面 npx nuxi add page xxx/xx —- 创建xxx目录并在内部创建xx页面 npx nuxi add page xxx/[id] —- 创建xxx目录并在内部创建动态路由页面 路由动态路由动态路由也是根据目录结构和文件的名称自动生成。 动态路由语法：页面组件目录 或 页面组件文件都 支持 [ ] 方括号语法，[ ] 方括号中编写动态路由参数。 例如： pages&#x2F;detail&#x2F;[id].vue —- &#x2F;detail&#x2F;:id pages&#x2F;detail&#x2F;user-[type].vue —- &#x2F;detail&#x2F;user-:type pages&#x2F;detail&#x2F;[role]&#x2F;[id].vue —- &#x2F;detail&#x2F;:role&#x2F;:id pages&#x2F;detail-[role]&#x2F;[id].vue —- &#x2F;detail-:role&#x2F;:id 动态路由和 index.vue 可以同时存在。 可选路由文件夹使用双括号 [[]] 命名，支持使用或不使用。 如 pages/[[test]]/testRoute.vue，这里浏览器访问：http://localhost:3000/test/testRoute 或 http://localhost:3000/testRoute 都可以。 路由参数通过 [ ] 方括号语法定义的动态路由，如目录结构为 pages/detail/[id].vue，可以 URL 路径传递动态路由参数 /detail/12?name=zhangsan，在 [id].vue 中通过 $route.params.id 和 $route.query.name 获取，也可以使用 useRoute 函数。 全局路由（404 page）用户可能会手动修改 URL 或 我们忘记创建某个页面，导致页面跳转出错，虽然 Nuxt 给我们定制了一个 404 页面，但不符合每个项目的需求，可能需要自定义。 我们可以通过 [ ] 方括号，并在内加入三个点，如：[…slug].vue。其中的 slug 可以是其它的字符串。 我们可以在 pages 根目录下创建该页面，也可以在任意子目录下创建该页面。需要注意的是子目录下的是该目录下输入的 URL 不存在则使用该目录下的 404 页面；pages 根目录下的是捕获全局的错误 URL。 路由匹配机制预定义路由优先于动态路由，动态路由优先于捕获所有路由。先找预定义路由，后动态路由，最后捕获所有路由（404页面）。 预定路由：pages&#x2F;detail&#x2F;create.vue 匹配 &#x2F;detail&#x2F;create 动态路由：pages&#x2F;detail&#x2F;[id].vue 匹配 &#x2F;detail&#x2F;1、&#x2F;detail&#x2F;abc、… 不匹配 &#x2F;detail&#x2F;、&#x2F;detail&#x2F;create、&#x2F;detail&#x2F;1&#x2F;1、… 捕获所有路由：pages&#x2F;detail&#x2F;[…slug].vue 匹配 &#x2F;detail&#x2F;1&#x2F;1、&#x2F;detail&#x2F;a&#x2F;b、… 不匹配 &#x2F;detail&#x2F;、… 嵌套路由嵌套路由也是根据目录结构和文件的名称自动生成。 步骤 在 pages 目录下创建一个一级路由，如：parent.vue 文件。 在 pages 目录下创建一个一级路由同名的文件夹，如：parent 文件夹。 二级路由在 parent 文件夹中创建即可。 在 app.vue 和 parent.vue 文件中编写页面占位，使用 &lt;NuxtLink&gt; 。 app.vue 中的页面占位是为了显示 parent.vue 等一级路由；parent.vue 中的页面占位是为了显示 parent 目录下的二级路由。 简单目录结构 pages parent child1.vue —- 二级路由，child1 页面 child2.vue —- 二级路由，child2 页面 index.vue —- 二级路由默认页面 index.vue —- 一级路由默认页面 parent.vue —- 一级路由，parent 页面 app.vue 代码编写app.vue&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;NuxtLink to=&quot;/&quot; :active-class=&quot;$route.path === &#x27;/&#x27; ? &#x27;active&#x27; : &#x27;&#x27;&quot;&gt; &lt;button&gt;Home&lt;/button&gt; &lt;/NuxtLink&gt; &lt;NuxtLink to=&quot;/parent&quot; :active-class=&quot;$route.path.includes(&#x27;parent&#x27;) ? &#x27;active&#x27; : &#x27;&#x27;&quot;&gt; &lt;button&gt;Parent&lt;/button&gt; &lt;/NuxtLink&gt; &lt;/div&gt; &lt;NuxtPage&gt;&lt;/NuxtPage&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;a &#123; margin-right: 10px;&#125;button &#123; cursor: pointer;&#125;.router-link-active.router-link-exact-active button,.active button &#123; color: red;&#125;&lt;/style&gt; pages&#x2F;index.vue&lt;template&gt; &lt;div&gt; &lt;div&gt;Page: index&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; pages&#x2F;parent.vue&lt;template&gt; &lt;div&gt; &lt;div&gt;Page: parent&lt;/div&gt; &lt;div&gt; &lt;NuxtLink to=&quot;/parent&quot;&gt; &lt;button&gt;parent home&lt;/button&gt; &lt;/NuxtLink&gt; &lt;NuxtLink to=&quot;/parent/child1&quot;&gt; &lt;button&gt;parent child1&lt;/button&gt; &lt;/NuxtLink&gt; &lt;NuxtLink to=&quot;/parent/child2&quot;&gt; &lt;button&gt;parent child2&lt;/button&gt; &lt;/NuxtLink&gt; &lt;/div&gt; &lt;NuxtPage&gt;&lt;/NuxtPage&gt; &lt;/div&gt;&lt;/template&gt; pages&#x2F;parent&#x2F;index.vue&lt;template&gt; &lt;div&gt; &lt;div&gt;Page: parent/index&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; pages&#x2F;parent&#x2F;child1.vue&lt;template&gt; &lt;div&gt; Page: parent/child1 &lt;/div&gt;&lt;/template&gt; pages&#x2F;parent&#x2F;child2.vue&lt;template&gt; &lt;div&gt; Page: parent/child2 &lt;/div&gt;&lt;/template&gt; 路由中间件概念Nuxt 提供了一个可定制的 路由中间件，可以在整个应用程序中使用，非常适合在导航到特定路由之前提取我们想要运行的代码。用来监听路由的导航，包括：局部和全局监听（支持在服务器和客户端执行）。 路由中间件分三类： 匿名（或内联）路由中间件：在页面中使用 definePageMeta 函数定义，可监听局部路由。当注册多个中间件时，会按照注册顺序来执行。 命名路由中间件：在 middleware 目录下定义，并且会自动加载中间件。命名通常使用短横线。也需要在 definePageMeta 函数定义。 全局路由中间件：在 middleware 目录中，需要带 .global 后缀的文件，每次路由更改会自动运行。 全局路由中间件的优先级最高，支持服务端和客户端。 路由中间件执行顺序： 全局路由中间件 页面定义的路由中间件顺序（多个路由中间件使用数组语法） 如果有多个全局路由中间件，则根据目录的顺序依次执行。 若想手动指定全局路由中间件的执行顺序，则可以在文件名前面加上字母编号。 注意：文件名是按照字母排序的，而不是按照数值排序。如：10.new.global.ts 将位于 2.new.global.ts 之前。 匿名（或内联）路由中间件匿名（或内联）路由中间件，只能用在单文件中，如：index.vue、parent.vue 等文件中。不能用在 app.vue 中。 &lt;!-- pages/index.vue --&gt;&lt;script setup&gt;definePageMeta(&#123; middleware: [ function (to, from) &#123; console.log(&#x27;我是匿名中间件&#x27;) &#125; ]&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;Page: index&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 命名路由中间件middleware&#x2F;home.tsexport default defineNuxtRouteMiddleware((to, from) =&gt; &#123; console.log(&#x27;我是命名中间件，是第一个中间件&#x27;)&#125;)export default defineNuxtRouteMiddleware((to, from) =&gt; &#123; if (to.path === &#x27;/about&#x27;) &#123; return navigateTo(&#x27;/login&#x27;) &#125;&#125;) pages&#x2F;index.vue&lt;script setup&gt;definePageMeta(&#123; // middleware: [&#x27;home&#x27;] // 单个 // middleware: &#x27;home&#x27; // 单个 middleware: [ // 多个 &#x27;home&#x27;, function (to, from) &#123; console.log(&#x27;我是匿名中间件，也是第二个中间件&#x27;) &#125; ]&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;Page: index&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 全局路由中间件// middleware/main.global.tsexport default defineNuxtRouteMiddleware((to, from) =&gt; &#123; console.log(&#x27;我是全局中间件，是优先级最高的中间件&#x27;)&#125;) 路由验证（validate）Nuxt支持对每个页面路由进行验证，我们可以通过 definePageMeta 中的 validate 属性来对路由进行验证。 validate 属性接受一个回调函数，回调函数中以 route 作为参数。 回调函数的返回值支持： 返回 boolean 值来确定是否放行路由 true 放行路由 false 默认重定向到内置的 404 页面。可以自定义错误页面，在项目根目录（不是pages目录）新建 error.vue 返回对象：&#123; statusCode:401 &#125; 返回自定义的 401 页面，验证失败 返回 boolean目录结构 pages detail [id].vue index.vue index.vue app.vue error.vue —- 路由验证错误页面 pages&#x2F;detail&#x2F;[id].vue&lt;script setup&gt;definePageMeta(&#123; validate: route =&gt; &#123; return /^\\d+$/i.test(route.params.id) &#125;&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt;Page: detail/[id]&lt;/div&gt;&lt;/template&gt; pages&#x2F;detail&#x2F;index.vue&lt;template&gt; &lt;div&gt; Page: detail/index &lt;/div&gt;&lt;/template&gt; pages&#x2F;index.vue&lt;template&gt; &lt;div&gt; &lt;div&gt;Page: index&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; error.vue&lt;template&gt; &lt;div&gt; &lt;div&gt;error&lt;/div&gt; &lt;div style=&quot;margin-top: 30px&quot;&gt;&#123;&#123; $route &#125;&#125;&lt;/div&gt; &lt;div style=&quot;margin-top: 30px&quot;&gt; &lt;button @click=&quot;goToHomeHandler&quot;&gt;返回首页&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const goToHomeHandler = () =&gt; &#123; clearError(&#123; redirect: &#x27;/&#x27; &#125;) // 清除错误，返回首页&#125;&lt;/script&gt; app.vue&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;NuxtLink to=&quot;/&quot;&gt; &lt;button&gt;Home&lt;/button&gt; &lt;/NuxtLink&gt; &lt;NuxtLink to=&quot;/detail&quot;&gt; &lt;button&gt;detail&lt;/button&gt; &lt;/NuxtLink&gt; &lt;NuxtLink to=&quot;/detail/1&quot;&gt; &lt;button&gt;detail/1&lt;/button&gt; &lt;/NuxtLink&gt; &lt;NuxtLink to=&quot;/detail/abc&quot;&gt; &lt;button&gt;detail/abc&lt;/button&gt; &lt;/NuxtLink&gt; &lt;/div&gt; &lt;NuxtPage&gt;&lt;/NuxtPage&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;a &#123; margin-right: 10px;&#125;button &#123; cursor: pointer;&#125;.router-link-active button &#123; color: red;&#125;&lt;/style&gt; 返回对象其他页面和上面一样。 修改 [id].vuedefinePageMeta(&#123; validate: route =&gt; &#123; return &#123; statusCode: 302 &#125; &#125;&#125;) 修改 error.vue&lt;template&gt; &lt;div&gt; &lt;div&gt;error&lt;/div&gt; &lt;div style=&quot;margin-top: 30px&quot;&gt;&#123;&#123; $route &#125;&#125;&lt;/div&gt; &lt;div style=&quot;margin-top: 30px&quot;&gt;statusCode: &#123;&#123; props.error.statusCode &#125;&#125;&lt;/div&gt; &lt;div style=&quot;margin-top: 30px&quot;&gt; &lt;button @click=&quot;goToHomeHandler&quot;&gt;返回首页&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const props = defineProps([&#x27;error&#x27;]) // 接收传递的错误信息const goToHomeHandler = () =&gt; &#123; clearError(&#123; redirect: &#x27;/&#x27; &#125;) // 清除错误，返回首页&#125;&lt;/script&gt; 渲染模式浏览器和服务器都可以解释 JavaScript 代码，将 Vue.js 组件转换为 HTML 元素。这一步称为渲染。 在客户端将 Vue.js 组件呈现为 HTML 元素，称为：客户端渲染模式。 在服务器将 Vue.js 组件呈现为 HTML 元素，称为：服务器渲染模式 或 通用渲染。 而Nuxt3是支持多种渲染模式： 客户端渲染模式（CSR）：将 srr 设置为 false。 优点： 开发速度快。不必担心代码的服务器兼容性，仅用于浏览器的 API。 便宜。只需要在任何带有 HTML、CSS 和 JavaScript 文件的静态服务器上托管仅限客户端应用程序即可。 离线。代码完全在浏览器中运行，可以在互联网不可用时很好地保持工作。 缺点： 性能不好。需要等浏览器下载、解析和运行 JS 文件。 搜索引擎优化不好。爬虫在第一次索引页面时不会等待界面完全呈现。 服务器渲染模式（SSR）：将 ssr 设置为 true。 优点： 性能好。用户可以立即访问页面内容。浏览器显示静态内容比 JS 生成的内容快，且在水合过程中保留了程序交互性。 搜索引擎优化很好。渲染是将整个页面返回，爬虫能直接索引页面内容。 缺点： 开发受限。服务器和浏览器的环境不同，提供的 API 也不同。 成本问题。服务器运行才能动态显示页面，每月成本增加；但浏览器接管了客户端导航的通用渲染，服务器的调用会大大减少。 适用于任何面向内容的网站：博客、营销网站、投资组合、电子商务网站和市场。 混合渲染模式（CSR | SSR | SSG | SWR）：允许每个路由使用不同的缓存规则，并决定服务器应该如何响应给定URL上的新请求。需要再 routeRules 根据每个路由动态配置渲染模式。 SSG：静态站点生成。在构建时预先生成所有静态 HTML 文件，直接托管在 CDN 上。首次加载极快，SEO 支持非常好。不过当数据需要更新时，需要重新构建。适合内容固定的页面，比如：文档、博客等。 SWR：过时数据优先更新策略。在数据获取时优先返回缓存（可能过期的数据），同时在后台静默更新最新数据。 工作流程： 用户-&gt;&gt;客户端: 发起请求客户端-&gt;&gt;缓存: 检查是否存在旧数据缓存--&gt;&gt;客户端: 立即返回旧数据客户端-&gt;&gt;服务器: 后台发起验证请求服务器--&gt;&gt;客户端: 返回新数据客户端-&gt;&gt;缓存: 更新缓存客户端-&gt;&gt;UI: 静默更新界面 优势： 零等待加载：用户立即看到内容。 带宽优化：减少重复请求。 自动更新：保持数据新鲜度。 离线支持：配合 Service Worker 实现。 // nuxt.config.tsexport default defineNuxtConfig(&#123; routeRules: &#123; &#x27;/&#x27;: &#123; prerender: true &#125;, // 构建时预渲染 &#x27;/detail&#x27;: &#123; ssr: true &#125;, // 服务器端渲染 &#x27;/news&#x27;: &#123; swr: 3600 &#125;, // 混合渲染模式，每隔 1h 重新获取最新数据 &#x27;/order/**&#x27;: &#123; ssr: false &#125; // 客户端渲染 &#125;&#125;) 插件Nuxt 支持自定义插件进行扩展，创建插件有两种方式：单个文件中使用 useNuxtApp(name, value) 创建、在 plugins 目录中创建。 Nuxt 会自动读取 plugins/ 目录中的文件，并在创建 Vue 应用程序时加载它们。即里面的所有插件都是自动注册的，不需要单独将它们添加到nuxt.config.ts中。 注意：只有目录顶层的文件（或任何子目录中的索引文件）才会自动注册为插件。 单文件中创建在 useNuxtApp() 中的 provide(name, value) 方法直接创建。useNuxtApp() 提供了访问 Nuxt 共享运行时上下文的方法和属性（两端可用）：provide、hooks、callhook、vueApp 等。 感觉在 app.vue 中创建查询，pages 目录下的文件创建后切换路由控制台会报错。 &lt;template&gt; &lt;NuxtPage&gt;&lt;/NuxtPage&gt;&lt;/template&gt;&lt;script setup&gt;const price = ref(78)const nuxtApp = useNuxtApp()nuxtApp.provide(&#x27;doublePrice&#x27;, () =&gt; price.value * 2)nuxtApp.provide(&#x27;increment&#x27;, ++price.value)console.log(nuxtApp.$doublePrice(), nuxtApp.$increment) // 158 79&lt;/script&gt; plugins 目录中创建 在 plugins 目录中创建插件（推荐） 顶级和子目录 index 文件写的插件会创建 Vue 应用程序时自动加载和注册。 如果带有 .server 或 .client 后缀的插件名，那么可以区分服务器端或客户端的运行环境。 步骤： 在 plugins 目录中创建插件文件。 接着在 defineNuxtPlugin 函数创建插件，参数是一个回调函数。 然后在组件中使用 useNuxtApp() 拿到插件中的方法。 注意：插件注册顺序可以通过在文件名前加上一个数字来控制插件注册的顺序。有助于实现插件间的相互依赖。如：plugins/1.price.ts、&#96;&#96;plugins&#x2F; 2.string.ts&#96;… 注意：文件名是按字符串排序的，而不是按数值排序的。也就是：10.new.ts 将排在 2.new.ts 前面。可以用 0作为 个位数的前缀 创建帮助函数使用组合 API需要注意的是，使用组合在插件间互相依赖情况下可能无法工作；插件依赖 vue.js 生命周期的情况下无法工作。 plugins&#x2F;price.ts// 定义插件export default defineNuxtPlugin(nuxtApp =&gt; &#123; return &#123; provide: &#123; formatPrice (value: number) &#123; return value.toFixed(2) &#125; &#125; &#125;&#125;) pages&#x2F;detail.vue&lt;script setup lang=&quot;ts&quot;&gt;// 使用插件中的方法const &#123; $formatPrice &#125; = useNuxtApp()&lt;/script&gt;&lt;template&gt; &lt;div&gt;Page: detail&lt;/div&gt; &lt;div&gt;34.5678 =&gt; &#123;&#123; $formatPrice(34.5678) &#125;&#125;&lt;/div&gt;&lt;/template&gt; .server 或 .client 后缀// plugins/time.client.ts ---- 定义export default defineNuxtPlugin((nuxtApp) =&gt; &#123; return &#123; provide: &#123; currentTime () &#123; return Date.now() &#125;, status: 1, userInfo: &#123; name: &#x27;张三&#x27; &#125; &#125; &#125;&#125;) // app.vue ---- 使用const &#123; $currentTime, $status, $userInfo &#125; = useNuxtApp()if (process.client) &#123; console.log(1, $currentTime(), $status, $userInfo)&#125; app 生命周期使用 Hooks 监听App的生命周期。 nuxtApp.hook(hook api, func) Hook Arguments Environment Description app:created vueApp Server &amp; Client Called when initial vueApp instance is created. app:error err Server &amp; Client Called when a fatal error occurs. app:error:cleared &#123; redirect? &#125; Server &amp; Client Called when a fatal error occurs. app:data:refresh keys? Server &amp; Client (internal) vue:setup - Server &amp; Client (internal) vue:error err, target, info Server &amp; Client Called when a vue error propagates to the root component. Learn More. app:rendered renderContext Server Called when SSR rendering is done. app:redirected - Server Called before SSR redirection. app:beforeMount vueApp Client Called before mounting the app, called only on client side. app:mounted vueApp Client Called when Vue app is initialized and mounted in browser. app:suspense:resolve appComponent Client On Suspense resolved event. app:manifest:update &#123; id, timestamp &#125; Client Called when there is a newer version of your app detected. link:prefetch to Client Called when a &lt;NuxtLink&gt; is observed to be prefetched. page:start pageComponent? Client Called on Suspense pending event. page:finish pageComponent? Client Called on Suspense resolved event. page:loading:start - Client Called when the setup() of the new page is running. page:loading:end - Client Called after page:finish page:transition:finish pageComponent? Client After page transition onAfterLeave event. dev:ssr-logs logs Client Called with an array of server-side logs that have been passed to the client (if features.devLogs is enabled). page:view-transition:start transition Client Called after document.startViewTransition is called when experimental viewTransition support is enabled. 使用插件来监听（推荐）plugins&#x2F;lifecycle.tsexport default defineNuxtPlugin(nuxtApp =&gt; &#123; // client &amp;&amp; server nuxtApp.hook(&#x27;app:created&#x27;, vueApp =&gt; &#123; console.log(&#x27;app:created&#x27;) &#125;) // client &amp;&amp; server nuxtApp.hook(&#x27;app:error&#x27;, err =&gt; &#123; console.log(&#x27;app:error&#x27;) &#125;) // client &amp;&amp; server nuxtApp.hook(&#x27;vue:setup&#x27;, () =&gt; &#123; console.log(&#x27;vue:setup&#x27;) &#125;) // client &amp;&amp; server nuxtApp.hook(&#x27;vue:error&#x27;, (err, target, info) =&gt; &#123; console.log(&#x27;vue:error&#x27;) &#125;) // server nuxtApp.hook(&#x27;app:rendered&#x27;, renderContext =&gt; &#123; console.log(&#x27;app:rendered&#x27;) &#125;) // client nuxtApp.hook(&#x27;app:beforeMount&#x27;, vueApp =&gt; &#123; console.log(&#x27;app:beforeMount&#x27;) &#125;) // client nuxtApp.hook(&#x27;app:mounted&#x27;, vueApp =&gt; &#123; console.log(&#x27;app:mounted&#x27;) &#125;) /* client 执行顺序 app:created app:beforeMount vue:setup app:mounted */ /* server 执行顺序 app:created vue:setup app:rendered */&#125;) 在 app.vue 中监听&lt;script setup&gt;const nuxtApp = useNuxtApp()nuxtApp.hook(&#x27;app:created&#x27;, vueApp =&gt; &#123; console.log(&#x27;app:created&#x27;)&#125;)// client &amp;&amp; servernuxtApp.hook(&#x27;app:error&#x27;, err =&gt; &#123; console.log(&#x27;app:error&#x27;)&#125;)// client &amp;&amp; servernuxtApp.hook(&#x27;vue:setup&#x27;, () =&gt; &#123; console.log(&#x27;vue:setup&#x27;)&#125;)// client &amp;&amp; servernuxtApp.hook(&#x27;vue:error&#x27;, (err, target, info) =&gt; &#123; console.log(&#x27;vue:error&#x27;)&#125;)// servernuxtApp.hook(&#x27;app:rendered&#x27;, renderContext =&gt; &#123; console.log(&#x27;app:rendered&#x27;)&#125;)// clientnuxtApp.hook(&#x27;app:beforeMount&#x27;, vueApp =&gt; &#123; console.log(&#x27;app:beforeMount&#x27;)&#125;)// clientnuxtApp.hook(&#x27;app:mounted&#x27;, vueApp =&gt; &#123; console.log(&#x27;app:mounted&#x27;)&#125;)/* client 执行顺序 app:mounted *//* server 执行顺序 app:rendered*/&lt;/script&gt; 上面的执行结果只有一个，是因为我们在 setup 里进行的，所以只能执行 vue:setup 后面的生命周期。 注意：如果不在 setup 中会报错的。 组件生命周期客户端渲染 options API composition API beforeCreate setup() created setup() beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeDestory onBeforeUnmount destoryed onUnmounted errorCaptured onErrorCaptured 服务器端渲染因为没有任何动态更新，所以像 mounted、updated 这样的生命周期钩子不会在 SSR 期间被调用，只会在客户端运行。 只有 beforeCreate 和 created 这两个钩子会在 SSR 期间被调用。 应该避免在 beforeCreate 和 created 使用期间编写副作用代码，比如使用定时器 setInterval 等。我们可能会在客户端对这些代码在 beforeUnmout 或 unMounted 中清理。但 SSR 中没有这些钩子。所以在 SSR 中我们需要避免这种情况，将副作用的代码放到 mounted 中。 options API composition API beforeCreate setup() created setup() 获取数据在 Nuxt 中数据的获取主要是通过下面5个函数来实现（支持 Server 和 Client）：$fetch()、useAsyncData()、useLazyAsyncData()、useFetch()、useLazyFetch()。 $fetch() 刷新会在客户端和服务端都会发起请求，浪费服务器资源，不推荐。后面几个是 hooks api，刷新页面服务端请求数据，客户端不会请求；路由切换客户端请求数据，服务端不会请求；服务端请求数据会通过 hydration 水合到客户端。 useAsyncData()、useFetch() 会阻塞页面导航，也就是需要等数据请求回来后才显示页面信息。可以设置 lazy:true 使其不阻塞页面导航，然后通过 watch 监听数据从而确保数据一定能拿到。 useLazyAsyncData()、useLazyFetch() 不会阻塞页面，相当于设置了 lazy: true，上面函数的简写方式。 注意：上面的函数只能在 setup 或 lifecycle hooks 中使用。 $fetch()$fetch(url, opts) 是一个类原生 fetch 的跨平台请求库。 不过，$fetch 函数在刷新页面时 client 和 server 都会发起一次请求，浪费服务器资源。 &lt;script setup&gt;const BASE_URL = &#x27;http://codercba.com:9060/juanpi/api&#x27;// 刷新页面时 client 和 server 都会发起一次请求，浪费服务器资源$fetch(BASE_URL + &#x27;/homeInfo&#x27;, &#123;method: &#x27;GET&#x27; &#125;) .then(res =&gt; &#123; console.log(res) &#125;)&lt;/script&gt; useAsyncData()useAsyncData(key, func) 专门解决异步获取数据的函数，会阻止页面导航。发起异步请求需用到 $fetch 全局函数，当然也可以用其他的，比如 axios。 使用 useAsyncData 函数，在刷新页面时可以减少客户端发起的一次请求。 刷新页面时服务端会发起请求，客户端不会发起。每次切换路由后回到此页面 或 修改代码保存后， 客户端会发起请求，服务端不会发起。 也就是客户端和服务端同时只有一方发起请求。 &lt;script setup&gt;const BASE_URL = &#x27;http://codercba.com:9060/juanpi/api&#x27;const &#123; data: homeInfo &#125; = await useAsyncData(&#x27;homeInfo&#x27;, () =&gt; &#123; return $fetch(BASE_URL + &#x27;/homeInfo&#x27;, &#123; method: &#x27;GET&#x27; &#125;)&#125;)console.log(&#x27;homeInfo:&#x27;, homeInfo.value?.data)&lt;/script&gt; 注意：多个 useAsyncData 函数时，需要保证 key 的唯一性，不然请求结果会重复。 下面代码因为两个函数的请求 key 值不唯一，所以在当前路由进行刷新时会出现重复请求，输出相同的结果。(路由切换不会出现重复请求，只有刷新才会) &lt;script setup&gt;const BASE_URL = &#x27;http://codercba.com:9060/juanpi/api&#x27;const &#123; data: homeInfo &#125; = await useAsyncData(&#x27;homeInfo&#x27;, () =&gt; &#123; return $fetch(BASE_URL + &#x27;/homeInfo&#x27;, &#123; method: &#x27;GET&#x27; &#125;)&#125;)console.log(&#x27;homeInfo:&#x27;, homeInfo.value?.data)const &#123; data: goods &#125; = await useAsyncData(&#x27;homeInfo&#x27;, () =&gt; &#123; return $fetch(BASE_URL + &#x27;/goods&#x27;, &#123; method: &#x27;POST&#x27; &#125;)&#125;)console.log(&#x27;goods:&#x27;, goods.value?.data)&lt;/script&gt; useFetch() 与 useLazyFetch()useFetch()useFetch(url, opts) 用于获取任意的 URL 地址的数据，会阻止页面导航。是 useAsyncData 使用 $fetch 的简写。 &lt;script setup&gt;const BASE_URL = &#x27;http://codercba.com:9060/juanpi/api&#x27;const &#123; data: homeInfo &#125; = await useFetch(BASE_URL + &#x27;/homeInfo&#x27;, &#123; method: &#x27;GET&#x27; &#125;)console.log(homeInfo.value)&lt;/script&gt; 验证阻塞页面导航下面的代码需要等数据返回后才会进行挂载，也就是输出’onMounted’。 &lt;script setup&gt;const BASE_URL = &#x27;http://codercba.com:9060/juanpi/api&#x27;const &#123; data: homeInfo &#125; = await useFetch(BASE_URL + &#x27;/homeInfo&#x27;, &#123; method: &#x27;GET&#x27; &#125;)console.log(homeInfo.value)onMounted(() =&gt; &#123; console.log(&#x27;onMounted&#x27;)&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt;Page: lazy&lt;/div&gt;&lt;/template&gt; 取消获取数据阻塞页面当页面数据需要获取很多时或网络波动较大时，那我们不可能让用户等待很久。如何解决呢？可以设置 lazy: true，这样就不会阻塞页面的导航了。同时设置 watch 去监听数据，当 data 数据更新后 watch 会自动去赋值那些。 &lt;script setup&gt;const BASE_URL = &#x27;http://codercba.com:9060/juanpi/api&#x27;const &#123; data: homeInfo &#125; = await useFetch(BASE_URL + &#x27;/homeInfo&#x27;, &#123; method: &#x27;GET&#x27;, lazy: true &#125;)console.log(homeInfo.value)onMounted(() =&gt; &#123; console.log(&#x27;onMounted&#x27;)&#125;)// 确保数据一定能拿到watch(homeInfo, () =&gt; &#123; console.log(homeInfo.value)&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt;Page: lazy&lt;/div&gt;&lt;/template&gt; 当然我们也可以不用 watch 去监听，当我们切换到其他路由后回到此页面一样能拿到数据。但是不能保证一定能拿到数据，比如网络波动较大，超时那些。 useLazyFetch()上面的写法有一种简写形式，就是使用 useLazyFetch()，效果与 useFetch(api, &#123; lazy: true &#125;) 一样。 &lt;script setup&gt;const BASE_URL = &#x27;http://codercba.com:9060/juanpi/api&#x27;const &#123; data: homeInfo &#125; = await useLazyFetch(BASE_URL + &#x27;/homeInfo&#x27;, &#123; method: &#x27;GET&#x27; &#125;)console.log(homeInfo.value)onMounted(() =&gt; &#123; console.log(&#x27;onMounted&#x27;)&#125;)watch(homeInfo, () =&gt; &#123; console.log(homeInfo.value)&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt;Page: lazy&lt;/div&gt;&lt;/template&gt; 客户端刷新按钮如果需要在客户端进行刷新，我们可以解构出 refresh。 &lt;script setup&gt;const BASE_URL = &#x27;http://codercba.com:9060/juanpi/api&#x27;const &#123; data: homeInfo, refresh &#125; = await useLazyFetch(BASE_URL + &#x27;/homeInfo&#x27;, &#123; method: &#x27;GET&#x27; &#125;)console.log(homeInfo.value)const updateHandler = () =&gt; &#123; refresh()&#125;onMounted(() =&gt; &#123; console.log(&#x27;onMounted&#x27;)&#125;)watch(homeInfo, () =&gt; &#123; console.log(homeInfo.value)&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;Page: lazy&lt;/div&gt; &lt;button @click=&quot;updateHandler&quot;&gt;获取最新数据&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; useFetch vs axios获取数据 Nuxt 推荐使用 useFetch()，为什么不是 axios？ 因为 useFetch() 底部使用的是 $fetch()，该函数基于 unjs/ohmyfetch 请求库，并于原生的 Fetch API 有着相同 API。 unjs&#x2F;ohmyfetch 是一个跨端请求库。运行在服务器，可以智能的处理对 API 接口的直接调用。运行在客户端，可以对后台提供的 API 接口正常的调用（类似 axios），当然也支持第三方接口的调用。会自动解析响应和对数据进行字符串化。 useFetch 支持之鞥呢的类型提示和智能的推断 API 响应式类型。 在 setup 中用 useFetch 获取数据，会减去客户端重复发起的请求。 useFetch 的封装步骤： 定义 request 类并导出。 在类中定义 request、get、post 方法。 在 request 中使用 useFetch 发起网络请求。 添加 TS 类型声明。 import type &#123; AsyncData, UseFetchOptions &#125; from &quot;#app&quot;const BASE_URL = &#x27;http://codercba.com:9060/juanpi/api&#x27;export type Methods = &#x27;GET&#x27; | &#x27;POST&#x27;class Request &#123; request&lt;T&gt; (url: string, method: Methods, data?: any, options?: UseFetchOptions&lt;T&gt;):Promise&lt;AsyncData&lt;T,Error&gt;&gt; &#123; // 整合请求配置 let newOptions = &#123; baseURL: BASE_URL, method: method || &#x27;GET&#x27;, // 没传则默认为 GET ...options &#125; // 根据请求类型设置请求体 if (method === &#x27;GET&#x27;) &#123; newOptions.params = data || &#123;&#125; &#125; else &#123; newOptions.body = data || &#123;&#125; &#125; return new Promise((resolve, reject) =&gt; &#123; useFetch&lt;T&gt;(url, newOptions as any) .then(res =&gt; &#123; resolve(res as AsyncData&lt;T, Error&gt;) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125; post&lt;T&gt; (url: string, data?: any, options?: UseFetchOptions&lt;T&gt;) &#123; return this.request&lt;T&gt;(url, &#x27;POST&#x27;, data, options) &#125; get&lt;T&gt; (url: string, params?: any, options?: UseFetchOptions&lt;T&gt;) &#123; return this.request&lt;T&gt;(url, &#x27;GET&#x27;, params, options) &#125;&#125;export default new Request() Server API编写后端服务接口可以在 server&#x2F;api 目录下编写。 编写一个 &#x2F;api&#x2F;homeinfo 接口： 新建 server&#x2F;api&#x2F;homeinfo.ts。 在该文件中使用 defineEventHandler 函数定义接口。 使用 useFetch 函数调用编写的接口。 // server/api/homeinfo.tsexport default defineEventHandler(async event =&gt; &#123; const &#123; context &#125; = event const &#123; req, res &#125; = event.node const method1 = req.method const url = req.url const params = context.params console.log(&#x27;method1=&#x27;, method1) console.log(&#x27;url=&#x27;, url) console.log(&#x27;params=&#x27;, params) // 获取查询字符串 const query = getQuery(event) const method2 = getMethod(event) // 废弃 const header = getHeaders(event) const body = await readBody(event) const rawBody = await readRawBody(event) console.log(&#x27;query=&#x27;, query) console.log(&#x27;method2=&#x27;, method2) console.log(&#x27;header=&#x27;, header) console.log(&#x27;body=&#x27;, body) console.log(&#x27;rawBody=&#x27;, rawBody) return &#123; code: 200, data: &#123; token: &#x27;test token&#x27;, query, method2, header, body, rawBody &#125; &#125;&#125;) post 请求 // 终端输出console.log(&#x27;method1=&#x27;, method1) // POSTconsole.log(&#x27;url=&#x27;, url) // /api/homeinfoconsole.log(&#x27;params=&#x27;, params) // &#123;&#125;// 获取查询字符串const query = getQuery(event)const method2 = getMethod(event) // 废弃const header = getHeaders(event)const body = await readBody(event)const rawBody = await readRawBody(event)console.log(&#x27;query=&#x27;, query) // &#123;&#125;console.log(&#x27;method2=&#x27;, method2) // POSTconsole.log(&#x27;header=&#x27;, header) // &#123; ... &#125;console.log(&#x27;body=&#x27;, body) // &#123; name: &#x27;zhangsan&#x27;, sex: &#x27;男&#x27;, age: 18 &#125;console.log(&#x27;rawBody=&#x27;, rawBody) // &#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:18&#125; get请求 全局状态共享跨页面、跨组件全局状态共享可使用 useState（支持Server和Client ）。 useState&lt;T&gt;(init?: () =&gt; T | Ref&lt;T&gt;): Ref&lt;T&gt; useState&lt;T&gt;(key: string, init?: () =&gt; T | Ref&lt;T&gt;): Ref&lt;T&gt; 参数: init：为状态提供初始值的函数，该函数也支持返回一个Ref类型。 key: 唯一key，确保在跨请求获取该数据时，保证数据的唯一性。为空时会根据文件和行号自动生成唯一key。 返回值：Ref 响应式对象。 使用： 在 composables 目录下编写，新建 composables&#x2F;states.ts。 在该文件中使用 useState 定义全局共享状态并导出。 在组件中导入 states.ts 导出的全局状态。 // composables/states.tsexport const useUserInfo = function () &#123; return useState(&#x27;userInfo&#x27;, () =&gt; &#123; return &#123; name: &#x27;zhangsan&#x27;, age: 18 &#125; &#125;)&#125; // pages/index.vueconst userInfo = useUserInfo()console.log(userInfo.value) // &#123; name: &#x27;zhangsan&#x27;, age: 18 &#125; 注意： useState 只能在 setup 函数中 和 lifecycle 函数中使用。 useState 不支持 classes, functions or symbols类型，因为这些类型不支持序列化。 集成 Pinia安装依赖安装依赖：npm i pinia @pinia/nuxt 如有遇到 pinia 安装失败，可以添加 --legacy-peer-deps 告诉 NPM 忽略对等依赖并继续安装。 配置 nuxt.config.tsexport default defineNuxtConfig(&#123; modules: [ &#x27;@pinia/nuxt&#x27; ]&#125;) 使用 在 store 目录中编写代码，如：store&#x2F;counter.ts 在该文件中使用功能 defineStore 函数来定义 store 对象。 在组件中使用定义好的 store 对象。 store&#x2F;counter.ts import &#123; defineStore &#125; from &quot;pinia&quot;import &#123; ref &#125; from &quot;vue&quot;export const useCounterStore = defineStore(&#x27;counter&#x27;, () =&gt; &#123; const number = ref(10) const doubleNumber = () =&gt; &#123; number.value *= 2 &#125; return &#123; number, doubleNumber &#125;&#125;) pages&#x2F;index.vue &lt;template&gt; &lt;div&gt; &lt;div&gt;Page: index &#123;&#123; number &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;counterStore.doubleNumber()&quot;&gt;double number&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;import &#123; useCounterStore &#125; from &#x27;~/store/counter&#x27;// 使用 piniaconst counterStore = useCounterStore()const &#123; number &#125; = storeToRefs(counterStore)&lt;/script&gt; 集成 ElementPlushttps://nuxt.com/modules/element-plus 安装 命令：npm i element-plus @element-plus/nuxt 配置在 nuxt.config.ts 中配置 element-plus 模块 export default defineNuxtConfig(&#123; css: [ &#x27;element-plus/dist/index.css&#x27; ], modules: [ &#x27;@element-plus/nuxt&#x27; ]&#125;) 国际化新建 plugins/element-plus.client.js 文件 import ElementPlus from &#x27;element-plus&#x27;import zhCn from &#x27;element-plus/es/locale/lang/zh-cn&#x27;export default defineNuxtPlugin(nuxtApp =&gt; &#123; nuxtApp.vueApp.use(ElementPlus, &#123; locale: zhCn &#125;)&#125;) 修改 nuxt.config.ts 文件 export default defineNuxtConfig(&#123; css: [ &#x27;element-plus/dist/index.css&#x27; ], plugins: [ &#x27;@/plugins/element-plus.client.js&#x27; ], modules: [ &#x27;@element-plus/nuxt&#x27; ]&#125;)","categories":[{"name":"SSR","slug":"SSR","permalink":"http://ran-up.github.io/categories/SSR/"}],"tags":[{"name":"nuxt","slug":"nuxt","permalink":"http://ran-up.github.io/tags/nuxt/"}]},{"title":"前端面试全家桶","slug":"前端面试集锦/前端面试全家桶","date":"2025-01-25T15:25:28.000Z","updated":"2025-02-14T13:13:04.847Z","comments":true,"path":"2025/01/25/前端面试集锦/前端面试全家桶/","link":"","permalink":"http://ran-up.github.io/2025/01/25/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%A8%E5%AE%B6%E6%A1%B6/","excerpt":"","text":"HTML 面试题如何理解 HTML 语义化？ 点击查看答案 先解释，之后举例，然后说利弊。 解释：使用正确的 HTML 标签来搭建结构，可以清晰明了的表示页面内容。 比如：我们头部用 header 标签，导航用 nav 标签，独立的文章内容用 article 标签，页面底部。 这样不但可以让我们更容易理解代码结构，增加代码可读性和可维护性。还可以提高搜索引擎的 SEO 效果，提高网站排名，增加网站访问。 默认情况下，哪些 HTML 标签是块级元素？哪些是内联元素？ 点击查看答案 先解释，后举例。 块级元素独占一行，可以设置宽高；内联元素不能独占一行，也不能设置宽高。还有一个内联块元素，也可以称作可替换元素，它具有内联元素不独占一行的特性，也有块级元素能设置宽高的特性。 块级元素：div、h1-h6、ul、ol、li、dl、dd、dt、table、th、tr、td、p等 内联元素：a、span、strong、em、small、sub、sup、mark 内联块元素：img、select、button、input、video、audio、canvas等 什么叫可替换元素？ 点击查看答案 先解释，后举例 是因为这些元素展示的效果和内容不是 css 直接控制的，而是由元素的标签和属性，或外部资源来决定的。这类元素的内容可以被外部资源所替换，而无需改变元素的标签结构。 以 img 标签来说，它的内容是由 src 属性指定的图片资源来决定的，而不是通过 css 来控制。 CSS 面试题布局盒模型的宽度如何计算？ 点击查看答案 标准盒模型是 box-sizing: content-box，组成部分是：margin + border + padding + content 怪异盒模型是 box-sizing: border-box，组成部分是：margin + content（border + padding + content） 下面代码中的 div 的 offsetWith 有多大？&lt;style&gt; #div &#123; width: 100px; padidng: 10px; border: 1px solid #ccc; margin: 10px; &#125;&lt;/style&gt;&lt;div id=&quot;div&quot;&gt;&lt;/div&gt; 点击查看答案 offsetWidth：122px offsetWidth = （内容宽度 + 内边距 + 边框），无外边距 如何让 offsetWidth 等于 100px？ 点击查看答案 css 中加一句 box-sizing: border-box; 下面代码 AAA 和 BBB 之间的距离是多少？&lt;style&gt; p &#123; margin-top: 10px; margin-bottom: 15px; font-size: 16px; line-height: 1; &#125;&lt;/style&gt;&lt;p&gt;AAA&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;BBB&lt;/p&gt; 点击查看答案 15px 需要注意的是：相邻元素的 margin-top 和 margin-bottom 会重叠；空白内容的 p 标签也会重叠 margin 纵向重叠的问题这个是父子外边距塌陷，可以开启 BFC，来解决塌陷问题。让其两个内容处于独立的层级中，互不影响。可以使用； overflow:hidden; 直接给父元素添加高度; 子元素添加 border； margin 负值的问题margin 的 left、top、right、bototm 为负值会如何？ 点击查看答案 margin-top 为负值，元素向上移动。 margin-left 为负值，元素向左移动。 margin-right 为负值，右侧元素左移，自身不受影响。 margin-bottom 为负值，下方元素上移，自身不受影响。 BFC 理解和应用 点击查看答案 Block format context，块级格式化上下文，开启后，形成一块独立的渲染区域，与外界元素隔离开，内部元素的渲染不会影响到边界以外的元素。 形成 BFC 的条件： float 不是 none position 是 absolute 或 fixed overflow 不是 visible display 是 flex、inline-block 等 BFC 的应用： 清除浮动 解决外边距合并 解决高度塌陷 双栏布局 可以解决高度塌陷，外边距合并问题。 可以通过： overflow: hidden; position 不为 relative; display 为 flex、grid 等开启 float 布局如何实现圣杯布局和双飞翼布局？三栏布局，中间一栏先加载和渲染，随宽度自适应 点击查看答案 技术总结： 使用 float 布局 两侧使用 margin 赋值，以便和中间内容横向重叠 防止中间内容被两侧覆盖，圣杯用 padidng 留白，双飞翼用 margin 留白 手写 clearfix 点击查看答案 .clearfix:after { content: ''; display: table; clear: both; } .clearfix: { *zoom: 1; /* 兼容 IE 低版本 */ } flex 布局flex 实现一个三点的色子 点击查看答案 定位absolute 和 relative 分别依据什么定位？ 点击查看答案 absolute 根据离它最近一层的定位元素进行定位。定位元素包含：absolute、relative、fixed 或 找到 body。 relative 根据自身进行定位。 居中对齐有哪些实现方式？水平居中 点击查看答案 inline 元素：text-align: center block 元素：margin: auto absolute 元素： left: 50% + margin-left 负值，需要知道子元素宽度 left: 50% + transformX(-50%)，不需要子元素宽度 垂直居中 点击查看答案 inline 元素：line-height 的值等于 hegiht 值 absolute 元素： top: 50% + margin-top 负值，需要知道子元素宽度 top: 50% + transformY(-50%)，不需要子元素宽度 top,left,bottom,right = 0 + margin: auto，不需要子元素宽度 图文样式下面代码，line-height 如何继承？p 标签的行高是多少 &lt;style&gt; body &#123; font-size: 20px; line-height: 200%; &#125; p &#123; font-size: 16px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;AAA&lt;/p&gt;&lt;/body&gt; 点击查看答案 40，body 的 font-size * line-height 写具体数值，如 30px，则继承该值。 写比例，如 2/15，则继承该比例，line-height 比例 * 子 font-size。 写百分比，如 200%，则继承计算出来的值，font-size 父 * line-height 父比例 响应式rem 是什么？ 点击查看答案 rem 是相对长度单位，相对于根元素。 rem 与 px、em 对比 点击查看答案 rem 是相对长度单位，相对于根元素，常用语响应式布局。 px 是绝对长度单位。 em 是相对长度单位，相当于父元素。 网页视口尺寸有哪些？ 点击查看答案 window.innerHeight // 网页视口高度，显示内容的哪个高度 window.screen.height // 屏幕高度 document.body.clientHeight // body 高度 介绍一下 vw、vh 点击查看答案 vm 网页视口宽度的 1/100 vh 网页视口高度的1/100 vmax 取两者最大值；vmin 取两者最小值 如何实现响应式？ 点击查看答案 可以使用 @media 来动态设置不同屏幕宽度下的根元素的 font-size，结合 rem。 CSS3动画 – 不是重点JS 面试题值类型 与 引用类型 点击查看答案 typeof 能判断哪些类型？ 点击查看答案 识别所有值类型、识别函数、判断是否为引用类型（不能细分） 何时使用 &#x3D;&#x3D;&#x3D; 何时使用 &#x3D;&#x3D;？ 点击查看答案 除了 == null 之外，其他的都用 === xxx == null 相当于 xxx === null || xxx === undefined 值引用和引用类型的区别下面代码输出什么？const obj1 = &#123; x: 100, y: 200&#125;const obj2 = obj1let x1 = obj1.xobj2.x = 101x1 = 102console.log(obj1) 点击查看答案 101 手写深拷贝原型原型关系 点击查看答案 每个 class 都有显示原型 prototype 每个实例都有隐式原型__proto__ 实例的__proto__指向对应 class 的 prototype 基于原型的执行规则 点击查看答案 获取属性或执行方法时，先找自身的属性和方法，没有则自动通过__proto__查找 如何准确判断一个变量是不是数组？手写一个简单的 jQuery，考虑插件和扩展性class 的原型本质，怎么理解？闭包作用域有哪些？ 点击查看答案 全局作用域、函数作用域、块级作用域 this 的不同应用场景，如何取值？ 点击查看答案 this 的取值是在函数执行时确定的，不是定义时确定的。 手写 bind 函数实际开发闭包的应用场景，举例说明 点击查看答案 隐藏数据 点击时能否弹出对应序号？若不能，弹出的序号是什么？如何修改？let i,afor (i = 0; i &lt; 10; i++) &#123; a = document.createElement(&#x27;a&#x27;) a.innerHTML = i +&#x27;&lt;br&gt;&#x27; a.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; e.preventDefault() alert(i) &#125;) document.body.appendChild(a)&#125; 点击查看答案 10 在for 循环中定义i，不在外部，这样每次循环都会创建一个块作用域。 下面两道代码输出什么？// 函数最为返回值function create() &#123; const a = 100 return function () &#123; console.log(a) &#125;&#125;const fn = create()const a = 200fn() 点击查看答案 100 闭包中所有的自由变量的查找，是在函数定义的地方向上层作用域查找，而不是在执行的地方。 // 函数作为参数function print(fn) &#123; const a = 200 fn()&#125;const a = 100function fn() &#123; console.log(a)&#125;print(fn) 点击查看答案 100 闭包中所有的自由变量的查找，是在函数定义的地方向上层作用域查找，而不是在执行的地方。 异步同步和异步的区别是什么？手写用 Promise 加载一张图片前端 event loop请描述 event loop（事件循环&#x2F;事件轮询）的机制，可画图。 点击查看答案 JS 是单线程，异步需要基于回调来实现。而 event loop 就是异步回调的实现原理。 每次 Call Stack 清空（每次轮询结束），即同步任务执行完；都是 DOM 重新渲染的机会，DOM 结构如果有改变则重新渲染；然后再去触发下一次 Event Loop。 event loop执行顺序：Call Stack 清空、执行当前的微任务、尝试 DOM 渲染、触发 Event Loop。 promisepromise 有哪三种状态？如何变化？ 点击查看答案 pending 进行中，fulfilled 已完成，rejected 已拒绝 pending -> fulfilled 或 pending -> rejected，变化不可逆。 then 正常返回 fulfilled，里面有报错返回 rejected。 catch 正常返回 fulfiled，里面有报错则返回 rejected 下面三道代码输出结果是什么？题目一Promise.resolve().then(() =&gt; &#123; console.log(1)&#125;).catch(() =&gt; &#123; console.log(2)&#125;).then(() =&gt; &#123; console.log(3)&#125;) 点击查看答案 1、3 then 中未报错，不运行后面的 catch，而运行后面的 then。 题目二Promise.resolve().then(() =&gt; &#123; console.log(1) throw new Error(&#x27;error2&#x27;)&#125;).catch(() =&gt; &#123; console.log(2)&#125;).then(() =&gt; &#123; console.log(3)&#125;) 点击查看答案 1、2、3 then 中是报错，运行第一个 catch，catch 中未报错，结果是 resolved，运行后面的 then。 题目三Promise.resolve().then(() =&gt; &#123; console.log(1) throw new Error(&#x27;error1&#x27;)&#125;).catch(() =&gt; &#123; console.log(2)&#125;).catch(() =&gt; &#123; console.log(3)&#125;) 点击查看答案 1、2 then 中是报错，运行第一个 catch，catch 中未报错，而后面跟着的是 catch，不运行。 手写 Promiseasync&#x2F;awaitasync&#x2F;await 是什么？ 点击查看答案 它们是一个语法糖，归根到底还是需要进行 event loop，只是写法是同步的。它们是消灭异步回调的终极武器。 执行 async 函数，返回的是 Promise 对象。 await 相当于 Promise 的 then。 try...catch 可以捕获异常，代替了 Promise 的 catch。 async/await 是微任务 注意：await 处理成功的结果，try...catch 处理错误的结果。当 await 的结果为 rejected 时，后面代码就不会走了，需要 try...catch 捕获异常。 下面三道代码输出什么？题目一async function async1 () &#123; console.log(&#x27;async1 start&#x27;) await async2() console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123; console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;)async1()console.log(&#x27;script end&#x27;) 点击查看答案 script start async1 start async2 script end async1 end 题目二async function fn() &#123; return 100&#125;(async function () &#123; const a = fn() const b = await fn()&#125;)() 点击查看答案 Promise 对象，值为100、100 题目三(async function () &#123; console.log(&#x27;start&#x27;) const a = await 100 console.log(&#x27;a&#x27;, a) const b = await Promise.resolve(200) console.log(&#x27;b&#x27;, b) const c = await Promise.reject(300) console.log(&#x27;c&#x27;, c) console.log(&#x27;end&#x27;)&#125;)() 点击查看答案 start、'a' 100、'b' 200 c 时 reject 导致程序出现异常，程序中断，后面的代码不执行。 宏任务&#x2F;微任务什么是宏任务和微任务，两者有什么区别？ 点击查看答案 宏任务在 DOM 渲染后触发，比如 setTimeout；微任务在 DOM 渲染前触发，比如 Promise。 宏任务：setTimeout、setInterval、Ajax、DOM 事件 微任务：Promise、async/await 为什么微任务在宏任务之前执行？ 点击查看答案 因为每次 Call Stack 清空（每次轮询结束），即同步任务执行完；都是 DOM 重新渲染的机会，DOM 结构如果有改变则重新渲染；然后再去触发下一次 Event Loop。 而宏任务在 DOM 渲染后触发，比如 setTimeout；微任务在 DOM 渲染前触发，比如 Promise。 promise 和 setTimeout 的顺序console.log(100)setTimeout(() =&gt; &#123; console.log(200)&#125;)Promise.resolve().then(() =&gt;&#123; console.log(300)&#125;)console.log(400) 点击查看答案 100、400、300、200 async、await、setTimeout的顺序async function async1() &#123; console.log(&#x27;async1 start&#x27;) await async2() console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123; console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;)setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;)&#125;, 0)async1()new Promise(function (resolve) &#123; console.log(&#x27;promise1&#x27;) resolve()&#125;).then(function() &#123; console.log(&#x27;promise2&#x27;)&#125;)console.log(&#x27;script end&#x27;) 点击查看答案 script start async1 start async2 promise1 script end async1 end promise2 setTimeout DOM 面试题DOM 是哪种数据结构 点击查看答案 树（DOM 树） DOM 操作的常用 API 点击查看答案 有 DOM 节点操作和结构操作，还有 attr 和 property 的操作。getElementById、getElementsByTagName、getElementsByClassName、querySelectorAll、querySelector、getAttribute、createElement、appendChild、removeChild attr 和 property 的区别 点击查看答案 property 修改对象属性，不会体现到 html 结构中；attribute 修改 html 属性，会改变html 结构。两者都有可能引起 DOM 重新渲染。 一次性插入多次 DOM 节点如何考虑性能 点击查看答案 先使用 document.createDocumentFrament() 创建一个文档片段，等都遍历插入到文档碎片中后，最后将文档碎片插入到 DOM 中。 BOM 面试题如何识别浏览器的类型分析拆解 url 各个部分事件编写一个通用的事件监听函数事件代理代码简洁、减少浏览器内存占用，但不要滥用。 描述事件冒泡的流程无限下拉的图片列表，如何监听每个图片的点击？gitgit 的常用命令 点击查看答案 git diff -- 查看修改了的文件信息 git diff 文件名 -- 查看某个文件的修改信息 git config -- 设置提交的信息 git config use.name xxx -- 设置提交的用户名 git config use.email xxx -- 设置提交的邮箱 git log -- 查看提交日志 git show + git log 查询出来日志索引 -- 查看提交详细内容 git checkout 文件名 -- 撤销该文件修改 git checkout . -- 撤销所有文件的修改 git checkout -b 分支名 -- 切换分支 git branch -- 查看分支 get fetch -- 拉取远程的所有分支 浏览器谈谈浏览器浏览器是多进程架构，采用多进程架构可以解决多个线程之间可能存在的恶意修改或获取非授权数据等复杂的安全问题。 单进程浏览器 不稳定。单进程中的插件、渲染线程崩溃会导致整个浏览器崩溃。 不流畅。脚本（死循环）或插件会使浏览器卡顿。 不安全。插件和脚本可以获取到操作系统的任何资源。 多进程浏览器 解决不稳定。进程相互隔离，一个页面或插件崩溃时，影响仅仅当前插件或页面，不会影响到其他页面。 解决不流畅。脚本阻塞当前页面渲染进程，不会影响到其他页面。 解决不安全。采用多进程架构，使用沙箱。 沙箱（安全沙箱）将渲染进程和 OS 隔离开的这道墙就是安全沙箱。沙箱是利用操作系统的安全技术给进程上了一把锁。沙箱的程序是可以运行的，但在渲染进程执行过程中是无法访问或修改 OS 中的数据的；如果需要在渲染进程中访问系统资源，那么需要通过浏览器内核来实现，将访问结果通过 IPC 转发给渲染进程。 IPC 是什么？为什么单进程无法被沙箱保护？因为最小的保护单位是进程。但单进程浏览器需要频繁的访问或修改 OS 的数据，所以单进程浏览器是无法被安全沙箱保护的。 浏览器的主要进程有哪些？浏览器是多进程，主要分为： 知识深度知识深度 1-2 个就行了。深度、广度不能兼得！！！ 如何检测 JS 内存泄露？JS 内存泄露场景有哪些？（JS 垃圾回收是什么算法？）什么是垃圾回收？正常情况下，一个函数执行完，里面的变量都会被 JS 垃圾回收。 function fn() &#123; const a = &#x27;aaa&#x27; // 执行完，a 销毁 console.log(a) const obj = &#123; x: 100 &#125; // 执行完，obj 销毁 console.log(obj)&#125;fn() 但某些情况下，变量不能被回收，因为可能被再次使用。比如变量在函数中挂载到了 window 上或闭包。 function fn() &#123; const obj = &#123; x: 100 &#125; window.obj = obj // 全局变量，obj 销毁不了&#125;fn() function genDataFns() &#123; const data = &#123;&#125; // 闭包，data 销毁不了 return &#123; get(key) &#123; return data[key] &#125;, set(key, val) &#123; data[key] = val &#125; &#125;&#125;const &#123; get, set &#125; = genDataFns() 变量销毁不了，不一定是内存泄露。 Vue 每个生命周期都做了什么？Vue2 Vue3 React 三者的 diff 算法有何区别？","categories":[{"name":"前端面试集锦","slug":"前端面试集锦","permalink":"http://ran-up.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://ran-up.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"typescript知识","slug":"TypeScript/typescript知识","date":"2025-01-20T11:01:22.000Z","updated":"2025-01-17T13:01:15.286Z","comments":true,"path":"2025/01/20/TypeScript/typescript知识/","link":"","permalink":"http://ran-up.github.io/2025/01/20/TypeScript/typescript%E7%9F%A5%E8%AF%86/","excerpt":"","text":"为什么使用 ts 提供类型检查，减少错误 更友好的代码提示 增强代码可读性和可维护性 更好的代码重构 更好的代码组织和管理 JS 的超集，扩展新功能 转换.ts 文件并不被浏览器所识别，运行不了。 所以需要转换为 .js 文件才能被浏览器所识别并运行。 我们可以安装 typescript，使用它提供的 tsc 来编译 .ts 文件。 安装：npm i -g typescript 转换：tsc xx.ts 不过，重新修改文件后需要重新运行转换命令。 如果想修改后自动进行装换，那么需要使用下面的命令。 自动监听的转换命令：tsc xx.ts -w .ts 文件设置全局或局部环境.ts 文件默认是全局环境的。也就是说，我们现在有两个文件，一个 a.ts，一个 b.ts。 a.ts 中定义了一个变量 a，let a = 1，在 b.ts 中输出变量 a，console.log(a)。 上面的代码不是不有警告的，b.ts 能够知道全局环境中有定义的 a 变量。 这样就不好了，我们希望 b.ts 只知道自己定义的 a 变量，而不应该知道全局环境中定义的 a 变量。 解决办法：只要文件使用模块化操作，那么该文件就会变为局部环境。 方法：在每个文件末尾添加 export &#123;&#125;，这样 a.ts、b.ts 就变成了一个个独立的模块，b.ts 就只能使用自己定义的 a 变量了。 生成 tsconfig.json 文件命令：tsc --init 联合类型多个类型，只有符合其中的一个条件即可。 类型之间进行或操作。 let a: string | number = &#x27;1&#x27;a = 1type A = &#123; name: string &#125;type B = &#123; age: number &#125;let person1: A | B = &#123; name: &#x27;zhangsan&#x27; &#125; 交叉类型多个类型，必须符合所有条件。 类型之间进行与操作。 type A = &#123; name: string &#125;type B = &#123; age: number &#125;let person1: A &amp; B = &#123; name: &#x27;zhangsan&#x27;, age: 18 &#125; never表示永远不会出现的值的类型。 很少用，一般是程序自动推断出来的。 let a: string &amp; number = 1 // 不能将类型“1”分配给类型“never”。 也可以手动定义。 function foo(n: 1 | 2 | 3) &#123; switch (n) &#123; case 1: break case 2: break case 3: break default: // 这里是永远无法走到的 let m: never = n break &#125;&#125; any表示任意类型，任何类型都可以赋值给 any 类型。 any 使用时，TS 不进行检测。 unknown表示 any 类型对应的安全类型。 unknow 使用时，TS 会进行检测。 类型断言当 TS 推断出来的类型并不满足我们的使用需要时，可以使用类型断言来手动指定一个类型。 let a: unknown = [1, 2, 3, 4];(a as []).map(() =&gt; &#123; &#125;) 非空断言数组定义方法： 类型[] Array&lt;类型&gt; – 泛型的写法 let arr1: number[] = [1, 2, 3, 4]let arr2: string[] = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]let arr3: Array&lt;number&gt; = [1, 2, 3, 4]let arr4: Array&lt;string&gt; = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]let arr5: (string | number)[] = [&#x27;1&#x27;, &#x27;2&#x27;, 3, 4] 元祖表示一个已知元素数量和类型的数组，各元素的类型不必相同。 注意定义的元素类型和元素的数量和它的类型必须一致。 let arr1: [string, number] = [&#x27;1&#x27;, 1]let arr2: [string, number, string] = [&#x27;1&#x27;, 2, &#x27;3&#x27;] 定义对象、可选属性、索引签名type Person = &#123; name: string age: number, sex?: string // 可选属性 [index: string]: any // 可以是任意属性，索引签名&#125;const person: Person = &#123; name: &#x27;John&#x27;, age: 30, address: &#x27;New York&#x27; // 可以是任意属性，这里就是多的，符合索引签名的定义&#125; 需要注意的是，代码的提示只会提示定义的属性，不会提示索引签名的属性。 如上面会提示的属性有 name、age、address。 空数组、空对象const arr: number[] = [] // 空数组type ObjType = &#123; name: string, age: number&#125;const obj = &#123;&#125; as ObjType // 空对象 定义函数、void类型函数的实参个数和形参个数必须一致。 function foo1 (a: string, b?:number): number &#123; return 123&#125;foo1(&#x27;1&#x27;, 2)const foo2 = (a: string, b?: number): number =&gt; &#123; return 123&#125;foo2(&#x27;1&#x27;, 2)const foo3: (a: string, b?: number) =&gt; number = (a, b) =&gt; &#123; return 123&#125;foo3(&#x27;1&#x27;, 2)type FooType = (a: string, b?: number) =&gt; numberconst foo4: FooType = (a, b) =&gt; &#123; return 123&#125;foo4(&#x27;1&#x27;, 2) void 类型是函数没有返回值的类型。 // 返回 void 可以不写return// 也可以写 return，但后面不跟内容，或者跟 undefinedfunction foo1 () &#123; &#125;function foo2 (): void &#123; return&#125;function foo3 (): void &#123; return undefined&#125; 如果返回的是 undefined 需要手动指定返回类型为 undefined。 函数重载现在需要实现一个函数，它接受一个、两个、四个参数，不能只传三个参数，因为第三个、第四个参数是搭配一起的。 // 函数重载function foo(n1: string): anyfunction foo(n1: string, n2: number): anyfunction foo(n1: string, n2: number, n3: string ,n4: string): anyfunction foo(n1: string, n2?: number, n3?: string, n4?: string): any&#123;&#125;foo(&#x27;1&#x27;)foo(&#x27;1&#x27;, 2)// foo(&#x27;1&#x27;, 2, &#x27;3&#x27;) // Errorfoo(&#x27;1&#x27;, 2, &#x27;3&#x27;, &#x27;4&#x27;) 可调用注解type Foo = &#123; (n1: string): any (n1: string, n2: number): any (n1: string, n2: number, n3: string, n4: string): any username?: string // 添加属性&#125;function foo(n1: string, n2?: number, n3?: string, n4?: string): any&#123;&#125;let fn: Foo = foofn(&#x27;1&#x27;)fn(&#x27;1&#x27;, 2)// fn(&#x27;1&#x27;, 2, &#x27;3&#x27;) // Errorfn(&#x27;1&#x27;, 2, &#x27;3&#x27;, &#x27;4&#x27;)fn.username = &#x27;haha&#x27;console.log(fn.username) // &#x27;haha&#x27; 枚举可以通过枚举的属性名获取枚举的值，也可以通过枚举的值获取枚举的属性名。 enum UserType &#123; SUPER_ADMIN, ADMIN, USER&#125;console.log(UserType.SUPER_ADMIN) // 0console.log(UserType.ADMIN) // 1console.log(UserType.USER) // 2console.log(UserType[0]) // SUPER_ADMINconsole.log(UserType[1]) // ADMINconsole.log(UserType[2]) // USER 可以手动定义枚举的值。后面的枚举值会自动递增。 enum UserType &#123; SUPER_ADMIN, ADMIN = 3, USER&#125;console.log(UserType.SUPER_ADMIN) // 0console.log(UserType.ADMIN) // 3console.log(UserType.USER) // 4console.log(UserType[0]) // SUPER_ADMINconsole.log(UserType[3]) // ADMINconsole.log(UserType[4]) // USER 也可以定义为字符串，但定义为字符串后，所有的枚举值都必须手动赋值。 enum UserType &#123; SUPER_ADMIN = &#x27;super_admin&#x27;, ADMIN = &#x27;admin&#x27;, USER = &#x27;user&#x27;&#125;console.log(UserType.SUPER_ADMIN) // super_adminconsole.log(UserType.ADMIN) // adminconsole.log(UserType.USER) // user enum UserType &#123; SUPER_ADMIN = &#x27;super_admin&#x27;, ADMIN = 2, USER = &#x27;user&#x27;&#125;console.log(UserType.SUPER_ADMIN) // super_adminconsole.log(UserType.ADMIN) // 2console.log(UserType.USER) // user const 枚举未使用 const 定义的枚举，编译结果对比 //.ts 文件enum UserType &#123; SUPER_ADMIN = &#x27;super_admin&#x27;, ADMIN = 2, USER = &#x27;user&#x27;&#125;console.log(UserType.SUPER_ADMIN) // super_adminconsole.log(UserType.ADMIN) // 2console.log(UserType.USER) // user 编译结果 //.ts 文件编译后的.js 文件代码var UserType;(function (UserType) &#123; UserType[&quot;SUPER_ADMIN&quot;] = &quot;super_admin&quot;; UserType[UserType[&quot;ADMIN&quot;] = 2] = &quot;ADMIN&quot;; UserType[&quot;USER&quot;] = &quot;user&quot;;&#125;)(UserType || (UserType = &#123;&#125;));console.log(UserType.SUPER_ADMIN); // super_adminconsole.log(UserType.ADMIN); // 2console.log(UserType.USER); // user 使用 const 定义的枚举，会在编译时被移除，不会生成对应的代码。 // .ts 文件const enum UserType &#123; SUPER_ADMIN = &#x27;super_admin&#x27;, ADMIN = 2, USER = &#x27;user&#x27;&#125;console.log(UserType.SUPER_ADMIN) // super_adminconsole.log(UserType.ADMIN) // 2console.log(UserType.USER) // user 编译后 // .ts 文件编译后的 .js 文件代码console.log(&quot;super_admin&quot; /* UserType.SUPER_ADMIN */); // super_adminconsole.log(2 /* UserType.ADMIN */); // 2console.log(&quot;user&quot; /* UserType.USER */); // user 接口 与 类型别名 的区别接口是一系列抽象方法的声明，是一些方法特征的集合。 简单来说，接口的作用就是为这些类型命名和为我们的代码或第三方代码定义契约。 区别： 接口主要用于对象类型，类型别名均可以。 相同接口定义可以进行合并，类型别名不行。 接口支持继承，类型别名不行。 类型别名支持映射类型，接口不支持。 // 接口主要用于对象类型，类型别名均可以type A = stringtype B = number[]interface C &#123; &#125;// 相同接口定义可以进行合并，类型别名不行。interface D &#123; a: string&#125;interface D &#123; b: string &#125;const e: D = &#123; a: &#x27;a&#x27;, b: &#x27;b&#x27;&#125;// 接口支持继承，类型别名不行。interface F extends D &#123; c: string&#125; 字面量类型可以把字面量作为具体的类型使用，需要注意的是，该类型的取值就必须是该字面量的值。 type Type = &#x27;admin&#x27; | &#x27;test&#x27;const userType: Type = &#x27;admin&#x27; keyof 关键字interface IObj &#123; name: string age: number&#125;// keyof 可以获取对象的所有属性名的联合类型，即 &#x27;name&#x27; | &#x27;age&#x27;// keyof IObj 就是 &#x27;name&#x27; | &#x27;age&#x27;，只能选择这两个值const user: keyof IObj = &#x27;age&#x27;const obj = &#123; name: &#x27;lisi&#x27;, age: 18&#125;// typeof obj 就是 &#123;name: string, age: number&#125;// keyof typeof obj 就是 &#x27;name&#x27; | &#x27;age&#x27;const user2: keyof typeof obj = &#x27;age&#x27; 类型保护类型保护允许我们使用更小范围下的对象类型。 typeof instanceof in 字面量类型 // typeoffunction fn(n: number | string) &#123; if (typeof n === &#x27;string&#x27;) &#123; console.log(n.length) &#125;&#125;// instanceofclass userName &#123; name!: string // 非空断言&#125;class userAge &#123; age!: number&#125;function fn1(n: userName | userAge) &#123; if (n instanceof userName) &#123; console.log(n.name) &#125; &#125;// infunction fn2(n: &#123;name: string&#125; | &#123;age: number&#125;) &#123; if (&#x27;name&#x27; in n) &#123; console.log(n.name) &#125;&#125;// 字面量类型function fn3(n: &#x27;a&#x27; | 123) &#123; if (n === &#x27;a&#x27;) &#123; console.log(n.length) &#125;&#125; 自定义类型保护// is 是类型谓语function isStr(n: any): n is string &#123; return typeof n === &#x27;string&#x27;&#125;function fn(n: number | string) &#123; if (isStr(n)) &#123; console.log(n.length) &#125;&#125;fn(&#x27;123&#x27;) 泛型指在定义函数、接口或类时，未指定参数类型，在运行时才确定。 // 类型别名type A&lt;T&gt; = Tconst a: A&lt;string&gt; = &#x27;string&#x27;const b: A&lt;number&gt; = 1// 接口interface IA&lt;T&gt; &#123; (n: T): T name?: T&#125;const c: IA&lt;string&gt; = (n: string): string =&gt; &#123; return n&#125;c.name = &#x27;string&#x27;// 函数function fn&lt;T&gt; (n: T): T &#123; return n&#125;fn(1)// 类class AClass&lt;T&gt; &#123; name: T constructor (name: T) &#123; this.name = name &#125; getName (): T &#123; return this.name &#125; setName (n: T): string &#123; this.name = n return &#x27;success&#x27; &#125;&#125;const d = new AClass&lt;string&gt;(&#x27;string&#x27;)console.log(d.getName())console.log(d.setName(&#x27;haha&#x27;)) 泛型约束class AClass&lt;T&gt; &#123; name: T constructor (name: T) &#123; this.name = name &#125;&#125;const d = new AClass&lt;string&gt;(&#x27;123&#x27;) // 任何类型const e = new AClass&lt;number&gt;(123)class BClass extends AClass&lt;string&gt; &#123; &#125; // Bclass 只能是 string 类型const f = new BClass(&#x27;string&#x27;)type B = stringfunction fn1&lt;T extends B&gt; (n: T): T &#123; // 只能为 string 类型 return n&#125;fn1(&#x27;string&#x27;) 类型兼容性类型兼容性用于确定一个类型是否能赋值给其他类型。 // 基础类型的兼容性let a: string = &#x27;123&#x27;let b: string | number = 123// a = b // errorb = a // ok// 对象类型的兼容性interface A &#123; a: number&#125;interface B &#123; a: number b: string&#125;let c: A = &#123; a: 1 &#125;let d: B = &#123; a: 1, b: &#x27;1&#x27; &#125;c = d // ok// d = c // error// 函数类型的兼容性function fn(&#123; a: number &#125;) &#123;&#125;fn(&#123; a: 1 &#125;)// fn(&#123; a: 1, b: 2 &#125;) // errorconst value = &#123; a: 1, b: 2 &#125;fn(value) // ok 对于基础类型来说，少的可以赋值给多的。对于对象类型来说，多的可以赋值给少的。对于函数类型来说，实参多的可以赋值给形参少的。 映射类型只能通过 类型别名 来定义映射类型。不能使用 接口 来定义映射类型。 type A = &#123; username: string age: number&#125;type B = &#123; [p in keyof A]: A[p]&#125;const a: B = &#123; username: &#x27;ss&#x27;, age: 12 &#125; keyof A 是获取类型 A 的所有属性名的联合类型，即 &#39;username&#39; | &#39;age&#39;。p in keyof A 是遍历类型 A 的所有属性名，即 &#39;username&#39; | &#39;age&#39;。A[p] 是获取 当前遍历属性 p 在 类型 A 中的类型，即 string | number。 内置工具类型type A = &#123; username: string age: number gender?: string, readonly address?: string&#125;type a = Readonly&lt;A&gt; // 全部变为只读属性/* type a = &#123; readonly username: string; readonly age: number; readonly gender?: string; readonly address?: string;&#125;*/type b = Partial&lt;A&gt; // 全部变为可选属性/* type b = &#123; username?: string; age?: number; gender?: string; readonly address?: string;&#125;*/type c = Pick&lt;A, &#x27;username&#x27; | &#x27;age&#x27;&gt; // 挑选属性/*type c = &#123; username: string; age: number;&#125;*/type d = Record&lt;&#x27;age&#x27;, string&gt; // 把所有属性变为指定类型/* type d = &#123; age: string; &#125; */type e = Record&lt;keyof A, string&gt;/* type e = &#123; username: string; age: string; gender: string; address: string;&#125;*/type f = Required&lt;A&gt; // 全部变为必选属性/* type f = &#123; username: string; age: number; gender: string; readonly address: string;&#125;*/type g = Exclude&lt;string | number | boolean, boolean&gt; // 排除指定类型/* type g = string | number; */type h = Extract&lt;string | number | boolean, boolean&gt; // 提取指定类型/* type h = boolean; */type i = Omit&lt;A, &#x27;username&#x27; | &#x27;age&#x27;&gt; // 剔除指定属性/* type i = &#123; gender?: string; readonly address?: string;&#125;*/type j = NonNullable&lt;string | number | undefined | null&gt; // 排除null和undefined/* type j = string | number; */ infer 关键字type A&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : T// infer U 用来推断数组元素的类型// 为什么加 infer，因为我们不知道数组的元素类型是什么，所以需要推断出来type B = A&lt;Array&lt;number&gt;&gt;type C = A&lt;string&gt; 类如何使用类型类中定义类型class A &#123; username!: string&#125;class B &#123; username: string = &#x27;zhangsan&#x27;&#125;class C &#123; username: string constructor (username: string) &#123; this.username = username &#125;&#125;const a = new A()a.username = &#x27;zhangsan&#x27;const b = new B()b.username = &#x27;zhangsan&#x27;const c = new C(&#x27;zhangsan&#x27;)console.log(a, b, c); // A &#123; username: &#x27;zhangsan&#x27; &#125; B &#123; username: &#x27;zhangsan&#x27; &#125; C &#123; username: &#x27;zhangsan&#x27; &#125;c.username = &#x27;lisi&#x27;console.log(a, b, c); // A &#123; username: &#x27;zhangsan&#x27; &#125; B &#123; username: &#x27;zhangsan&#x27; &#125; C &#123; username: &#x27;lisi&#x27; &#125; 类使用接口interface IA &#123; username: string getUserInfo(age: number): string&#125;class A implements IA &#123; username: string = &#x27;张三&#x27; getUserInfo(age: number): string &#123; return `我叫$&#123;this.username&#125;，今年$&#123;age&#125;岁了` &#125;&#125;const a = new A()console.log(a.getUserInfo(18)) 类使用泛型class A&lt;T&gt; &#123; username: T constructor(username: T) &#123; this.username = username &#125;&#125;const a = new A&lt;string&gt;(&#x27;123&#x27;)class B extends A&lt;number&gt;&#123; &#125;const b = new B(123)// 泛型接口interface IA&lt;T&gt; &#123; username: T getUserInfo(age: number): string&#125;class A implements IA&lt;string&gt; &#123; username: string = &#x27;张三&#x27; getUserInfo(age: number): string &#123; return `我叫$&#123;this.username&#125;，今年$&#123;age&#125;岁了` &#125;&#125;const a = new A()console.log(a.getUserInfo(18))","categories":[{"name":"typescript","slug":"typescript","permalink":"http://ran-up.github.io/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://ran-up.github.io/tags/typescript/"}]},{"title":"手工搭建简易SSR","slug":"SSR/nuxt/手工搭建简易SSR","date":"2025-01-17T16:47:44.000Z","updated":"2025-02-11T14:56:14.635Z","comments":true,"path":"2025/01/18/SSR/nuxt/手工搭建简易SSR/","link":"","permalink":"http://ran-up.github.io/2025/01/18/SSR/nuxt/%E6%89%8B%E5%B7%A5%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93SSR/","excerpt":"","text":"简介最近开始学习 nuxt，先自己搭建一个简易的 SRR，来体验体验，并了解它的运行原理。 搭建 服务端安装初始化项目：npm init -y 安装依赖： npm i vue express npm i -D nodemon vue-loader babel-loader @babel/preset-env webpack webpack-cli webpack-merge webpack-node-externals vue: 前端框架 express：服务器 nodemon: 监听文件变化，自动重启服务器 vue-loader: 加载 .vue 文件 babel-loader: 加载 ES6 语法 @babel&#x2F;preset-env: 转换 ES6 语法 webpack: 打包工具 webpack-cli: 命令行工具 webpack-merge: 合并配置文件 webpack-node-externals: 排除 node 模块 目录结构 config server.config.js node_modules src demo index.html server index.js App.vue app.js package-lock.json package.json 编写代码App.vue&lt;template&gt; &lt;div style=&quot;border: 1px solid #eee&quot;&gt; &lt;h1&gt;&#123;&#123; count &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;addHandler&quot;&gt;点击增加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(100)const addHandler = () =&gt; &#123; count.value++&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; app.js返回函数的原因是避免跨请求状态污染。 import &#123; createSSRApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;// 返回函数，避免跨请求状态污染export default function createApp() &#123; const app = createSSRApp(App) return app&#125; src&#x2F;demo&#x2F;index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;custon-ssr&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;手动搭建ssr&lt;/h1&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; src&#x2F;server&#x2F;index.jsconst express = require(&#x27;express&#x27;)const server = express()// 下面的文件导出方式是 ES6 的 export default 语法，所以这里需要用 import 语句导入// 将 vue 实例转化为 html 字符串import &#123; renderToString &#125; from &#x27;@vue/server-renderer&#x27;import createApp from &#x27;../app.js&#x27;server.get(&#x27;/&#x27;, async (req, res) =&gt; &#123; const app = createApp() // renderToString 是一个异步方法，返回一个 Promise 对象 const appStringHtml = await renderToString(app) // 生成字符串形式的 HTML // html 代码是 src/demo/inde.html 的内容 res.send(` &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;custon-ssr&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;手动搭建ssr&lt;/h1&gt; &lt;div id=&quot;app&quot;&gt; $&#123;appStringHtml&#125; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; `)&#125;)server.listen(3000, () =&gt; &#123; console.log(&#x27;Server is running on http://localhost:3000&#x27;)&#125;) config&#x2F;server.config.jsconst path = require(&#x27;path&#x27;)const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)const nodeExternals = require(&#x27;webpack-node-externals&#x27;) // 忽略node_modulesmodule.exports = &#123; entry: &#x27;./src/server/index.js&#x27;, output: &#123; filename: &#x27;server_bundle.js&#x27;, path: path.resolve(__dirname, &#x27;../build/server&#x27;) &#125;, module: &#123; rules: [ &#123; test: /\\.js$/i, loader: &#x27;babel-loader&#x27;, options: &#123; presets: [&#x27;@babel/preset-env&#x27;] &#125; &#125;, &#123; test: /\\.vue$/i, loader: &#x27;vue-loader&#x27; &#125; ] &#125;, resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;] // import引入文件的时候不用加后缀 &#125;, plugins: [new VueLoaderPlugin()], // vue-loader插件 externals: [nodeExternals()], // 忽略node_modules target: &#x27;node&#x27;, // 服务端渲染 mode: &#x27;development&#x27;&#125; entry 字段讲解 config 目录和 src 目录是同级的，为什么 entry 是 .&#x2F; 而不是 ..&#x2F;？ 因为 webpack 的 entry 是相对于配置文件的 webpack.config.js webpack 配置文件中的 entry 字段是相对于项目根目录的路径，而不是相对于配置文件本身 因此，无论配置文件在哪个目录下，entry 都应该是相对于项目根目录的路径。 所以这里的 .&#x2F;src&#x2F;client&#x2F;index.js 是相对于项目根目录的路径。 package.jsonpackage.json 的 script 添加下面字段。 &quot;script&quot;: &#123; &quot;build:server&quot;: &quot;webpack --config ./config/server.config.js --watch&quot;, &quot;start&quot;: &quot;nodemon ./build/server/server_bundle.js&quot;&#125; 查看结果命令： 打包服务端：npm run build:server 运行：npm run start ctrl + 鼠标左键单击 终端输出的 http:localhost:3000 可在浏览器中看到静态效果，不过点击按钮是无反应的。下面我们接着写客户端配置。 搭建 客户端新增目录结构 config client.config.js src client index.js 编写代码src&#x2F;client&#x2F;index.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;../App.vue&#x27;const app = createApp(App)app.mount(&#x27;#app&#x27;) config&#x2F;client.config.jsconst path = require(&#x27;path&#x27;)const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)module.exports = &#123; entry: &#x27;./src/client/index.js&#x27;, output: &#123; filename: &#x27;client_bundle.js&#x27;, path: path.resolve(__dirname, &#x27;../build/client&#x27;) &#125;, module: &#123; rules: [ &#123; test: /\\.js$/i, loader: &#x27;babel-loader&#x27;, options: &#123; presets: [&#x27;@babel/preset-env&#x27;] &#125; &#125;, &#123; test: /\\.vue$/i, loader: &#x27;vue-loader&#x27; &#125; ] &#125;, resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;] &#125;, plugins: [new VueLoaderPlugin()], target: &#x27;web&#x27;, mode: &#x27;development&#x27;&#125; 进行 Hydration 水合服务器端渲染页面 + 客户端激活页面，是页面有交互效果（这个过程称为：Hydration 水合） Hydration 的具体步骤如下： 开发一个 App 应用，比如 App.vue。 将 App.vue 打包为一个客户端的 client_bundle.js 文件。用来激活应用，使页面有交互效果。 将 App.vue 打包为一个服务器端的 server_bundle.js 文件。用来在服务器端动态生成页面的 HTML。 server_bundle.js 渲染的页面 + client_bundle.js 文件进行 Hydration。 src/server/index.js 添加下面代码 server.use(express.static(&#x27;build&#x27;)) // 静态资源目录// express.static() 是一个 Express 内置的中间件函数，用于提供静态资源// build 目录下的文件会被映射到根路径下。// 例如 build/client/client_bundle.js 可以通过 http://localhost:3000//client/client_bundle.js 访问// server.use(express.static()) 使用中间件函数server.get(&#x27;/&#x27;, async (req, res) =&gt; &#123; res.send(` &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;custon-ssr&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;手动搭建ssr&lt;/h1&gt; &lt;div id=&quot;app&quot;&gt; $&#123;appStringHtml&#125; &lt;/div&gt; &lt;script src=&quot;/client/client_bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `)&#125;) package.jsonpackage.json 的 script 添加下面字段。 &quot;script&quot;: &#123; &quot;build:client&quot;: &quot;webpack --config ./config/client.config.js --watch&quot;&#125; 查看结果命令： 打包客户端：npm run build:client 打包服务端：npm run build:server 运行：npm run start ctrl + 鼠标左键单击 终端输出的 http:localhost:3000 可在浏览器中看到效果，此时点击按钮是有反应的。 去除控制台警告控制台报警告： index.js:6 Feature flags __VUE_OPTIONS_API__, __VUE_PROD_DEVTOOLS__, __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ are not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle. For more details, see https://link.vuejs.org/feature-flags. 去除警告，config/client.config.js 添加下面代码： const &#123; DefinePlugin &#125; = require(&#x27;webpack&#x27;)module.exports = &#123; plugins: [ new VueLoaderPlugin(), // 定义环境变量，关闭 vue 的调试提示 new DefinePlugin(&#123; __VUE_OPTIONS_API__: false, __VUE_PROD_DEVTOOLS__: false, __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: false &#125;) ],&#125; 提取重复配置代码现在的 config&#x2F;server.config.js 和 config&#x2F;client.js 有很多的重复代码，我们可以将其重复代码剔除为一个单独的文件，再在两个文件中引入。 base.config.jsconst &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/i, loader: &#x27;babel-loader&#x27;, options: &#123; presets: [&#x27;@babel/preset-env&#x27;] &#125; &#125;, &#123; test: /\\.vue$/i, loader: &#x27;vue-loader&#x27; &#125; ] &#125;, resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;] &#125;, plugins: [new VueLoaderPlugin()], mode: &#x27;development&#x27;&#125; server.config.jsconst path = require(&#x27;path&#x27;)const nodeExternals = require(&#x27;webpack-node-externals&#x27;) // 忽略node_modulesconst baseConfig = require(&#x27;./base.config&#x27;)const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)module.exports = merge(baseConfig, &#123; entry: &#x27;./src/server/index.js&#x27;, output: &#123; filename: &#x27;server_bundle.js&#x27;, path: path.resolve(__dirname, &#x27;../build/server&#x27;) &#125;, externals: [nodeExternals()], // 忽略node_modules target: &#x27;node&#x27; // 服务端渲染&#125;) client.config.jsconst path = require(&#x27;path&#x27;)const &#123; DefinePlugin &#125; = require(&#x27;webpack&#x27;)const baseConfig = require(&#x27;./base.config&#x27;)const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)module.exports = merge(baseConfig, &#123; entry: &#x27;./src/client/index.js&#x27;, output: &#123; filename: &#x27;client_bundle.js&#x27;, path: path.resolve(__dirname, &#x27;../build/client&#x27;) &#125;, plugins: [ // 定义环境变量，关闭 vue 的调试提示 new DefinePlugin(&#123; __VUE_OPTIONS_API__: false, __VUE_PROD_DEVTOOLS__: false, __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: false &#125;) ], target: &#x27;web&#x27;&#125;) 搭配 vue-router安装：npm i vue-router 注意：为了避免跨请求状态污染，我们需要在每一个请求中都创建一个全新的 Router，也就是生成函数。 目录 src pages home.html about.html router index.js 代码编写src&#x2F;pages&#x2F;home.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这里是 Home 页面&lt;/h1&gt; &lt;div style=&quot;border: 1px solid #eee&quot;&gt; &lt;h1&gt;&#123;&#123; count &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;addHandler&quot;&gt;点击增加&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(100)const addHandler = () =&gt; &#123; count.value++&#125;&lt;/script&gt; src&#x2F;pages&#x2F;about.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这里是 About 页面&lt;/h1&gt; &lt;div style=&quot;border: 1px solid #eee&quot;&gt; &lt;h1&gt;&#123;&#123; count &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;addHandler&quot;&gt;点击增加&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(1000)const addHandler = () =&gt; &#123; count.value++&#125;&lt;/script&gt; src&#x2F;App.vue&lt;template&gt; &lt;div&gt; &lt;div style=&quot;border: 1px solid #eee&quot;&gt; &lt;h1&gt;&#123;&#123; count &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;addHandler&quot;&gt;点击增加&lt;/button&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div&gt; &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt; &lt;/div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(100)const addHandler = () =&gt; &#123; count.value++&#125;&lt;/script&gt; src&#x2F;router&#x2F;index.jsimport &#123; createRouter &#125; from &#x27;vue-router&#x27;const routes = [ &#123; path: &#x27;/&#x27;, component: () =&gt; import(&#x27;../pages/home.vue&#x27;) &#125;, &#123; path: &#x27;/about&#x27;, component: () =&gt; import(&#x27;../pages/about.vue&#x27;) &#125;]export default function (history) &#123; return createRouter(&#123; routes, history &#125;)&#125; src&#x2F;server&#x2F;index.js注意：这里的 get(&#39;/&#39;) 变为了 get(&#39;/*&#39;)，因为在地址栏中 about 页面也需要通过这里访问。 const express = require(&#x27;express&#x27;)const server = express()// 下面的文件导出方式是 ES6 的 export default 语法，所以这里需要用 import 语句导入import &#123; renderToString &#125; from &#x27;@vue/server-renderer&#x27;import createApp from &#x27;../app.js&#x27;import createRouter from &#x27;../router/index.js&#x27;import &#123; createMemoryHistory &#125; from &#x27;vue-router&#x27;server.use(express.static(&#x27;build&#x27;))server.get(&#x27;/*&#x27;, async (req, res) =&gt; &#123; const app = createApp() const router = createRouter(createMemoryHistory()) app.use(router) // 有页面则跳转该页面，无页面就跳转首页 // router.push() 是异步操作 await router.push(req.url || &#x27;/&#x27;) // 用于等待所有异步导航钩子和异步组件加载完成。 // 在服务器端渲染时非常重要，因为需要确保所有异步操作完成后再进行渲染。 // 在客户端 和服务端我们都需要 等待路由器 先解析 异步路由组件 // router.isReady() 是一个异步操作 await router.isReady() // renderToString 是一个异步方法，返回一个 Promise 对象 const appStringHtml = await renderToString(app) // 生成字符串形式的 HTML res.send(` &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;custon-ssr&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;手动搭建ssr&lt;/h1&gt; &lt;div id=&quot;app&quot;&gt; $&#123;appStringHtml&#125; &lt;/div&gt; &lt;script src=&quot;/client/client_bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `)&#125;)server.listen(3000, () =&gt; &#123; console.log(&#x27;Server is running on http://localhost:3000&#x27;)&#125;) src&#x2F;client&#x2F;index.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;../App.vue&#x27;import createRouter from &#x27;../router/index&#x27;import &#123; createWebHistory &#125; from &#x27;vue-router&#x27;const app = createApp(App)const router = createRouter(createWebHistory())app.use(router).mount(&#x27;#app&#x27;) 查看结果命令： 打包客户端：npm run build:client 打包服务端：npm run build:server 运行：npm run start ctrl + 鼠标左键单击 终端输出的 http:localhost:3000 可在浏览器中看到效果。 搭配 pinia安装：npm i pinia 目录 src store index.js 代码编写src&#x2F;store&#x2F;index.jsimport &#123; defineStore &#125; from &#x27;pinia&#x27;export const useCountStore = defineStore(&#x27;count&#x27;, &#123; state() &#123; return &#123; count: 50 &#125; &#125;, actions: &#123; addHandler() &#123; this.count++ &#125; &#125;, getters: &#123; countDouble() &#123; return this.count * 2 &#125; &#125;&#125;) src&#x2F;pages&#x2F;home.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这里是 Home 页面&lt;/h1&gt; &lt;div style=&quot;border: 1px solid #eee&quot;&gt; &lt;h1&gt;&#123;&#123; count &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;addHandler&quot;&gt;点击增加&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;// import &#123; ref &#125; from &#x27;vue&#x27;import &#123; useCountStore &#125; from &#x27;../store&#x27;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;// const count = ref(100)const countStore = useCountStore()const &#123; count &#125; = storeToRefs(countStore)const addHandler = () =&gt; &#123; count.value++&#125;&lt;/script&gt; src&#x2F;pages&#x2F;about.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这里是 About 页面&lt;/h1&gt; &lt;div style=&quot;border: 1px solid #eee&quot;&gt; &lt;h1&gt;&#123;&#123; count &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;addHandler&quot;&gt;点击增加&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;// import &#123; ref &#125; from &#x27;vue&#x27;import &#123; useCountStore &#125; from &#x27;../store&#x27;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;// const count = ref(1000)const countStore = useCountStore()const &#123; count &#125; = storeToRefs(countStore)const addHandler = () =&gt; &#123; count.value++&#125;&lt;/script&gt; src&#x2F;server&#x2F;index.jsconst express = require(&#x27;express&#x27;)const server = express()// 下面的文件导出方式是 ES6 的 export default 语法，所以这里需要用 import 语句导入import &#123; renderToString &#125; from &#x27;@vue/server-renderer&#x27;import createApp from &#x27;../app.js&#x27;import createRouter from &#x27;../router/index.js&#x27;import &#123; createMemoryHistory &#125; from &#x27;vue-router&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;server.use(express.static(&#x27;build&#x27;))server.get(&#x27;/*&#x27;, async (req, res) =&gt; &#123; const app = createApp() const router = createRouter(createMemoryHistory()) app.use(router).use(createPinia()) // 有页面则跳转该页面，无页面就跳转首页 // router.push() 是异步操作 await router.push(req.url || &#x27;/&#x27;) // 用于等待所有异步导航钩子和异步组件加载完成。 // 在服务器端渲染时非常重要，因为需要确保所有异步操作完成后再进行渲染。 // 在客户端 和服务端我们都需要 等待路由器 先解析 异步路由组件 // router.isReady() 是一个异步操作 await router.isReady() // renderToString 是一个异步方法，返回一个 Promise 对象 const appStringHtml = await renderToString(app) // 生成字符串形式的 HTML res.send(` &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;custon-ssr&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;手动搭建ssr&lt;/h1&gt; &lt;div id=&quot;app&quot;&gt; $&#123;appStringHtml&#125; &lt;/div&gt; &lt;script src=&quot;/client/client_bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `)&#125;)server.listen(3000, () =&gt; &#123; console.log(&#x27;Server is running on http://localhost:3000&#x27;)&#125;) src&#x2F;client&#x2F;index.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;../App.vue&#x27;import createRouter from &#x27;../router/index&#x27;import &#123; createWebHistory &#125; from &#x27;vue-router&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;const app = createApp(App)const router = createRouter(createWebHistory())app.use(router).use(createPinia()).mount(&#x27;#app&#x27;) 查看结果命令： 打包客户端：npm run build:client 打包服务端：npm run build:server 运行：npm run start ctrl + 鼠标左键单击 终端输出的 http:localhost:3000 可在浏览器中看到效果。","categories":[{"name":"SSR","slug":"SSR","permalink":"http://ran-up.github.io/categories/SSR/"}],"tags":[{"name":"nuxt","slug":"nuxt","permalink":"http://ran-up.github.io/tags/nuxt/"}]},{"title":"异步题","slug":"前端面试集锦/异步题","date":"2025-01-17T14:37:18.000Z","updated":"2025-01-23T14:38:42.228Z","comments":true,"path":"2025/01/17/前端面试集锦/异步题/","link":"","permalink":"http://ran-up.github.io/2025/01/17/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/%E5%BC%82%E6%AD%A5%E9%A2%98/","excerpt":"","text":"看下面的代码，执行后依次输出什么async function async1() &#123; console.log(&#x27;async1 start&#x27;) await async2() console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123; console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;)setTimeout(function () &#123; console.log(&#x27;setTimeout&#x27;)&#125;, 0)async1()new Promise(function (resolve) &#123; console.log(&#x27;promise1&#x27;) resolve()&#125;).then(function () &#123; console.log(&#x27;promise2&#x27;)&#125;)console.log(&#x27;script end&#x27;) 点击查看答案 script start async1 start async2 promise1 script end async1 end promise2 setTimeout 代码执行步骤： 1.同步代码优先执行： console.log('script start')：直接输出 script start。 调用 async1()，进入 async1 函数： console.log('async1 start')：输出 async1 start。 遇到 await async2()，暂停 async1 的执行，先执行 async2。 进入 async2 函数： console.log('async2')：输出 async2。 async2 执行完毕，返回一个 Promise，await 会让出控制权，将 async1 的剩余部分放入微任务队列。 继续执行同步代码： new Promise 的构造函数是同步的，所以 console.log('promise1')：输出 promise1。 resolve() 将 Promise 的状态改为 fulfilled，将其 then 回调放入微任务队列。 console.log('script end')：输出 script end。 2.微任务队列执行： 微任务队列中有两个任务： async1 中 await 之后的代码：console.log('async1 end')。 Promise 的 then 回调：console.log('promise2')。 按照微任务的先进先出原则： 先执行 console.log('async1 end')：输出 async1 end。 再执行 console.log('promise2')：输出 promise2。 3.宏任务队列执行： 宏任务队列中有一个任务： setTimeout 的回调：console.log('setTimeout')。 执行 console.log('setTimeout')：输出 setTimeout。","categories":[{"name":"前端面试集锦","slug":"前端面试集锦","permalink":"http://ran-up.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://ran-up.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"http状态码","slug":"网络/http状态码","date":"2025-01-16T09:33:18.000Z","updated":"2025-01-16T09:50:13.484Z","comments":true,"path":"2025/01/16/网络/http状态码/","link":"","permalink":"http://ran-up.github.io/2025/01/16/%E7%BD%91%E7%BB%9C/http%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"","text":"返回 400 语法错误：如缺少必要参数、格式不正确等。 未授权：API 需要认证信息，请求未提供有效凭证。 资源不存在：客户端请求的资源在服务器上不存在。 请求过大：客户端发送的请求体太大。 请求超时：客户端的请求在服务器处理时超时。","categories":[{"name":"网络","slug":"网络","permalink":"http://ran-up.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://ran-up.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"webpack 学习","slug":"webpack/webpack学习","date":"2025-01-15T03:41:10.000Z","updated":"2025-01-23T14:37:21.619Z","comments":true,"path":"2025/01/15/webpack/webpack学习/","link":"","permalink":"http://ran-up.github.io/2025/01/15/webpack/webpack%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"准备 新建 webpack-test 文件夹 目录 src hello.js export const hello= &#39;hello&#39; main.js import &#123; hello &#125; from &#39;./hello.js&#39; console.log(hello + &#39; world&#39;) webpack.config.js package.json 打包 js 文件 安装 webpack、webpack-cli npm i -D webpack webpack-cli 在 webpack.config.js 中输入下面代码 module.exports = &#123; entry: &#123; // 入口文件 main: &#x27;./src/main.js&#x27; &#125;, output: &#123; // 出口文件 path: __dirname + &#x27;/dist&#x27; &#125;&#125; 在 package.json 文件中编写命令行执行代码 &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot; &#125; 终端输入：npm run build 生成 dist 文件夹，里面有一个 main.js 文件，这个文件就是打包的 js 文件 新建 index.html，导入打包的js文件：&lt;script src=&#39;./main.js&#39;&gt;&lt;/script&gt; entry 字段讲解现在的目录是这样的： config client.config.js src client index.js package-lock.json package.json 现在我需要在 client.config.js 中配置打包信息，其中遇到一个 entry 路径问题。 我写的是 ../src/client/index.js，报路径错误。 后面改为 ./src/client/index.js 就可以了。 查找了原因： config 目录和 src 目录是同级的，为什么 entry 是 .&#x2F; 而不是 ..&#x2F;？ 因为 webpack 的 entry 是相对于配置文件的 webpack.config.js webpack 配置文件中的 entry 字段是相对于项目根目录的路径，而不是相对于配置文件本身 因此，无论配置文件在哪个目录下，entry 都应该是相对于项目根目录的路径。 所以这里的 .&#x2F;src&#x2F;client&#x2F;index.js 是相对于项目根目录的路径。 html 文件自动引入打包文件 安装插件：npm i -D html-webpack-plugin，这个插件会自动生成 HTML 文件，并将打包后的 JavaScript 和 CSS 文件自动插入到 HTML 中。 新建 public 文件夹 和 index.html 文件，作为插件的模板 html 文件 修改 webpack.config.js 代码： const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;) // 自动生成 HTML 文件的插件module.exports = &#123; entry: &#123; // 入口文件 main: &#x27;./src/main.js&#x27; &#125;, output: &#123; // 出口文件 path: __dirname + &#x27;/dist&#x27; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./public/index.html&#x27; // 作为生成 HTML 文件的模板文件 &#125;) ]&#125; 修改 src&#x2F;main.js 文件内容：import &#123; hello &#125; from &#39;./hello.js&#39; console.log(hello + &#39; world!!!&#39;) 终端输入：npm run build 可以看到在 dist 文件夹中会自动生成 index.html index.html 使用模板插件提供的 title 可以在 HtmlWebpackPlugin 中定义 title 信息 const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;) // 自动生成 HTML 文件的插件module.exports = &#123; entry: &#123; // 入口文件 main: &#x27;./src/main.js&#x27; &#125;, output: &#123; // 出口文件 path: __dirname + &#x27;/dist&#x27; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./public/index.html&#x27;, // 作为生成 HTML 文件的模板文件 title: &#x27;webpack-test&#x27; &#125;) ]&#125; 修改 public&#x2F;index.html 的 title 标签内容：&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; 终端输入：npm run build 可以在浏览器中看到标签页的 title 信息已经生效了，显示的：“webpack-test” 清除 dist 目录中的旧文件 安装插件：npm i -D clean-webpack-plugin，此插件在每次打包前清除输出目录中的旧文件。避免打包后的旧文件残留在输出目录中，导致构建过程中的文件混乱或冗余。保持输出目录的整洁。 修改 dist 文件夹中的 index.html 文件名为 index111.html 修改 webpack.config.js const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;) // 自动生成 HTML 文件的插件const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;) // 打包前清除输出目录中的旧文件module.exports = &#123; entry: &#123; // 入口文件 main: &#x27;./src/main.js&#x27; &#125;, output: &#123; // 出口文件 path: __dirname + &#x27;/dist&#x27; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./public/index.html&#x27; // 作为生成 HTML 文件的模板文件 &#125;), new CleanWebpackPlugin() ]&#125; 终端输入：npm run build 可以看到 dist 文件夹中的 index111.html 被删除，从新出现 index.html 文件。 配置 webpack 的 web 服务环境 此时的 webpack 是没有 web 服务环境的，可以使用 webpack-dev-server 模块来启动 web 服务 安装：npm i -D webpack-dev-server 修改 package.json 中的 script 脚本，添加 &quot;serve&quot;: &quot;webpack-dev-server&quot; 终端输入：npm run serve，就可以启动一个运行在 80 端口的服务了 此时的项目具有热更新，修改代码后不需要重新在终端进行启动 配置 sourcemap sourcemap 启动映射文件，可以通过浏览器查找原始的文件，这样对调试是非常有帮助的。 比如我们现在在 main.js 中输入一个错误代码，console.log(a)，a 是不存在的，肯定会报错。 上面可以看到报错信息指向的是打包后的文件，对于我们调试来说很麻烦。 可以使用 sourcemap 来映射文件，帮助我们更好的找到错误的位置。 在 webpack.config.js 文件中添加如下代码：devtool: &#39;inline-source-map&#39; 修改了 webpack.config.js 文件后记得重新启动项目：npm run serve css 模块化 安装 css-loader 和 style-loader 来支持 css 模块化 命令：npm i -D css-loader style-loader 在 webpack.config.js 中添加下面代码module: &#123; rules: [ &#123; test: /\\.css$/i, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] // 从右至左依次执行 &#125; ]&#125; 终端输入：npm run serve 去控制台查看 Elements 选项能够发现 body 类上加入了 * &#123; margin: 0; padding: 0; &#125; 代码。 图片模块化 如果想让 webpack 支持图片模块化也需要相应的 loader，不过最新版本的 webpack 已经内置了对图片的处理。 只需要配置好信息即可实现对图片的模块化处理。 修改 webpack.config.js 代码module: &#123; rules: [ &#123; test: /\\.(png|gif|jpg|jpeg)/i, type: &#x27;asset/resource&#x27; &#125; ]&#125; public&#x2F;index.html 添加 img：&lt;img src=&quot;&quot; alt=&quot;&quot;&gt; main.js 添加：import img from &#x27;./assets/01.png&#x27;const imgDom = document.querySelector(&#x27;img&#x27;)imgDom.src = img 终端输入：npm run serve 处理单文件 .vue 文件 安装：npm i -D vue vue-template-complier vue-loader vue – 让 vue 功能生效 vue-template-complier – 支持单文件组件 vue-loader – 把单文件组件进行转换 webpack.config.js 文件添加下面代码const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;)module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.vue$/i, loader: &#x27;vue-loader&#x27; &#125; ] &#125;, plugins: [ new VueLoaderPlugin() ]&#125; 新建 src&#x2F;App.vue 文件&lt;template&gt; &lt;div class=&quot;greet&quot; @click=&quot;clickHandler&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; msg: &#x27;Hello World&#x27; &#125; &#125;, methods: &#123; clickHandler() &#123; alert(&#x27;Hi Vue&#x27;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .greet &#123; background-color: skyblue; &#125;&lt;/style&gt; src&#x2F;main.js 文件新增下面代码import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;createApp(App).mount(&#x27;#app&#x27;) pulic&#x2F;index.html 新增下面代码：&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 终端输入：npm run serve，可以看到页面显示 “hello word”，并且背景为天蓝色。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://ran-up.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://ran-up.github.io/tags/webpack/"}]},{"title":"ElemetPlus报使用被废弃语法","slug":"Vue/ElemetPlus报使用被废弃语法","date":"2025-01-03T03:58:45.000Z","updated":"2025-01-03T04:12:40.588Z","comments":true,"path":"2025/01/03/Vue/ElemetPlus报使用被废弃语法/","link":"","permalink":"http://ran-up.github.io/2025/01/03/Vue/ElemetPlus%E6%8A%A5%E4%BD%BF%E7%94%A8%E8%A2%AB%E5%BA%9F%E5%BC%83%E8%AF%AD%E6%B3%95/","excerpt":"","text":"简介今天做项目，遇到个很奇葩的问题： [ElPagination] 你使用了一些已被废弃的用法，请参考 el-pagination 的官方文档 之后对照文档，将一个一个属性改为固定数字后发现了问题。 原因改到 total 属性是发现报错消失，恢复到使用动态参数时报错恢复，此时发现了问题出处。 猜测是 total 最初没有获取到的原因导致。 因为我使用了 TypeScript :total=&quot;hospital_work_data?.total&quot;const hospital_work_data = ref&lt;HospitalWork | null&gt;(null) 当请求到接口数据后 hospital_work_data 才会有内容，导致页面渲染后没有第一时间获取到内容导致。 确定了问题就好解决了。 解决办法我给 total 添加了一个默认值：:total=&quot;hospital_work_data?.total || 6&quot; 最终问题解决。","categories":[{"name":"vue","slug":"vue","permalink":"http://ran-up.github.io/categories/vue/"}],"tags":[{"name":"ElementPlus","slug":"ElementPlus","permalink":"http://ran-up.github.io/tags/ElementPlus/"}]},{"title":"router 中使用 pinia 的仓库，仓库属性不更新 bug","slug":"Vue/router中使用pinia的仓库","date":"2024-12-31T14:43:21.000Z","updated":"2024-12-31T15:07:04.216Z","comments":true,"path":"2024/12/31/Vue/router中使用pinia的仓库/","link":"","permalink":"http://ran-up.github.io/2024/12/31/Vue/router%E4%B8%AD%E4%BD%BF%E7%94%A8pinia%E7%9A%84%E4%BB%93%E5%BA%93/","excerpt":"","text":"简介今天做项目在 router 中使用 pinia 的仓库时遇到了一些问题，记录一下。 我的操作是，在 router 中的前置路由守卫中使用 pinia 的用户信息仓库，修改其中的属性。 问题操作页面后，页面不更新，仓库中的属性不更新。 我最初想法是在前置路由守卫之外获取 pinia 仓库实例。之后再路由守卫中修改其中的属性。触发页面内容的改变。 但这先出现了报错：&quot;getActivePinia()&quot; was called but there was no active Pinia. Are you trying to use a store before calling &quot;app.use(pinia)&quot;? 然后我在获取 pinia 仓库实例时传入了 createPinia() 函数：const userStore = useUserStore(createPinia()) 这样就可以获取到 pinia 仓库实例了，并解决了报错。 注意：在 main.ts 中需要保证 pinia 的加载在 路由 的加载之前。app.use(createPinia()).use(router) 然后出现了现在的错误，仓库的内容不会更新。 最终发现的是在前置路由守卫之外定义的内容，不是响应式的，获取不到最新的内容。 原因前置路由守卫之外定义的内容，不是响应式的，获取不到最新的内容。 需要在路由守卫中定义，当每次路由跳转时会获取到最新的内容。 解决在前置路由守卫中使用 useStore() 函数获取 pinia 仓库实例：const userStore = useUserStore()","categories":[{"name":"vue","slug":"vue","permalink":"http://ran-up.github.io/categories/vue/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"http://ran-up.github.io/tags/vue3/"}]},{"title":"牛客前端js笔试题","slug":"前端面试集锦/牛客前端js笔试题","date":"2024-12-27T17:38:35.766Z","updated":"2024-12-27T17:38:35.766Z","comments":true,"path":"2024/12/28/前端面试集锦/牛客前端js笔试题/","link":"","permalink":"http://ran-up.github.io/2024/12/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/%E7%89%9B%E5%AE%A2%E5%89%8D%E7%AB%AFjs%E7%AC%94%E8%AF%95%E9%A2%98/","excerpt":"","text":"一些面试笔试题 单选题JS基础js概念与类型检测以下不属于 typeof 运算符返回值的是？ A. &quot;string&quot;B. &quot;function&quot;C. &quot;object&quot;D. &quot;null&quot; D 执行以下代码，错误的输出结果是 A. 输入：typeof &#123;&quot;x&quot;:1&#125; 输出：&#x27;object&#x27;B. 输入：typeof 1 输出：&#x27;number&#x27; C. 输入：typeof [&#123;x:1&#125;] 输出：&#x27;array&#x27; D. 输入：typeof NaN 输出：&#x27;number&#x27; C 应该输出：'object' 可以用 typeof 来判断的基本类型有 A. undefinedB. nullC. arrayD. object A typeof 可以检测 `number、string、boolean、undefined、function、object。` null、array 使用 typeof 检测出来都是：'object' object 是引用类型 以下不属于JavaScript基本数据类型的是： A. BooleanB. undefinedC. SymbolD. Array D 以下关于JavaScript中数据类型的说法错误的是 A. 数据类型分为基本数据类型和引用数据类型B. JavaScript一共有8种数据类型C. Object是引用数据类型，且只存储于堆(heap)中D. BigInt是可以表示任意精度整数的基本数据类型，存储于栈(stack)中 C 逻辑判断请选择结果为ture的表达式？ A. null instanceof ObjectB. null === undefinedC. null == undefinedD. NaN == NaN C NaN 不与任何值相等，包括它本身 下列代码结果为 true 的是？ A. Symbol.for(&#x27;a&#x27;) === Symbol.for(&#x27;a&#x27;)B. Symbol(&#x27;a&#x27;) === Symbol(&#x27;a&#x27;)C. NaN === NaND. &#123;&#125; === &#123;&#125; A Symbol.for(key) 会在 symbol 注册表中找相应的 key，找到就返回，未找到就创建。 Symbol 为独一无二的值，不相等 NaN 不与任何值相等，包括它本身 {} 为引用类型，是两个独立的对象，存储的地址不同 根据如下变量，下列表达式中返回值为true的是 var a = 1;var b = [];var c = &#x27;&#x27;;var d = true;A. (a || b) === trueB. (b &amp;&amp; c) === trueC. (c &amp;&amp; d) === trueD. (d || a) === true D || 或运算，第一个为 true 就返回第一个的值，为 false 就返回第二个的值 && 与运算，第一个为 true 就返回第二个值，为 false 就返回第一个的值 a || b --> 1、b && c --> ''、c && d --> ''、d || a --> true 1&#x3D;&#x3D;true的返回值是true，这句话是否正确？ A. TB. F A 下面代码输出为true的是? A. console.log([] === []);B. console.log(undefined == 0);C. console.log(undefined == false);D. console.log(false == &#x27;&#x27;); D 浏览器环境下，以下打印结果为true的是 A. console.log(&quot;12&quot; === 12)B. console.log (NaN === NaN)C. console.log (typeof(null) === typeof(window))D. console.log ([1,2,3] === [1,2,3]) C C选项都返回为 object 以下表达式，正确的是 A. Number(&#x27;a&#x27;) == Number(&#x27;a&#x27;)B. -1 == trueC. 3 + &#x27;2&#x27; === 5D. ![] == &#x27;&#x27; D Math如何把 7.25 四舍五入为最接近的整数 A. Math.round(7.25)B. Math.ceil(7.25)C. round(7.25)D. Math.rnd(7.25) A 下面哪个选项可以产生 0&lt;&#x3D;num&lt;&#x3D;10 的随机整数 A. Math.floor(Math.random()*6)B. Math.floor(Math.random()*10)C. Math.floor(Math.random()*11)D. Math.ceil(Math.random()*10) C 注意：D永远取不到0，但能取到10 以下( )表达式产生一个0~7之间(含0,7)的随机整数 A. Math.floor(Math.random()*6)B. Math.floor(Math.random()*7)C. Math.floor(Math.random()*8) C 字符串split() 方法用于把一个字符串分割成字符串数组。 A. TB. F A String对象的哪个方法可以寻找子字符串并返回该子字符串位置 A. match()B. indexOf()C. search()D. concat() BC JSON下面哪一个是JSON数据？ A. ｛name:&quot;xiaoming&quot;,age,&quot;student&quot;｝B. ｛&quot;name&quot;:&quot;xiaoming&quot;,&quot;age&quot;:&quot;student&quot;｝C. ｛&quot;xiaoming&quot;,&quot;student&quot;｝D. [&quot;xiaoming&quot;,&quot;student&quot;] B 下面分别使用 JSON.stringify 方法，返回值 res 分别是 const fn = function()&#123;&#125;const res = JSON.stringify(fn)const num = 123const res = JSON.stringify(num)const res = JSON.stringify(NaN)const b = trueconst res = JSON.stringify(b) A. &#x27;function&#x27;、&#x27;123&#x27;、&#x27;NaN&#x27;、&#x27;true&#x27;B. undefined、&#x27;123&#x27;、undefined、&#x27;true&#x27;C. undefined、&#x27;123&#x27;、&#x27;null&#x27;、&#x27;true&#x27;D. undefined、&#x27;123&#x27;、&#x27;null&#x27;、undefined C 数组js数组中不会改变原有数组的方法是() A. pushB. concatC. sortD. shift B 下列哪种数组的方法不会修改数组本身 A. sliceB. spliceC. sortD. unshift A JavaScript中需要往数组末尾处添加一个元素，应该使用以下哪个方法： A. pushB. popC. shiftD. unshift A 以下js操作Array的方法中不能添加元素的是： A. pushB. popC. unshiftD. splice B 数组以下哪个方法会影响原数组？ A. concatB. spliceC. sliceD. join B JavaScript中，下列哪一个Array的方法的返回值类型和其他不同 A. concatB. shiftC. filterD. map B 如下的 Array.prototype 上的方法中，那个方法不会改变原有的数组？ A. pushB. sliceC. spliceD. sort B 对于一个数字组成的数组 nums，现在需要执行在不改动 nums 的基础上去重操作，返回一个新的无重复元素的数组，以下几段代码能完成这一操作的是() // (1)const newNums = Array.from(new Set(nums)) // (2)const newNums = nums.filter((n, i) =&gt; &#123; return nums.indexOf(n) === i&#125;) // (3)const newNums = nums.forEach((n, i) =&gt; &#123; return nums.indexOf(n) === i&#125;) // (4)const newNums = nums.reduce((acc, n, i) =&gt; &#123; return [].concat(acc, nums.indexOf(n) === i ? n : [])&#125;) A. (1)、(2)、(3)、(4)B. (1)、(3)、(4)C. (1)、(2)、(4)D. (1)、(4) C 正则正则表达式 ^d+[^d]+ 能匹配下列哪个字符串？ A. 123B. 123aC. d123D. 123def C 下面哪个不是RegExp对象的方法 A. testB. matchC. execD. compile D 以下哪项可以去除变量str中的所有空格 A. str.replace(`/\\s*/g,&quot;&quot;`)B. str.replace(`/^\\s|\\s$/g,&quot;&quot;`)C. str.replace(`/^\\s*/, &quot;&quot;`)D. str.replace(`/(\\s*$)/g, &quot;&quot;`) A 其他下列函数哪个不是JavaScript的全局函数 A. encodeURIB. parseFloatC. roundD. eval C 编写高性能JavaScript，以下描述错误的是 A. 遵循严格模式：&quot;use strict&quot;B. 将js脚本放在页面顶部，加快渲染页面C. 将js脚本成组打包，减少请求，尽量减少使用闭包D. 使用非阻塞方式下载js脚本，最小化重绘(repaint)和回流(reflow) B 有关JavaScript中系统方法的描述，错误的是？ A. parseFloat方法：该方法将一个字符串转换成对应的小数B. isNaN方法：该方法用于检测参数是否为数值型，如果是，返回true，否则，返回false。C. escape方法： 该方法返回对一个字符串编码后的结果字符串D. eval方法：该方法将某个参数字符串作为一个JavaScript执行题 B 下面列出的浏览器，无webkit内核的是() A. chromeB. SafariC. 搜狗浏览器D. Firefox D 下列代码哪个能够实现获取形式为 2017-08-01 形式的日期( )？ // Avar formatDate=getDate()// Bvar formatDate = new Date()// Cvar formatDate = function (date) &#123; var y = date.getFullYear(); var m = date.getMonth() + 1; var d = date.getDate(); return y + &#x27;-&#x27; + m + &#x27;-&#x27; + d;&#125;;// Dvar formatDate = function (date) &#123; var y = date.getFullYear(); var m = date.getMonth() + 1; m = m &lt; 10 ? &#x27;0&#x27; + m : m; var d = date.getDate(); d = d &lt; 10 ? (&#x27;0&#x27; + d) : d; return y + &#x27;-&#x27; + m + &#x27;-&#x27; + d;&#125;; D 下面哪一项不能最小化重绘(repaint)和回流(reflow) A. 需要对元素进行复杂的操作时，可以先隐藏(display:&quot;none&quot;)，操作完成后再显示B. 需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入documentC. 尽量避免用table布局(table元素一旦触发回流就会导致table里所有的其它元素回流)D. 尽量不要使用 css 属性简写，如：用border-width, border-style, border-color代order D JS深入this下列哪种方法不能改变this指向() A. evalB. applyC. bindD. call A 在JavaScript中下面选项关于this描述正确的是 A. 在使用new实例化对象时, this指向这个实例对象B. 将对象的方法赋值给变量A。执行A()时 该方法中的this指向这个对象。 C. 在函数定义时,this指向全局变量D. 在浏览器下的全局范围内，this指向全局对象 A 下面有关JavaScript中call和apply方法的描述，错误的是？ A. call与apply都属于 Function.prototype 的一个方法，所以每个function实例都有call、apply属性B. 两者传递的参数不同，call函数第一个参数都是要传入给当前对象的对象，apply不是C. apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入D. call传入的则是直接的参数列表。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 B 作用域(闭包)内存泄漏是 javascript 代码中必须尽量避免的，以下几段代码可能会引起内存泄漏的有() // (1)function getName() &#123; name = &#x27;javascript&#x27;&#125;getName() // (2)const elements = &#123; button: document.getElementById(&#x27;button&#x27;)&#125;;function removeButton() &#123; document.body.removeChild(elements.button);&#125;removeButton() // (3)let timer = setInterval(() =&gt; &#123; const node = document.querySelector(&#x27;#node&#x27;) if(node) &#123; clearInterval(timer) &#125;&#125;, 1000); A. (1)、(2)、(3)B. (2)、(3)C. (1)、(3)D. (1)、(2) D (2) 是如果一直不点击就会形成：没有被清理的DOM元素引用 那个操作不会造成内存泄露 A. 没有清理的DOM元素引用B. 被遗忘的定时器C. 事件侦听没有移除D. 局部变量不用时，没有设为null D 下列关于闭包理解错误的是 A. 增加一定的内存消耗B. 使用不当可能会导致内存泄漏C. 可以使用闭包模拟私有方法D. 闭包会改动对象的原型链 D 原型与继承JavaScript实现继承的方式，不正确的是： A. 原型链继承B. 构造函数继承C. 组合继承D. 关联继承 D 继承方式 原型链继承 构造函数继承 组合继承 寄生式继承 寄生式组合继承 所有对象都有原型 A. TB. F B null 没有 以下关于原型链的描述正确的是: A. 通过原型链继承的属性和对象自己定义的属性等效B. 通过原型链可以模拟对象的私有属性C. 在对象上访问不存在的属性时,会依次遍历整条原型链D. 所有 JavaScript 中的对象都是位于原型链顶端的 `Object` 的实例 C 其他以下不属于前端数据存储方式的是？ A. jsonpB. cookieC. localStorageD. sessionStorage A DOM题事件流将A元素拖拽并放置到B元素中，B元素需要做哪项操作()？ A. event.preventDefault()B. event.prevent()C. event.drag()D. event.drop() A 以下不支持冒泡的鼠标事件为( )？ A. mouseoverB. clickC. mouseleaveD. mousemove C mouseenter、mouseleave都不支持事件冒泡 在javascript中，用于阻止默认事件的默认操作的方法是 A. stopDeafault()B. stopPropagation()C. preventDefault()D. preventDefaultEven() C 事件传播的三个阶段是什么 目标 -&gt; 捕获 -&gt; 冒泡冒泡 -&gt; 目标 -&gt; 捕获目标 -&gt; 冒泡 -&gt; 捕获捕获 -&gt; 目标 -&gt; 冒泡 D 下面有关 javascript 常见事件的触发情况，描述错误的是？ A. onchange：用户改变域的内容B. onkeypress：某个键盘的键被按下或按住C. onmousedown：某个鼠标按键被按下D. onblur：元素获得焦点 D DOM遍历下列哪项不属于DOM查找节点的属性()？ A. parentObj.firstChildB. parentObj.childrenC. neborNode.previousSiblingD. neborNode.siblings D DOM中，给父节点添加子节点的正确方法为()？ A. appendChild(parentNode,newNode);B. append(parentNode,newNode);C. parentNode.append(newNode);D. parentNode.appendChild(newNode); D JavaScript中document.getElementById()返回值的类型为？ A. ArrayB. ObjectC. StringD. Function B getElementById --> 返回 Function getElementById() --> 返回 Object 其他DOM元素的以下属性改变会导致重排(reflows)的是 outlinevisiblityfont-sizebackground-color C BOM题setInterval(updateClock,60)的含义是( )？ A. 每隔60秒调用一次updateClock()B. 每隔60毫秒调用一次updateClock()C. 每隔60分钟调用一次updateClock()D. 每分钟调用60次updateClock() B 使用方法( )可以获取到地理位置所在的经纬度？ A. Geolocation.watchPosition()B. Geolocation.getCurrentPosition()C. Geolocation.getPosition()D. Geolocation.Position() B setInterval(“alert(‘welcome’);”,1000);这段代码的意思是 A. 等待1000秒后，再弹出一个对话框B. 等待1秒钟后弹出一个对话框C. 每隔一秒钟弹出一个对话框D. 语句报错,语法有问题 C ES6题箭头函数下列对js箭头函数描述错误的是() A. 箭头函数没有原型属性B. 箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值C. 箭头函数可以作为构造函数，使用newD. 箭头函数不绑定arguments，取而代之用rest参数解决 C 关于箭头函数下列说法错误的一项是： A. 函数体内this的指向是定义时所在的对象，而不是使用时所在的对象B. 箭头函数内不能使用arguments对象C. 箭头函数不能使用yield命令D. 可以使用new创建一个箭头函数的实例 D promise关于将 Promise.all 和 Promise.race 传入空数组的两段代码的输出结果说法正确的是： Promise.all([]).then((res) =&gt; &#123; console.log(&#x27;all&#x27;);&#125;);Promise.race([]).then((res) =&gt; &#123; console.log(&#x27;race&#x27;);&#125;);A. all 和 race 都会被输出B. all 和 race 都不会被输出C. all 会被输出，而 race 不会被输出D. all 不会被输出，race 会被输出 C all 如果传入的迭代是空的，则返回一个已完成（already resolved）状态的 Promise。 race 如果传的迭代是空的，则返回的 promise 将永远等待。 以下方案中，不是用于解决回调陷阱的的是： A. PromiseB. GeneratorC. asyncD. Proxy D 在 ECMAScript6 中，不属于promise的状态是: A. PendingB. PauseC. FulfilledD. Rejected B 解构赋值关于ES6解构表达式,描述正确的是() let [a, b, c, d, e] = &quot;hello&quot;; A. e = &quot;hello&quot;;B. 其它都为undefinedC. 当中 a = &quot;h&quot;, b = &quot;e&quot;;D. 语法报错 C 多选题JS基础下面哪些数组方法会改变原数组 A. push B. concat C. splice D. map AC 下面可以声明数字的js代码是 A. const a = 0xa1B. const a = 076C. const a = 0b21D. const a = 7e2 ABD 以下属于操作符 typeof 的返回值的是： (1) function(2) object(3) null(4) array(5) NaN(6) bigint(7) regexp(8) undefinedA. (1)、(2)、(3)、(4)、(5)、(6)、(7)、(8)B. (1)、(2)、(3)、(8)C. (1)、(2)、(8)D. (1)、(2)、(6)、(8) D 以下()结果等于字符串string A. typeof &#x27;string&#x27;B. String(&#x27;string&#x27;).toString()C. &#x27;string&#x27;.split(&#x27;&#x27;).sort().join(&#x27;&#x27;)D. (function(string)&#123;return string&#125;)(&#x27;string&#x27;)E. JSON.parse(&#x27;&#123;&quot;string&quot;:&quot;string&quot;&#125;&#x27;).string ABDE 下面的等式成立的是? A. parseInt(46.8) == parseFloat(46.8)B. NaN !== NaNC. isNaN(&#x27;abc&#x27;) == NaND. typeof NaN === &#x27;number&#x27; BD 以下哪些选项可以将集合A转化为数组？ A. Array.from(A)B. [].slice.apply(A)C. [...A]D. [].map.call(A, o =&gt; o) ABCD 下列结果返回 true 的是 A. null == undefinedB. null === undefinedC. null === nullD. NaN == nullE. NaN === NaNF. Infinity + 1 !== Infinity AC JS深入关于以下代码，说法正确的有哪些？ function Person() &#123; &#125;var person = new Person(); A. 每一个原型都有一个constructor属性指向关联的构造函数。B. 每一个对象都有一个prototype属性。C. Object.getPrototypeOf(person) === Person.prototypeD. person.constructor === Person ACD 下列在 JS 时间循环机制中属于微任务(microTask)的是？ A. process.nextTickB. promiseC. setTimeoutD. setInterval AB ES6以下关于let和const的说法中正确的是: A. let声明的变量值和类型都可以改变B. const声明的常量不可以改变C. 两者都不存在变量提升，同时存在暂时性死区，只能在声明的位置后面使用D. const可以先声明再初始化，可以后赋值 ABC 下面关于Promise说法正确的是(注意“返回结果”的意思包含成功或者失败) A. Promise.all在所有给定的promise都fulfilled后才返回结果B. Promise.race在给定的promise中，某个fulfilled后才返回结果C. promise.then的回调函数中，可以返回一个新的promiseD. 对于一个向后台获取数据已经产生结果的promise:p1，再次调用p1.then，不会去重新发起请求获取数据 CD Promise.all 中的promise全部fulfilled则成功，则返回的value为一个数组；若有一个rejected则失败，整体抛出的异常为第一个失败的promise抛出的异常。 Promise.race 中的promise只要有一个且是第一个成功或失败则整体的结果就是这个promise的结果 DOM下列关于使用 JS 修改元素样式的代码，正确的有哪些？ A. document.body.style.[&#x27;background-color&#x27;] = &#x27;#fff&#x27;B. document.body.style.setProperty(&#x27;background-color&#x27;, &#x27;#fff&#x27;)C. document.body.style = &#x27;background-color: #fff&#x27;D. document.body.style.fontSize = &#x27;14px&#x27; BCD `style.setProperty(propertyName, value, priority);`为一个声明了 CSS 样式的对象设置一个新的值 下列方法可用于阻止事件冒泡的有 A. event.cancelBubble = true;B. event.stopPropagation();C. event.preventDefault();D. return false; ABD 填空题类型检测1.在JavaScript中，有var arr = []; typeof arr的结果为? 'object' 2.以下使用 typeof 操作符的代码的输出结果为 var x = typeof xvar res = typeof typeof x;console.log(x, res) 'undefined'、'string 3.[typeof null, null instanceof Object]的结果是什么? 'object'、false 4.typeof typeof 0 'string' 5.JavaScript的typeof运算符的可能结果为array？解释为什么 不可能，因为 typeof 只能检测基本数据类型，array 是引用数据类型。 6.下面代码的输出结果是多少？ var arr = [];console.log(typeof arr, Object.prototype.toString.call(arr)); 'object'、'[object Array]' 7.下面的结果是？ console.log(Object.prototype.toString.call(undefined)) '[object Undefined]' 类型转换1.表达式 &quot;2&quot;+3+4 的值为？ '234' 2.console.log(&#39;5&#39; + 3, 5 + &#39;3&#39;) '53'、'53' 3.var a = parseInt(&quot;111办公室&quot;);alert(a); 111 4.[&quot;0x1&quot;, &quot;0x2&quot;, &quot;0x3&quot;].map(parseInt) 的结果 1、NaN、0 5.在js中执行 1+&#39;1&#39;的结果是？ 11 6.在js中执行 parseInt(&#39;77&#39;,40)的结果是? NaN parseInt() 的第二位参数是2-36之间 逻辑判断1.请给出 [5&lt;6&lt;3,3&lt;2&lt;4] 代码的运行结果 [true, true] 我觉得这就是比较大小，从左到右依次执行。 首先比较5","categories":[{"name":"前端面试集锦","slug":"前端面试集锦","permalink":"http://ran-up.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/"}],"tags":[{"name":"笔试题","slug":"笔试题","permalink":"http://ran-up.github.io/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"}]},{"title":"pure主题增加文章更新时间","slug":"pure主题配置/pure主题增加文章更新时间","date":"2024-12-27T17:38:35.763Z","updated":"2024-12-27T17:38:35.763Z","comments":true,"path":"2024/12/28/pure主题配置/pure主题增加文章更新时间/","link":"","permalink":"http://ran-up.github.io/2024/12/28/pure%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/pure%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4/","excerpt":"","text":"当给文章进行更新，却没有更新提示，这怎么能行呢，于是，这篇文章出现了。 浅浅声明一下这篇文章，是借鉴了Hexo博客Hiker主题增加文章最后编辑时间并按照最后编辑时间排序。在此非常感谢Vientiane提供的详细而清晰的修改教程，因为每个人的需求不同，进行了相应的修改，如果想要观看原文，或者更多的配置，请移步上面的原文链接。 由于 Hiker 主题和 Pure 主题的 layout 结构是类似的，所以我们可以从 Vientiane 的修改方式中，发现适合我们 pure 主题配置的具体修改方式。 调整 Hexo 主配置文件我们找到主配置文件 _config.yml（注意：不是主题的 _config.yml），修改 index_generator 的 order_by 为 -updated 就可以开启以更新时间来排序，就会将最后修改过的文章显示在最前面。 index_generator: path: &#x27;&#x27; per_page: 10 order_by: -updated # -date、-updated 以上传时间或更新时间排序 然后继续修改 date_format 部分，将 YYYY-MM-DD 改成如下的 YYYY-MM-DD HH:mm:ss格式，再重新生成一下网页就能看到具体的时间了。 date_format: YYYY-MM-DD HH:mm:sstime_format: HH:mm:ss## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;updated_option: &#x27;mtime&#x27; 新建 updated.ejs 文件在 themes\\pure\\layout\\_partial\\post 中的 date.ejs 这个文件中添加一些东西。 内容如下： &lt;!-- 上传时间 --&gt;&lt;span class=&quot;article-date&quot;&gt; &lt;i class=&quot;icon icon-calendar-check&quot;&gt;&lt;/i&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;&quot; class=&quot;&lt;%= class_name %&gt;&quot;&gt; &lt;%= __(&#x27;published&#x27;) %&gt; &lt;time datetime=&quot;&lt;%= date_xml(post.date) %&gt;&quot; itemprop=&quot;datePublished&quot;&gt; &lt;%= date(post.date, date_format) %&gt; &lt;/time&gt; &lt;/a&gt;&lt;/span&gt;&lt;!-- 更新时间 --&gt;&lt;span class=&quot;article-date&quot;&gt; &lt;i class=&quot;icon icon-calendar-check&quot;&gt;&lt;/i&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;&quot; class=&quot;&lt;%= class_name %&gt;&quot;&gt; &lt;%= __(&#x27;updated&#x27;) %&gt; &lt;time datetime=&quot;&lt;%= date_xml(post.updated) %&gt;&quot; itemprop=&quot;dateUpdated&quot;&gt; &lt;%= date(post.updated, date_format) %&gt; &lt;/time&gt; &lt;/a&gt;&lt;/span&gt; 大体上与 date.ejs 内容相仿，post.date 改成了 post.updated，itemprop&#x3D;”datePublished” 改成了 itemprop=&quot;dateUpdated&quot;。同时还多了一个 &lt;%= __(&#39;updated&#39;) %&gt;，因为在原来的格式下只会显示时间，而这两个时间没有任何的提示信息，就会不知道哪个是哪个，所以为了用户体验，我们需要加上一些明显的提示信息。 同时在 上传时间 中也多了个 &lt;%= __(&#39;published&#39;) %&gt;，这是为了配合 更新时间，而添加的提示性文本信息。 配置提示文本 由于 date.ejs 中分别引入了 published 和 updated 字段，因此我们需要去在语言文件中新增对应的字段，语言文件在 themes/pure/languages中，你博客设置成什么语言，就修改对应的语言文件，当然全部更改也是可以的，这样就方便后面的语言切换。 打开文件，在文件中增加两行：(我是添加到文章最后的) copyright: theme_by: Theme by base_on: base on powered_by: Powered by# 这个是给时间前面设置个醒目文本 published: 首次updated: 更新 保存退出即可。简单解释一下，格式为字段名：字段值，字段名不变，字段值可以随意更改。 修改 archive-post.ejs 文件打开 themes\\pure\\layout\\_partial\\archive-post.ejs 文件，找到： &lt;%- partial(&#39;post/date&#39;, &#123;class_name: &#39;article-date&#39;, date_format: &#39;MMM D&#39;&#125;) %&gt;，把其中的 date_format 改为 null，保存退出即可。这里是为了防止首页」和「文章页」时间格式不一致的问题。 &lt;p class=&quot;article-meta&quot;&gt; &lt;!-- 上传时间 --&gt; &lt;%- partial(&#x27;post/date&#x27;, &#123;class_name: &#x27;article-date&#x27;, date_format: null&#125;) %&gt; &lt;%- partial(&#x27;post/category&#x27;) %&gt; &lt;%- partial(&#x27;post/tag&#x27;) %&gt; &lt;span class=&quot;post-comment&quot;&gt;&lt;i class=&quot;icon icon-comment&quot;&gt;&lt;/i&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;#comments&quot; class=&quot;article-comment-link&quot;&gt;&lt;%= __(&#x27;article.comments&#x27;) %&gt;&lt;/a&gt;&lt;/span&gt; &lt;%- partial(&#x27;post/wordcount&#x27;) %&gt; &lt;/p&gt; 配置 .md 文件date: &#123;date&#125; updated: &#123;date&#125; 结束$效果展示然后你就可以：hexo clean、hexo g、hexo s看看效果了。 首页样式 文章页样式","categories":[{"name":"pure主题配置","slug":"pure主题配置","permalink":"http://ran-up.github.io/categories/pure%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"pure主题新增时间","slug":"pure主题新增时间","permalink":"http://ran-up.github.io/tags/pure%E4%B8%BB%E9%A2%98%E6%96%B0%E5%A2%9E%E6%97%B6%E9%97%B4/"}]},{"title":"Sass知识点概括","slug":"CSS预处理器/Sass知识点概括","date":"2024-12-27T17:38:35.754Z","updated":"2024-12-27T17:38:35.754Z","comments":true,"path":"2024/12/28/CSS预处理器/Sass知识点概括/","link":"","permalink":"http://ran-up.github.io/2024/12/28/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/Sass%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E6%8B%AC/","excerpt":"","text":"Sass知识点梳理 概念Sass (英文全称：Syntactically Awesome Stylesheets) 是一个最初由 Hampton Catlin 设计并由 Natalie Weizenbaum 开发的层叠样式表语言。 Sass 是一个 CSS 预处理器，可以帮助我们减少 CSS 重复的代码，节省开发时间。 Sass 完全兼容所有版本的 CSS；扩展了 CSS3，增加了规则、变量、混入、选择器、继承、内置函数等等特性。 Sass 生成良好格式化的 CSS 代码，易于组织和维护；文件后缀为 .scss。 Sass 定义变量使用 $ 符号，引用外部文件使用 @include 。 作用CSS 本身语法不够强大，导致重复编写一些代码，无法实现复用，而且代码也不方便维护。 Sass 引入合理的样式复用机制，增加了规则、变量、混入、选择器、继承、内置函数等特性。 对于重复使用的 CSS 样式就可以在头部设置为一个单独的变量，方便了后期的修改和管理。 使用方法上面已经知道了 Sass 是什么了，以及它的作用，那我们如何使用呢？ 首先咱们的浏览器并不支持 Sass 代码。 所以，我们就需要自己使用 Sass 预处理器来先将 Sass 代码转换为 CSS 代码。 并且要将页面中链接的地址改成，刚刚转换为 CSS 代码的这个地址。 安装 Sass使用 npm 来全局安装：npm install -g sass 查看版本使用：sass --version 转换规则 先创建一个后缀名为 .scss 的文件。后面的 xxx 是我们取的文件名！ 使用 sass xxx.scss 就可以将文件转换为 CSS 代码，但是它并不会创建 .css 文件，只是在终端输出了转换的 CSS 代码。 我们也可以指定文件，使用 sass xxx.scss xxx.css ，将转换的代码放到指定的 xxx.css 文件中了，可以自动创建 .css 文件。 上面的方法每次修改了 sass 文件，就需要手动重新调用，如果想执行一次之后每次修改文件后自动进行编译，那我们可以在调用后面添加一个 -w：sass xxx.scss xxx.css -w，这样就可以修改后自动编译了。 注释Sass 中有两种注释方式：// 和 /**/ 其中 // 为单行注释，也叫静默注释，其内容不会出现在 CSS 文件中。 /* ... */ 为多行注释， 也叫标准注释格式，它里面的注释内容可以编译到 css 文件中去。 并且当注释出现在原生 css 不允许的地方时，Sass 会将这些注释抹掉。 我们还可以定义变量，以插值语句的形式写进多行注释中来输出变量值。 变量变量用于存储一些信息，它们可以被重复使用。 Sass 变量可以存储以下信息 (数据类型)： 字符串：有或无引号字符串，比如：”foo”, ‘bar’, baz 数字：1, 2, 13, 10px 颜色值：blue, #04a3f9, rgba(255,0,0,0.5) 布尔值：true, false **数组(list)**：用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif 空值：null maps：相当于 JavaScript 的 object，(key1: value1, key2: value2) Sass 变量使用 $ 符号：$名称: 值。 名字可以使用连接符连接，不过在 Sass 中的 -与_是相同的，也就是 @mixin xxx-yyy &#123;...&#125; 与 @mixin xxx_yyy &#123;...&#125; 是一样的。 Sass 中也有全局和局部作用域之分，在文件头部 (最外层)设置的变量就是全局变量，而在一个样式中设置的变量则是局部变量。 我们如果想在其他样式中也用那个变量，就给局部变量加上 !global 关键字来将其修改为全局变量。 不过，我们通常将所有的全局变量定义在同一个文件，如：_globals.scss，然后我们使用 @include 来包含该文件。 注意：当我们使用 #&#123;&#125; 时，有引号的字符串会被编译为无引号的字符串，这样便于在 混入(mixin) 中引用选择器名。 /* 1_Sass.scss 文件 *//* 全局作用域 */$myColor: red;$fontSize: 14px;$fontFamily: Helvetica,sans-serif;$myWidth: 200px;$myHeight: 200px;$myBorder: 1px solid $myColor;div &#123; /* 局部作用域 */ $myColor: pink; /* 全局作用域 */ /* $myColor: pink !global; */ width: $myWidth; height: $myHeight; border: $myBorder; background-color: $myColor;&#125;body &#123; background-color: $myColor;&#125;/* 1_Sass.css 文件*/div &#123; width: 200px; height: 200px; border: 1px solid red; background-color: pink;&#125;body &#123; /* 局部作用域 */ background-color: red; /* 全局作用域 */ /* background-color: pink; */&#125; 运算所有数据类型均支持 == 、 !=，此外，每种数据类型也有其各自支持的运算方式。 数字运算Sass 支持数字的加减乘除、取整等运算 (+, -, *, &#x2F;, %)，会根据情况会在不同的单位间进行转换。 /* Sass 文件*/p &#123; width: 1pt + 1px;&#125;/* CSS 文件*/p &#123; width: 1.75pt;&#125; 关系运算 (&lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;) 也可用于数字运算，相等运算 (&#x3D;&#x3D;, !&#x3D;) 可用于所有数据类型。 除法运算以下三种情况 / 将被视为除法运算符号： 如果值或值的一部分，是变量或者是函数的返回值。 如果值被圆括号包裹。 如果值是算数表达式的一部分。 也就是写上：数字 &#x2F; 数字 这种情况没用。不能是单纯的数字，而是需要通过某些操作转化为数字才行。 /* Sass 文件 */p &#123; font: 10px/8px; /* CSS */ $width: 1000px; width: $width/2; /* 变量 */ width: round(1.5)/2; /* function */ height: (500px/2); /* () */ margin-left: 5px + 8px/2px; /* + 算数表达式 */&#125;/* CSS 文件 */p &#123; font: 10px/8px; width: 500px; height: 250px; margin-left: 9px;&#125; 如果需要使用变量，同时又不想 / 做除法运算而是完整地编译到 CSS 文件中，则使用 #&#123;&#125; 插值语句将变量包裹。 /* Sass 文件 */p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125; / #&#123;$line-height&#125;;&#125;/* CSS 文件 */p &#123; font: 12px/30px;&#125; 颜色值运算颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值。 !default使用sass的!default标签可以让其他通过@import导入 sass 库文件的使用者去自定义修改 sass 库文件中的某些值。 !default用于变量。 含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。 $myWidth: 400px !default;div &#123; width: $myWidth;&#125; 嵌套规则与属性嵌套Sass 嵌套 CSS 选择器类似于 HTML 的嵌套规则。 也就是允许将一套 CSS 样式嵌套进另一套样式中，将外层的选择器作为自身的父选择器。 嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更易于管理。 在一个大盒子里面包含的其他标签可以在 Sass 中进行选择器嵌套，而有些 CSS 属性可以进行属性嵌套。 就比如有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中。 如：font-xxx，text-xxx等。 这里是：最外层为 nav，nav 里面有一个无序列表 ul，ul中有 li，li中又有链接 a，还对 font 属性进行了拆分嵌套操作。 /* 2_嵌套.scss 文件 */nav &#123; width: 1200px; height: 30px; /* 选择器嵌套 */ ul &#123; list-style: none; &#125; /* 选择器嵌套 */ li &#123; margin-left: 5px; float: left; height: 10px; /* 选择器嵌套 */ a &#123; padding: 0 5px; /* 属性嵌套 -- 有前缀的 CSS 属性 font-xxx */ font: &#123; family: Helvetica, sans-serif; weight: bold; size: 14px; &#125; /* 属性嵌套 -- 有前缀的 CSS 属性 text-xxx */ text: &#123; align: center; &#125; &#125; &#125;&#125;/* 2_嵌套.css 文件 */nav &#123; width: 1200px; height: 30px;&#125;nav ul &#123; list-style: none;&#125;nav li &#123; margin-left: 5px; float: left; height: 10px;&#125;nav li a &#123; padding: 0 5px; font-family: Helvetica, sans-serif; font-weight: bold; font-size: 14px; text-align: center;&#125; 并且命名空间也可以拥有自己的属性值。 /* Sass 文件 */div &#123; font: 20px/24px &#123; family: Helvetica, sans-serif; weight: bold; &#125;&#125;/* CSS 文件 */div &#123; font: 20px/24px; font-family: Helvetica, sans-serif; font-weight: bold;&#125; 父选择器 &amp;当我们在嵌套 CSS 时，有时也需要直接使用嵌套外层的父选择器。 也就是遇到伪元素或者伪类选择器的时候，不想以 后代选择器 的方式连接，那么这时候就可以使用 &amp; 来连接。 必须将 &amp; 放在最前面，作为选择器的第一个字符，在其之后跟随需要生成复合的其它选择器。 在编译后的 CSS 文件中 &amp; 会被替换成在嵌套外一层的父选择器。 如果是多层次的嵌套，那么会将最外层的父选择器一层一层向下传递。 /* sass 文件 */div &#123; padding: 5px; width: 200px; height: 200px; background-color: yellow; &amp;:hover &#123; background-color: pink; &#125;&#125;/* css 文件 */div &#123; padding: 5px; width: 200px; height: 200px; background-color: yellow;&#125;div:hover &#123; background-color: pink;&#125; 并集选择器的嵌套css的写法会让你在并集选择器中的每一个选择器前都重复一遍容器元素的选择器。 比如：.container h1, .container h2, .container h3 &#123; ... &#125; 而 sass的嵌套特性也是支持这种场景的。 当sass解开一个并集选择器内嵌时，它会把每一个内嵌选择器都正确地解析出来。 /* sass 文件*/ .container &#123; h1, h2, h3 &#123; margin-bottom: .8em &#125;&#125;/* css 文件 */.container h1,.container h2,.container h3 &#123; margin-bottom: margin: 5px;&#125; &gt;、+和~ 选择器：在 CSS 中 &gt;、+ 和 ~ 分别叫：相邻后代选择器、相邻兄弟选择器 和 全部兄弟选择器。但在 Sass 中，它们分别叫：子组合选择器、同层选择器 和 同层全体组合选择器。 这三个选择器必须和其他选择器配合使用，以指定浏览器仅选择某种特定上下文中的元素。 我们可以使用子组合选择器 &gt; 选择一个元素的直接子元素。 也可以用 同层选择器 + 和 同层全体组合选择器 ~ ，分别选择一个元素紧跟着的兄弟元素，或者选择所有跟在那个元素后面的同层元素，不管它们之间隔了多少其他元素。 /* sass 文件 */article &#123; /* 同层全体组合选择器 */ ~ article &#123; border-top: 1px dashed #ccc &#125; /* 子组合选择器 */ &gt; section &#123; background: #eee &#125; dl &gt; &#123; dt &#123; color: #333 &#125; dd &#123; color: #555 &#125; &#125; /* 同层选择器 */ nav + &amp; &#123; margin-top: 0 &#125;&#125;/* css 文件 */article ~ article &#123; border-top: 1px dashed #ccc &#125;article &gt; footer &#123; background: #eee &#125;article dl &gt; dt &#123; color: #333 &#125;article dl &gt; dd &#123; color: #555 &#125;nav + article &#123; margin-top: 0 &#125; @import 与 Partials@importSass 可以帮助我们减少 CSS 重复的代码，节省开发时间。 我们可以像 CSS 那样为不同的属性创建不同的代码文件，如：变量定义的文件、颜色相关的文件、字体相关的文件等。 然后利用 @import 将这些文件导入到需要使用的文件中。 可以全局导入，也可以局部导入。 语法：@import &quot;文件名&quot;; 这里的文件名可以是 CSS 文件，也可以是 Sass 文件，Sass 文件可以不加后缀名，因为它会自动添加上去，不过 CSS 文件还是要自己添加上后缀名哈。 注意：这里的 @import 只是将文件包含在 CSS 中，不需要额外的 HTTP 请求；不像 CSS中的那样：在每次调用时，都会创建一个额外的 HTTP 请求。 Partials如果我们不希望将 Sass 文件编译成 CSS 文件，那么就可以在命名文件名的时候，在文件名的开头处添加上一个下划线 。 但是，在使用 @import 导入文件时，我们不需要添加下划线。 语法：_文件名 注意： 不能 将带下划线与没有带下划线的同名文件放置在 同一目录 下，不然带下划线的文件将会被忽略，这样就白设置了。 /* 3_import.scss 文件 */@import &quot;2_嵌套&quot;;@import &quot;1_Sass&quot;;/* 3_import.css 文件 *//* 就是将 2_嵌套.scss 和 1_Sass.scss 里面的代码全部导入到一个文件中了*/@charset &quot;UTF-8&quot;;nav &#123; width: 1200px; height: 30px;&#125;nav ul &#123; list-style: none;&#125;nav li &#123; margin-left: 5px; float: left; height: 10px;&#125;nav li a &#123; padding: 0 5px; font-family: Helvetica, sans-serif; font-weight: bold; font-size: 14px; text-align: center;&#125;div &#123; width: 200px; height: 200px; border: 1px solid red; background-color: pink;&#125;body &#123; background-color: red;&#125; @mixin 与 @include@mixin 指令允许我们定义一个可以在整个样式表中 重复使用的样式。 @include 指令可以 将混入 （mixin） 引入到文档 中。 并且在混入中也可以包含混入，也可以给混入传递参数和默认的参数。 在进行兼容浏览器时，浏览器前缀使用混入也是非常方便的。 那么我们如何去判断一组属性是否应该组合成一个混合器呢？ 可以给这个混合器取一个浅显的、好的名字。如果你能找到一个很好的短名字来描述这些属性修饰的样式，比如rounded-corners、fancy-font或者no-bullets，那么往往能够构造一个合适的混合器。如果你找不到，这时候构造一个混合器可能并不合适。 定义 mixin混入(mixin)通过 @mixin 指令来定义。 语法：@mixin 名字 &#123; ... &#125; /* 定义混入(mixin) */@mixin txt-style &#123; text-align: center; text-decoration: none; color: pink;&#125; 使用 mixin@include 指令可用于包含混入。 语法：选择器 &#123; @include 混入的名字; &#125; div &#123; width: 200px; height: 200px; background-color: yellow; a &#123; font-size: 14px; /* 导入混入(mixin) */ @include txt-style; &#125;&#125;/* css文件 */div &#123; width: 200px; height: 200px; background-color: yellow;&#125;div a &#123; font-size: 14px; text-align: center; text-decoration: none; color: pink;&#125; 在混入中包含混入@mixin special-text &#123; @include important-text; @include link; @include special-border;&#125; 给混入传入参数注意：如果我们需要在 混入(mixin) 中引用 选择器名，那么需要使用 #&#123;&#125; ，来将有引号的字符串编译为无引号的字符串，不然会报错。 固定参数/* 混入接收两个参数 */@mixin myBorder($width, $color) &#123; border: $width solid $color;&#125;div &#123; /* 调用混入，并传参 */ @include myBorder(1px, pink);&#125;ul &#123; /* 调用混入，并传参 */ @include myBorder(2px, black);&#125;/* css文件 */div &#123; border: 1px solid pink;&#125;ul &#123; border: 2px solid black;&#125; 含有默认参数/* $color:yellow 的默认参数为黄色 */@mixin myBorder($width, $color:yellow) &#123; border: $width solid $color;&#125;div &#123; /* 调用混入，并传参 */ @include myBorder(1px);&#125;ul &#123; /* 调用混入，并传参 */ @include myBorder(2px, black);&#125;/* css文件 */div &#123; border: 1px solid yellow;&#125;ul &#123; border: 2px solid black;&#125; 可变参数当我们不能确定一个混入（mixin）或者一个函数（function）使用多少个参数，这时我们就可以使用参数变量 … 声明 (写在参数的最后方）告诉 Sass 将这些参数视为值列表处理。 /* 可变参数 */@mixin box-shadow($shadows...) &#123; /* 兼容其他浏览器 */ -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows;&#125;div &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);&#125;/* css文件 */div &#123; -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;&#125; 参数变量也可以用在引用混合指令的时候 (@include)，与平时用法一样，将一串值列表中的值逐条作为参数引用。 /* Sass 文件 */@mixin colors($text, $background, $border) &#123; color: $text; background-color: $background; border-color: $border;&#125;$values: #ff0000, #00ff00, #0000ff;div &#123; @include colors($values...);&#125;/* CSS 文件 */div &#123; color: #ff0000; background-color: #00ff00; border-color: #0000ff;&#125; @extend 与 继承@extend 指令告诉 Sass 一个选择器的样式从另一选择器继承。 如果一个样式与另外一个样式几乎相同，只有少量的区别，则使用 @extend 就显得很有用。 @extend 很好的体现了代码的复用。 /* extend.scss 文件 */div &#123; margin: 5px; width: 200px; height: 200px; background-color: red&#125;.div1 &#123; @extend div; background-color: pink;&#125;.div2 &#123; @extend div; background-color: yellow; cursor: pointer;&#125;/* extend.css 文件*/div, .div2, .div1 &#123; margin: 5px; width: 200px; height: 200px; background-color: red;&#125;.div1 &#123; background-color: pink;&#125;.div2 &#123; background-color: yellow; cursor: pointer;&#125;","categories":[{"name":"CSS预处理器","slug":"CSS预处理器","permalink":"http://ran-up.github.io/categories/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://ran-up.github.io/tags/Sass/"}]},{"title":"真实高质量低代码商业项目前端后端运维管理系统","slug":"项目流程记载/真实高质量低代码商业项目前端后端运维管理系统","date":"2024-12-27T17:29:38.000Z","updated":"2025-02-10T14:26:57.019Z","comments":true,"path":"2024/12/28/项目流程记载/真实高质量低代码商业项目前端后端运维管理系统/","link":"","permalink":"http://ran-up.github.io/2024/12/28/%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E8%AE%B0%E8%BD%BD/%E7%9C%9F%E5%AE%9E%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%95%86%E4%B8%9A%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AB%AF%E5%90%8E%E7%AB%AF%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"架构师课程笔记需求分析 架构师课程的组成 业务相关 - 完成慕课乐高项目 前端开发 后端开发 和开发相关的流程- 单元测试，部署，上线等 研发相关 脚手架 组件平台 监控平台等 需求等资源 链接：https://www.yuque.com/books/share/af79538c-09eb-4ddd-bfb7-599816c233bf 将慕课乐高 https://imooc-lego.com/ 网站当作高保真原型（UX prototypes）进行使用。将需求分类进行提取。 Axure RP Figma Adobe XD 需求分类 模版 模版列表 使用模版创建 用户 获取验证码 手机登录 获取用户信息 作品 创建 字体修改 内容缩放 内容拖拽 保存 发布 获取作品列表以及信息 分享到 H5 渠道 获取渠道 创建渠道 删除渠道 技术架构设计需要几个项目 前后端分离项目 前端（SPA 项目，使用 Vue 或者 React） - lego 网站：https://imooc-lego.com/ 编辑器 (lego-editor?) 其他页面(lego-pages?) 后端 - lego-backend RESTful API H5 页面 SSR (Server side rendering) 组件库 - lego-components 核心问题分析抓住关键问题：海报，或者说是作品是整个系统的核心也是难点。 海报的组成 背景，由图片或者纯色组成。 元素 由各种不同的元素（组件）组成。 一部分属性界定它的位置（position）。 一部分属性界定它的展示（looks）。 扩展性 - 场景设计 海报添加对应的背景音乐 新的组件类型 - 比如说当前日期 本课程完成的文档：https://imooc-lego.yuque.com/books/share/dc22e979-74b0-4e88-a04b-1b0e93ec0ef5?# 《技术方案》 复杂项目业务的复杂度 交互的复杂性，拖拽、改变字体等 数据结构和状态的复杂性 多项目互相依赖的复杂性 打包 性能优化 第三方库使用和调研以及二次开发 流程的复杂度 git flow lint 工具 单元测试 commit 信息 PR review CI&#x2F;CD 简单分析一下 B 端的需求只是简要的分析。从页面上分，会分为这几个页面。 首页 导航条 未登录和已登录 未登录 显示登录按钮 已登录 显示 创建设计，我的作品，还有下拉菜单（个人设置和登出） 展示列表 图片 标题 作者信息 和 使用人数 Hover 显示创建按钮 搜索 搜索以后有清空按钮 点击更多展示列表（每页展示 8 条） 我的作品 （展示四条 右侧到我的作品页面） 登录 发送验证码 登录 表单验证 模版详情页 展示 图片 二维码 标题 作者 使用该模版创建 下载图片 我的作品 作品或者模版列表 编辑 统计 删除 转赠 下载图片 搜索 翻页 编辑器 左 组件面板 - 可以添加到编辑器中的组件类型 文本 图形 形状 中 编辑器区域 - 从左侧添加的组件都会呈现到编辑器中 点击选中 拖动改变位置 拖动改变大小 快捷键 右键菜单 右 属性编辑面板 - 可以编辑中间组件的属性以及其他功能 元素属性，详细的在实现的时候在讨论 图层面板 隐藏显示 锁定解锁 拖动排序 背景设置 顶部 - 保存，发布，预览和设置 点击保存 点击预览 弹框 左侧显示预览 右侧设置标题，描述和头图， 发布 - 弹框 左侧显示截图 右侧显示默认渠道，并且可以进行编辑 其他 - 不属于界面上的一些功能（定时保存 ，退出前提示等等） 技术选型 node版本: v16.13.0 可以使用 nvm 进行切换 node 版本 nvm 网站：https://github.com/nvm-sh/nvm TypeScript版本：v5.1.6 安装：npm i typescript -g 编译：tsc &lt;文件名.ts&gt; 基础数据类型let flag: boolean = falselet age: number = 10let str: string = &#x27;hello&#x27;let u: undefined = undefinedlet n: null = nulllet num: number = undefinedlet notSure: any = 4 // 任何类型notSure = &#x27;word&#x27; 数组和元祖// 数组let arr: number[] = [1, 2, 3] // 数字类型的数组，只能添加数字类型// 元祖let arr2: [number, string] = [1, &#x27;2&#x27;] // 第一位为数字，第二位为字符串// 但是在上面不能写超过 2 个，但可以通过 push 添加这两种类型，其他的不行arr2.push(3) interface 接口 对对象的形状进行描述 Duck Typeing（鸭子类型） 不会编译到 JS 中，只是在 TS 中类型检查 interface Person &#123; readonly id: number // 只读属性 name: string age?: number // 可选属性&#125;const userInfo: Person = &#123; id: 1, name: &#x27;ranup&#x27;, age: 18&#125; Function 函数在 JS 中函数是一等公民 // 函数声明function add(a: number, b: number, z?: number): number &#123; return typeof z === &#x27;number&#x27; ? a + b + z : a + b&#125;// 函数表达式const add1 = (a: number, b: number, z?: number): number =&gt; &#123; return typeof z === &#x27;number&#x27; ? a + b + z : a + b&#125;// 赋值const sum1: (a: number, b: number, z?: number) =&gt; number = add// 接口类型interface ISum &#123; (a: number, b: number, z?: number): number&#125;// 赋值const sum2: ISum = add1 联合类型（union type）let numberOrString: string | number = 12// 访问共有的属性或方法console.log(numberOrString.toString())console.log(numberOrString.valueOf())// 字符长度是 string 的属性，那改怎么办呢？// 方法1，类型断言function getLength(value: string | number): number &#123; const str = value as string if (str.length) &#123; return str.length &#125; else &#123; const num = value as number return num.toString().length &#125;&#125;// 方法2，类型保护（type guard）function getLength2(value: string | number): number &#123; if (typeof value === &#x27;string&#x27;) &#123; return value.length &#125; else &#123; return value.toString().length &#125;&#125; 枚举（enum）一系列常量 // 枚举成员赋值从0开始递增enum Direction &#123; Up, // 0 Down, // 1 Left, // 2 Right, // 3 custom = 100, // 100 custom1 // 101&#125;console.log(Direction.Up) // 0console.log(Direction[0]) // &#x27;Up// 字符串枚举，常量枚举enum Direction1 &#123; Up = &#x27;UP&#x27;, Down = &#x27;DOWN&#x27;, Left = &#x27;LEFT&#x27;, Right = &#x27;RIGHT&#x27;&#125;const value = &#x27;UP&#x27;if (value === Direction1.Up) &#123; console.log(&#x27;go up&#x27;)&#125; 泛型介绍泛型就是指在定义函数，接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 function echoValue&lt;T&gt;(value: T): T &#123; return value&#125;echoValue(&#x27;str&#x27;)echoValue(2) 替换数组位置function changeArr&lt;T, U&gt;(arr: [T, U]): [U, T] &#123; return [arr[1], arr[0]]&#125;const res = changeArr([1, &#x27;str&#x27;])console.log(res) // [ &#x27;str&#x27;, 1 ] 约束泛型约束为数组function echoWithArr&lt;T&gt;(arr: T[]): number &#123; return arr.length&#125;const res = echoWithArr([1, &#x27;str&#x27;])// const res2 = echoWithArr(&#x27;str&#x27;) // 类型“string”的参数不能赋给类型“unknown[]”的参数console.log(res) // 2 约束为包含 lengthinterface IWithLength &#123; length: number&#125;function echoWithLength&lt;T extends IWithLength&gt; (value: T): number &#123; return value.length&#125;const res1 = echoWithLength([1, &#x27;str&#x27;])const res2 = echoWithLength(&#x27;str&#x27;)const res3 = echoWithLength(&#123; length: 10 &#125;)console.log(res1, res2, res3) // 2 3 10 约束类class Queue&lt;T&gt; &#123; private data: T[] = [] push(item:T) &#123; return this.data.push(item) &#125; pop() &#123; return this.data.shift() &#125;&#125;const queue1 = new Queue&lt;number&gt;()const queue2 = new Queue&lt;string&gt;()queue1.push(1)queue2.push(&#x27;1&#x27;)const res1 = queue1.pop()const res2 = queue2.pop()if (res1) &#123; console.log(res1.toFixed())&#125;if (res2) &#123; console.log(res2.length)&#125; 约束 interfaceinterface IObj&lt;T, U&gt; &#123; key: T value: U&#125;const p1: IObj&lt;string, number&gt; = &#123; key: &#x27;zhangsan&#x27;, value: 18 &#125;const p2: IObj&lt;number, string&gt; = &#123; key: 20, value: &#x27;lisi&#x27; &#125; 约束数组const arr1: number[] = [1, 2, 3, 4, 5]const arr2: Array&lt;number&gt; = [1, 2, 3, 4, 5]const arr3: Array&lt;string&gt; = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;] 类型别名const num1: (a: number, b: number) =&gt; number = (a, b) =&gt; a + btype FunType = (a: number, b: number) =&gt; numberconst num2: FunType = (a, b) =&gt; a + b 字符串字面量const str: &#x27;zhangsan&#x27; = &#x27;zhangsan&#x27;type Directions = &#x27;up&#x27; | &#x27;down&#x27; | &#x27;left&#x27; | &#x27;right&#x27;const toWhere: Directions = &#x27;up&#x27; 交叉类型interface IName &#123; name: string;&#125;type IPerson = IName &amp; &#123; age: number &#125;const user: IPerson = &#123; name: &#x27;张三&#x27;, age: 18 &#125; 技术选型 Vue3 TypeScript ESLint Ant Design Vue Vue Router Vuex 项目生成使用 Imooc CLI 新建项目，视频作者封装的脚手架 不是针对某个前端框架的脚手架，而是一个大而全更加针对业务的脚手架 支持各种模版, 可扩展性 云构建 预发布和正式发布 项目回滚 远程 Git 操作 安装：npm i @imooc-cli/core -g需要依赖 npm：npm i cnpm -g创建项目：imooc-cli init 项目会自动检测，如果在 .vue 文件中检测了 let a = 1，但在 .ts 文件中未检测 可以点击 ESLint 插件的设置按钮，选择它的 setting.json 文件，添加：&quot;eslint.validate&quot;: [&quot;typescript&quot;] ESLint 自动修复错误，方法： 法1：VSCode 快捷键：Ctrl + Shift + P，弹出框中输入ESLint: 选择，ESLint:Fix all auto-fixable Problems 法2：在 ESLint 插件设置中设置保存自动修正，代码：&quot;editor.codeActionsOnSave&quot;: &#123;&quot;source.fixAll.eslint&quot;: true&#125; perttier 格式化代码： VSCode 快捷键：Ctrl + Shift + P，弹出框中输入Format 选择，Format Document（快捷键：Shift + Alt + F） 编写流程 使用 ImoocCli 搭建项目，配置 ESLint、Prettier 通过在 .ts、.vue 文件中添加 let a = 1 来验证 ts 是否可以正常工作 随意修改代码后保存，看 prettier 的保存自动格式化是否生效 安装 Ant-design-vue 编写 首页、拆分模版、单个模板页的整个页面 和 编辑页页面大致结构搭建 安装 Vue-router、编写路由，实现首页logo、首页模板、单个模板等页的跳转逻辑 编写 meta，实现根据 meta 显示不同的页面信息（是否有 header、footer） 法1：路由均为一级路由，使用 meta 的方式来进行判断 法2：将 index 设为一级路由，home 和 templateDetail 页面设置为其的子路由。 安装 Vuex，完成：登录、登出 功能，使用 Module 分割 user 和 template 的数据。 业务组件 LText 编写。业务组件属性和表单组件的显示和实时更新。支持vNode的在 vue template 中显示。","categories":[{"name":"项目流程记录","slug":"项目流程记录","permalink":"http://ran-up.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"项目流程记录","slug":"项目流程记录","permalink":"http://ran-up.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"}]},{"title":"如果视频作者当面试官会问","slug":"前端面试集锦/如果视频作者当面试官会问","date":"2024-12-27T13:10:20.000Z","updated":"2024-12-27T17:43:26.245Z","comments":true,"path":"2024/12/27/前端面试集锦/如果视频作者当面试官会问/","link":"","permalink":"http://ran-up.github.io/2024/12/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/%E5%A6%82%E6%9E%9C%E8%A7%86%E9%A2%91%E4%BD%9C%E8%80%85%E5%BD%93%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BC%9A%E9%97%AE/","excerpt":"","text":"异步什么是单线程，和异步有什么关系 单线程，只有一个线程，同一时间只能做一件事，两段 JS 代码不能同时执行 原因，避免 DOM 渲染的冲突 浏览器需要渲染 DOM JS 可以修改 DOM 结构 JS 执行的时候，浏览器 DOM 渲染会暂停 两段 JS 也不能同时执行（都修改 DOM 就冲突了） webworker 支持多线程，但是不能访问 DOM 解决单线程方法：异步 问题一：没按照书写方式执行，可读性差 问题二：callback 中不容易模块化 什么是 event-loop 事件轮询，JS 实现异步的具体解决方案 同步代码，直接执行 异步函数先放在 异步队列 中 待同步函数执行完毕，轮询执行 异步队列 的函数 是否用过 jQuery 的 DeferredDeferred 延迟 jQuery 1.5 之前// 修改开发扩展封闭const ajax = $.ajax(&#123; url: &#x27;data.js&#x27;, success: () =&gt; &#123; console.log(&#x27;success&#x27;) &#125;, error: () =&gt; &#123; console.log(&#x27;error&#x27;) &#125;&#125;)console.log(ajax) // 返回 XHR 对象// success jQuery 1.5 及之后const ajax = $.ajax(&#x27;data.js&#x27;)ajax.done(() =&gt; console.log(&#x27;success1&#x27;)).fail(() =&gt; console.log(&#x27;error&#x27;)).done(() =&gt; console.log(&#x27;success2&#x27;))console.log(ajax); // 返回 deferred 对象// success1 success2 // 很像 Promise 的写法 -- 扩展开发修改封闭const ajax = $.ajax(&#x27;data.js&#x27;)ajax.then(() =&gt; &#123; console.log(&#x27;success1&#x27;)&#125;, () =&gt; &#123; console.log(&#x27;error1&#x27;)&#125;).then(() =&gt; &#123; console.log(&#x27;success2&#x27;)&#125;, () =&gt; &#123; console.log(&#x27;error2&#x27;)&#125;)console.log(ajax)// success1 success2 jQuery 1.5 的变化 无法改变 JS 异步和单线程的本质 只能从写法上杜绝 callback 这种形式 它只是一种语法糖形式，但是解耦了代码 很好的体现：开放封闭原则 使用 jQuery Deferred不使用const wait = () =&gt; &#123; const task = () =&gt; &#123; console.log(&#x27;task success&#x27;) &#125; setTimeout(task, 2000)&#125;wait() 使用成功 function waitHandler ()&#123; const dtd = $.Deferred() const wait = (dtd) =&gt; &#123; const task = () =&gt; &#123; console.log(&#x27;task success&#x27;) dtd.resolve(&#x27;ok&#x27;) // 成功 // dtd.reject(&#x27;fail&#x27;) // 失败 &#125; setTimeout(task, 2000) return dtd &#125; return wait(dtd)&#125;const w = waitHandler()w.then((res) =&gt; &#123; console.log(res) console.log(&#x27;suc1&#x27;) &#125;, () =&gt; &#123; console.log(&#x27;err1&#x27;)&#125;).then(() =&gt; &#123; console.log(&#x27;suc2&#x27;)&#125;, () =&gt; &#123; console.log(&#x27;err2&#x27;)&#125;)/*task successoksuc1suc2*/ 失败 function waitHandler ()&#123; const dtd = $.Deferred() const wait = (dtd) =&gt; &#123; const task = () =&gt; &#123; console.log(&#x27;task fial&#x27;) // dtd.resolve(&#x27;ok&#x27;) // 成功 dtd.reject(&#x27;fail&#x27;) // 失败 &#125; setTimeout(task, 2000) return dtd &#125; return wait(dtd)&#125;const w = waitHandler()w.then(() =&gt; &#123; console.log(&#x27;suc1&#x27;) &#125;, (err) =&gt; &#123; console.log(err) console.log(&#x27;err1&#x27;)&#125;)w.then(() =&gt; &#123; console.log(&#x27;suc2&#x27;) &#125;, (err) =&gt; &#123; console.log(err) console.log(&#x27;err2&#x27;)&#125;)w.then(() =&gt; &#123; console.log(&#x27;suc3&#x27;) &#125;, (err) =&gt; &#123; console.log(err) console.log(&#x27;err3&#x27;)&#125;)/*task fialfailerr1failerr2failerr3*/ 但在 const w = waitHandler() 可以直接调用 w.reject() 会导致后面的结果出现偏差 function waitHandler ()&#123; const dtd = $.Deferred() const wait = (dtd) =&gt; &#123; const task = () =&gt; &#123; console.log(&#x27;task fial&#x27;) dtd.resolve(&#x27;ok&#x27;) // 成功 // dtd.reject(&#x27;fail&#x27;) // 失败 &#125; setTimeout(task, 2000) return dtd.promise() &#125; return wait(dtd)&#125;const w = waitHandler() // 返回 promise 对象// w.reject() // w.reject is not a functionw.then((res) =&gt; &#123; console.log(res) console.log(&#x27;suc1&#x27;) &#125;, () =&gt; &#123; console.log(&#x27;err1&#x27;)&#125;) Promise 的基本使用和原理加载一张图片function loadImg(src) &#123; return new Promise((resolve, reject) =&gt; &#123; let img = document.createElement(&#x27;img&#x27;) img.src = src img.onload = function () &#123; resolve(img) &#125; img.onerror = function () &#123; reject(new Error(&#x27;图片加载失败&#x27;)) &#125; &#125;)&#125;const img1 = loadImg(&#x27;./allpage.jpg&#x27;)img1.then(img =&gt; &#123; console.log(img) console.log(img.width)&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 加载第一张后再加载第二张function loadImg(src) &#123; return new Promise((resolve, reject) =&gt; &#123; let img = document.createElement(&#x27;img&#x27;) img.src = src img.onload = function () &#123; resolve(img) &#125; img.onerror = function () &#123; reject(new Error(&#x27;图片加载失败&#x27;)) &#125; &#125;)&#125;const img1 = loadImg(&#x27;./allpage.jpg&#x27;)const img2 = loadImg(&#x27;./bird.gif&#x27;) 普通img1.then(img1 =&gt; &#123; console.log(img1) console.log(img1.width) return img2&#125;).then(img2 =&gt; &#123; console.log(img2) console.log(img2.width)&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 使用 Promise.all()Promise.all([img1, img2]).then(res =&gt; &#123; console.log(res[0]) console.log(res[0].width) console.log(res[1]) console.log(res[1].width)&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 使用 await&#x2F;asyncfunction loadImg(src) &#123; return new Promise((resolve, reject) =&gt; &#123; let img = document.createElement(&#x27;img&#x27;) img.src = src img.onload = function () &#123; resolve(img) &#125; img.onerror = function () &#123; reject(new Error(&#x27;图片加载失败&#x27;)) &#125; &#125;)&#125;async function createImg() &#123; let img1 = await loadImg(&#x27;./allpage.jpg&#x27;) let img2 = await loadImg(&#x27;./bird.gif&#x27;) console.log(img1) console.log(img1.width) console.log(img2) console.log(img2.width)&#125;createImg() 介绍一下 async&#x2F;await（和 Promise 的区别、联系） 不是取代 Promise 的，而是对 Promise 的补充 使用了 Promise，并乜有和 Promise 冲突 使用 await，函数必须用 async 标识 await 后面跟的是一个 Promise 实例 完全是同步的写法，再也没有回调函数 但是：改变不了 JS 单线程、异步的本质 总结一下当前 JS 解决异步的方案 jQuery deferred Promise async&#x2F;await Generator 不是异步的直接替代方式 原型说一个原型的实际应用 描述 jquery 如何使用原型 描述 zepto 如何使用原型 结合自己的开发经验，其中使用的原型 原型如何体现它的扩展性 说一下 jquery 和 zepto 的插件机制 结合自己的开发经验，做过的基于原型的插件 vdom、虚拟 dom、virtual dom vdom 是 vue 和 react 的核心 如果面试问道 vue 和 react 和实现，免不了问 vdom vdom 是什么？为何会存在（为何使用） vdom？ 虚拟 DOM 用 JS 模拟 DOM 结构 DOM 变化的对比，放在JS 层来做（图灵完备语言） 提高重绘性能 DOM 操作是“昂贵”的，JS 运行效率高 劲量减少 DOM 操作，而不是“推到重来” 项目越复杂，影响就越复杂 vdom 可以解决 vdom 如何应用，核心 API 是什么 如何使用？可用 snabbdom 库的用法举例 核心 API：h 函数、patch 函数 vdom-snabbdom 使用 vdom 实现的一个库 h(‘&lt;标签名&gt;’, {…属性…}, […子元素…]) –&gt; 有很多子元素 h(‘&lt;标签名&gt;’, {…属性…}, ‘…’) –&gt; 只有一个文本节点的子元素 patch(container, vnode) –&gt; 将 节点 添加到容器中，初次渲染 patch(vnode, newVnode) –&gt; 新旧节点对比，将需改的内容添加，再次渲染 介绍一下 diff 算法 什么是 diff 算法 去繁就简 diff 算法非常复杂，实现难度很大，源码量很大 去繁就简，讲明白核心流程，不关心细节， 2、8原则： 学习的东西太多了，现在不能一行一行的学习，根据目录去查找自己需要补充的重点，然后纤细去看那部分，余下部分过一遍就行。 面试官也大部分不清楚细节，但是很关心核心流程 vdom 为何用 diff 算法 DOM 操作是“昂贵”的，因此劲量减少 DOM 操作 找出本次 DOM 必须更新的节点来更新，其他的不更新 这个“找出”的过程，就需要 diff 算法 vdom 中应用 diff 算法是为了找出需要更新的节点 diff 算法的实现流程 vue看视频、看博客、看文章都属于看源码，并不是非要去看代码才算看源码 说一下使用 jQuery 和使用框架的区别（vue、react）代码演示、使用总结 数据与视图的分离，解耦（开放封闭原则） 以数据驱动视图，只关心数据变化，DOM 操作被封装 说一下对 MVVM 的理解先讲 MVM 再讲 MVVM MVC： Model（数据）、View（视图、界面）、Controller（控制器、逻辑处理） 用户 –&gt; View –&gt; Controller –&gt; Model（View 发生变化出发 Conatroller，Controller 修改 Model，Model 导致 View 更新） 用户 –&gt; Controller –&gt; Model –&gt; View MVVM Model（模型、数据）、View（视图、模板）、ViewModel（桥梁，连接 Model 和 View） 视图和模型是分离的 MVVM 不算一种创新，是在 MVC 上的一种微创新 但其中的 ViewModel 确是一种创新 真正结合前端场景应用的创建 MVVM 框架的三要素响应式：vue 如何监听到 data 的每个属性变化？模板引擎：vue 的模板如何被解析，指令如何处理？渲染：vue 的模板如何被渲染成 html？以及渲染过程vue 中如何实现响应式？ 关键是理解 Object.defineProperty 讲一下 data 的属性代理到 vm 上 什么是响应式？ 修改 data 属性后，vue 立刻监听到 data 属性被代理到 vm 上 Object.defineProperty() 如何使用？在 vue 中如何使用？模拟、演示vue 中如何解析模版？ 模版是什么 模版最终必须转化为 JS 代码，因为： 有逻辑（v-if v-for），必须用 JS 才能实现（图灵完备） 转换为 html 渲染页面，必须用 JS 才能实习 因此，模板后需要转换成一个 JS 函数（render 函数，渲染函数） 模板：字符串，有逻辑，嵌入 JS 变量… 模板必须转换为 JS 代码（有逻辑、渲染 html、JS 变量） with 的用法（劲量不要用，render 函数用到了，会给开发调试带来很大的成本） 读一读《js语言精粹》美国比较牛的js程序员写的，js创始人，有价值，有干货 render 函数 哪里可以看到 render 函数？– 在 vue.js 源码中搜索 render，在 code.render 中可以看到 render 函数是什么样子的？ v-if v-for v-on 都是怎么处理的？ vm._c是什么？render 函数返回了什么？ render 函数执行返回 vnode render 函数与 vdom 如何解析模版 vue 的整个实现流程 解析模板成 render 函数 模板中的所有信息都被 render 函数包含 模板中用到的 data 中的属性，都变成了 JS 变量 模板中的 v-model v-for v-on 都变成了 JS 逻辑 render 函数返回 vnode 响应式开始监听 使用 Object.defineProperty() 将 data 的属性代理到 vm 上 首次渲染，显示页面，且绑定依赖 初次渲染，执行 updateComponent，执行vm._render() 执行 render 函数，会访问到 vm.list 和 vm.title 会被响应式的 get 方法监听到 执行 updateComponent，会走到 vdom 的 patch 方法 patch 将 vnode 渲染成 DOM，初次渲染完成 为何要监听 get，直接监听 set 不行吗？ data 中有很多属性，有些被用到，有些可能不被用到 被用到的会走 get，不被用到的不会走到 get 未走到 get 中的属性，set 的时候我们也无需关心 data 属性变化，触发 rerender 修改属性，被响应式的 set 监听到 set 执行 updateComponent updateComponent 重新执行 vm.render() 生成的 vnode 和 preVnode，通过 patch 进行对比 渲染到 html 中 hybrid","categories":[{"name":"前端面试集锦","slug":"前端面试集锦","permalink":"http://ran-up.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://ran-up.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"杂记.md","slug":"杂记","date":"2024-06-28T13:53:48.000Z","updated":"2024-12-27T17:38:35.768Z","comments":true,"path":"2024/06/28/杂记/","link":"","permalink":"http://ran-up.github.io/2024/06/28/%E6%9D%82%E8%AE%B0/","excerpt":"","text":"new Date().getTime() 和 Date.now() 区别同：这两个方法都是获取当前的时间戳。区别： new Date().getTime() 会先创建一个 Date 对象，之后再调用 getTime() 方法返回当前时间戳。 Date.now() 直接返回当前时间戳，耗时短。","categories":[],"tags":[{"name":"杂糅","slug":"杂糅","permalink":"http://ran-up.github.io/tags/%E6%9D%82%E7%B3%85/"}]},{"title":"ssh: connect to host github.com port 22: Connection timed out","slug":"git相关/ssh-connect-to-host-github-com-port-22-Connection-timed-out","date":"2024-01-18T15:16:21.000Z","updated":"2024-12-27T17:38:35.760Z","comments":true,"path":"2024/01/18/git相关/ssh-connect-to-host-github-com-port-22-Connection-timed-out/","link":"","permalink":"http://ran-up.github.io/2024/01/18/git%E7%9B%B8%E5%85%B3/ssh-connect-to-host-github-com-port-22-Connection-timed-out/","excerpt":"","text":"简介今天 git push 或 git clone 到 github 中总是报：ssh: connect to host github.com port 22: Connection timed out。 找了很久，比如更换为 HTTPS 或 HTTP、重新添加 ssh 文件信息、重新生成 ssh信息，还有什么在 host 文件C:\\Windows\\System32\\drivers\\etc\\hosts中手动配置GitHub域名映射，在文件末尾处增加一行 140.82.113.4 github.com等。 最终明白问题是 22 端口被占用，需要重新建 config 文件来新指定端口，博客：https://blog.csdn.net/qq_46123200/article/details/134392486 我这里把最终的操作写出来，后面自己遇到了方便查找。 解决办法本博客引用的是【fruge】博客的内容，相应博客地址：https://blog.csdn.net/qq_46123200/article/details/134392486。 最终方法： 在文件目录： C:\\Users\\26589\\.ssh 新建 config 文件。 起初创建可以为 config.txt 文件，当把下面的内容复制好后，保存退出，修改文件名，删掉后缀.txt。 这里是将 github 和 gitlab 的连接端口均改为了 443 端口。 ~/.ssh/id_rsa 是你自己的文件路径 Host github.comUser gitHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 Host gitlab.comHostname altssh.gitlab.comUser gitPort 443PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa 若设置有效，测试通过如下：输入ssh -T git@github.com $ ssh -T git@github.comHi DJCKING! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 最后别忘记去 ~/.ssh/id_rsa.pub 中把内容粘贴到 gitee 和 github 的 ssh 中。 新生成 ssh输入：ssh-keygen -t rsa -C &quot;3xxxx73@qq.com&quot; 其中的 “&#x33;&#120;&#x78;&#120;&#x78;&#55;&#51;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;“ 是你在 gitee 或 github 中的邮箱。之后一直回车（Enter）即可。 检测：ssh -v git@github.com、ssh -v git@gitee.com，只要有 successfully 字样就表示成功了。 如果报：ssh: connect to host github.com port 22: Connection timed out 就是上面的解决方案了。","categories":[{"name":"git相关","slug":"git相关","permalink":"http://ran-up.github.io/categories/git%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"git报错","slug":"git报错","permalink":"http://ran-up.github.io/tags/git%E6%8A%A5%E9%94%99/"}]},{"title":"动态修改swiper的slidesPerView属性，自动轮播有问题","slug":"项目bug/使用swiper出现的bug/动态修改swiper的slidesPerView属性，自动轮播有问题","date":"2023-07-05T08:52:21.000Z","updated":"2024-12-27T17:38:35.773Z","comments":true,"path":"2023/07/05/项目bug/使用swiper出现的bug/动态修改swiper的slidesPerView属性，自动轮播有问题/","link":"","permalink":"http://ran-up.github.io/2023/07/05/%E9%A1%B9%E7%9B%AEbug/%E4%BD%BF%E7%94%A8swiper%E5%87%BA%E7%8E%B0%E7%9A%84bug/%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9swiper%E7%9A%84slidesPerView%E5%B1%9E%E6%80%A7%EF%BC%8C%E8%87%AA%E5%8A%A8%E8%BD%AE%E6%92%AD%E6%9C%89%E9%97%AE%E9%A2%98/","excerpt":"","text":"简介我们有个需求，就是需要动态的设置 swiper 中显示的 个数。 本以为直接赋予动态值就可以了，结果修改了之后，自动轮播有些问题。 解决办法 给 swiper 配置中新增两个属性： observer: true, &#x2F;&#x2F; 修改 swiper 自己或子元素时，自动初始化 swiper 默认为 false observeParents: false &#x2F;&#x2F; 修改 swiper 的父元素时，自动初始化 swiper 修改 swiper 配置中的一个属性： slidesPerView: this.judgeInfoData.loopJudgeNumber &#x2F;&#x2F; 让其使用动态数据 最后就是进行动态数据的操作了，在数据进行改变的地方，调用如下的方法(swiper 内置的方法) judgeSwiper.destroy()this._initJudgeSwiper() 解释一下 judgeSwiper: 这是我的swiper名 judgeSwiper.destroy(): 销毁这个 swiper this._initJudgeSwiper(): 重新初始化 swiper 代码&lt;div class=&quot;swiper-container judge-swiper swiper-no-swiping swiper-container-setting&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot; v-for=&quot;(item, index) in judgeDataList&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;judge-box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;// eslint-disable-next-line no-unused-varslet judgeSwiperexport default &#123; methods: &#123; _initJudgeSwiper () &#123; // eslint-disable-next-line no-new judgeSwiper = new Swiper(&#x27;.judge-swiper&#x27;, &#123; loop: true, autoplay: &#123; delay: 2000, disableOnInteraction: false &#125;, speed: 3000, // slidesPerView: 4, slidesPerView: this.judgeInfoData.loopJudgeNumber, spaceBetween: 40, preloadImages: true, observer: true, // 修改 swiper 自己或子元素时，自动初始化 swiper 默认为 false observeParents: false // 修改 swiper 的父元素时，自动初始化 swiper &#125;) &#125;, changeLoopJudgeNumberHandler () &#123; this.$nextTick(() =&gt; &#123; judgeSwiper.destroy() this._initJudgeSwiper() // judgeSwiper.init() // judgeSwiper.params.slidesPerView = this.judgeInfoData.loopJudgeNumber // judgeSwiper.update() &#125;) &#125;, &#125;&#125;","categories":[{"name":"使用swiper出现的bug","slug":"使用swiper出现的bug","permalink":"http://ran-up.github.io/categories/%E4%BD%BF%E7%94%A8swiper%E5%87%BA%E7%8E%B0%E7%9A%84bug/"}],"tags":[{"name":"项目bug","slug":"项目bug","permalink":"http://ran-up.github.io/tags/%E9%A1%B9%E7%9B%AEbug/"}]},{"title":"不同tab切换，内部的swiper自动轮播失效","slug":"项目bug/使用swiper出现的bug/不同tab切换，内部的swiper自动轮播失效","date":"2023-07-05T08:12:52.000Z","updated":"2024-12-27T17:38:35.773Z","comments":true,"path":"2023/07/05/项目bug/使用swiper出现的bug/不同tab切换，内部的swiper自动轮播失效/","link":"","permalink":"http://ran-up.github.io/2023/07/05/%E9%A1%B9%E7%9B%AEbug/%E4%BD%BF%E7%94%A8swiper%E5%87%BA%E7%8E%B0%E7%9A%84bug/%E4%B8%8D%E5%90%8Ctab%E5%88%87%E6%8D%A2%EF%BC%8C%E5%86%85%E9%83%A8%E7%9A%84swiper%E8%87%AA%E5%8A%A8%E8%BD%AE%E6%92%AD%E5%A4%B1%E6%95%88/","excerpt":"","text":"简介我们有个需求，就是不同功能中都有轮播，然后使用的是 swiper。 也就是切换 tab 标签，内部的 swiper 变开始自动轮播。 现在遇到的问题是：初始进来的那个 tab 的 swiper 能自动轮播，但切换了 tab 就不能轮播了。 解决方法然后我就查询度娘，找到了一个博客，里面大致说的就是，切换了 tab，让每个 swiper 的父盒子(这个 tab 盒子添加了一个 display: “none”) 所以就造成了：swiper 轮播失效。 然后他说的就是，每次切换回来的时候重新初始化 swiper 所以，我的方案是：每次切换 tab 时，通过全局事件总线，来让子组件重新调用函数进行 swiper 的初始化。 代码swiper 部分代码&lt;div class=&quot;swiper-container judge-swiper swiper-no-swiping swiper-container-setting&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot; v-for=&quot;(item, index) in judgeDataList&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;judge-box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 以前的代码// eslint-disable-next-line no-unused-varslet judgeSwiperexport default &#123; methods: &#123; _initJudgeSwiper () &#123; // eslint-disable-next-line no-new judgeSwiper = new Swiper(&#x27;.judge-swiper&#x27;, &#123; loop: true, autoplay: &#123; delay: 2000, disableOnInteraction: false &#125;, speed: 3000, slidesPerView: 4, spaceBetween: 40, preloadImages: true, observer: true, // 修改 swiper 自己或子元素时，自动初始化 swiper 默认为 false observeParents: false // 修改 swiper 的父元素时，自动初始化 swiper &#125;) &#125;, &#125;, activated () &#123; setTimeout(() =&gt; &#123; this._initJudgeSwiper() &#125;, 2000) &#125;&#125; 修改后的代码父组件 &lt;el-tabs v-model=&quot;defaultTab&quot; style=&quot;margin-top: -15px&quot; class=&quot;content-wrapper&quot; @tab-click=&quot;tabClickHandle&quot;&gt; &lt;el-tab-pane label=&quot;评委介绍页&quot; name=&quot;judgeShow&quot;&gt; &lt;keep-alive&gt;&lt;ScreenJudgeShow @_submitJudgeData=&quot;_submitJudgeData&quot; :judgeData=&quot;subcomponentData.judgeData&quot;&gt;&lt;/ScreenJudgeShow&gt;&lt;/keep-alive&gt; &lt;/el-tabs&gt;&lt;/el-tab-pane&gt;methods: &#123; tabClickHandle (tab, event) &#123; // 当点击了这个 tab 后就告诉对应子组件: 我被点击了，你快点初始化 swiper 组件，让它动起来 this.$bus.$emit(&#x27;initJudgeSwiper&#x27;) &#125;&#125; 解释一下： @tab-click=&quot;tabClickHandle&quot;: 父子组件之间的 $emit 通信(本次讲解的通信，使用的是事件委托，本来的 tab 标签较多，这里未展示完全) @_submitJudgeData=&quot;_submitJudgeData&quot;: 父子组件之间的 $emit 通信(这个是另一个的通信，这里可以不管) :judgeData=&quot;subcomponentData.judgeData&quot;: 父子组件之间的 props 通信 子组件 // eslint-disable-next-line no-unused-varslet judgeSwiperexport default &#123; methods: &#123; _initJudgeSwiper () &#123; // eslint-disable-next-line no-new judgeSwiper = new Swiper(&#x27;.judge-swiper&#x27;, &#123; loop: true, autoplay: &#123; delay: 2000, disableOnInteraction: false &#125;, speed: 3000, slidesPerView: 4, spaceBetween: 40, preloadImages: true, observer: true, // 修改 swiper 自己或子元素时，自动初始化 swiper 默认为 false observeParents: false // 修改 swiper 的父元素时，自动初始化 swiper &#125;) &#125;, &#125;, activated () &#123; this.$nextTick(() =&gt; &#123; // 收到父组件传递的消息(我被点击了，你快点初始化 swiper 组件，让它动起来)，开始对 swiper 进行初始化 this.$bus.$on(&#x27;initJudgeSwiper&#x27;, this._initJudgeSwiper) &#125;) &#125;&#125;","categories":[{"name":"使用swiper出现的bug","slug":"使用swiper出现的bug","permalink":"http://ran-up.github.io/categories/%E4%BD%BF%E7%94%A8swiper%E5%87%BA%E7%8E%B0%E7%9A%84bug/"}],"tags":[{"name":"项目bug","slug":"项目bug","permalink":"http://ran-up.github.io/tags/%E9%A1%B9%E7%9B%AEbug/"}]},{"title":"JavaScript题","slug":"前端面试集锦/JavaScript题","date":"2023-05-30T12:31:03.000Z","updated":"2024-12-27T17:38:35.764Z","comments":true,"path":"2023/05/30/前端面试集锦/JavaScript题/","link":"","permalink":"http://ran-up.github.io/2023/05/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/JavaScript%E9%A2%98/","excerpt":"","text":"一道关于 Promise 的面试题要求： 使用以下代码实现：首先输出 1，等待 3 秒后才输出 3 console.log(1)await delay(3000)console.log(3) async function fn() &#123; console.log(1) await delay(3000) console.log(3)&#125;fn() function delay(time) &#123; if (typeof time !== &#x27;number&#x27;) &#123; throw new Error(&#x27;请输入数值类型&#x27;) &#125; return new Promise(resolve =&gt; &#123; setTimeout(resolve, time) &#125;)&#125; 输出结果var a = 0, b = 0function A(a) &#123; A = function (b) &#123; console.log(a + b++) &#125; console.log(a++)&#125;A(1)A(2) 1 4 输出结果let a = &#123;&#125;, b = &#x27;0&#x27;, c = 0a[b] = &#x27;唐诗&#x27;a[c] = &#x27;宋词&#x27;console.log(a[b]) 宋词 js对象中的key通常是字符串或Symbol类型。使用其他类型作为键，js会自动转换为字符串或Symbol。 输出结果let a = &#123;&#125;, b = Symbol(&#x27;1&#x27;), c = Symbol(&#x27;1&#x27;)a[b] = &#x27;唐诗&#x27;a[c] = &#x27;宋词&#x27;console.log(a[b]) 唐诗 Symbol是唯一的。 输出结果let a = &#123;&#125;, b = &#123; n: &#x27;1&#x27; &#125;, c = &#123; m: &#x27;2&#x27; &#125;a[b] = &#x27;唐诗&#x27;a[c] = &#x27;宋词&#x27;console.log(a[b]) 宋词 对象作为key时会调用toString()转换为字符串，最终为：[object Object]。 var test = (function (i) &#123; return function () &#123; alert((i *= 2)) &#125;&#125;)(2)test(5) 弹出框中显示4，注意alert只会输出字符串类型，所以准确回答是：字符串4。 test函数是立即执行函数，返回一个函数，其中的内容为：alert(4)。 调用test(5)，其实5没有用，立即函数中的i是后面调用的2，所以test(5)传递的参数无效。 输出结果console.log(1)const promise = new Promise((resolve, reject) =&gt; &#123; console.log(2) setTimeout(() =&gt; &#123; resolve(3) reject(4) &#125;, 0)&#125;)promise .then(data =&gt; &#123; console.log(data) &#125;) .catch(error =&gt; &#123; console.log(error) &#125;)console.log(5) 1 2 5 3 console.log(1)，输出 1。 const promise = new Promise((resolve, reject) => {...}), 创建一个 Promise。 console.log(2)，输出 2。 setTimeout(() => {...}, 0)，添加到宏任务队列中。 promise.then((data) => {...}).catch((error) => {...})，添加到微任务队列中。 console.log(5)，输出 5。 setTimeout 内部的代码执行，输出 6。 resolve(3)：Promise 被解决，传递了数据 3。 reject(4)：这行代码不会被执行，因为 Promise 已经被解决了。 输出结果for (i = 0; i &lt; 3; i++) &#123; setTimeout(() =&gt; console.log(++i), 0)&#125; 4 5 6 输出结果var fullname = &#x27;a&#x27;var obj = &#123; fullname: &#x27;b&#x27;, prop: &#123; fullname: &#x27;c&#x27;, getFullname: () =&gt; &#123; return this.fullname &#125; &#125;&#125;console.log(obj.prop.getFullname())var test = obj.prop.getFullnameconsole.log(test()) a a 写一个函数根据参数输出对应的棱形 function createDiamondByParam(count) &#123; if (!(count - 1)) &#123; return console.log(&#x27;*&#x27;); &#125; // 输出上面部分 const rows = 2 * count - 1 for (let i = 1; i &lt; rows; i += 2) &#123; const num = (rows - i) / 2 console.log(&#x27; &#x27;.repeat(num) + &#x27;*&#x27;.repeat(i)); &#125; // 输出下面部分 for (let i = rows; i &gt; 0; i -= 2) &#123; const num = (rows - i) / 2 console.log(&#x27; &#x27;.repeat(num) + &#x27;*&#x27;.repeat(i)); &#125;&#125;createDiamondByParam(3)","categories":[{"name":"前端面试集锦","slug":"前端面试集锦","permalink":"http://ran-up.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/tags/JavaScript/"}]},{"title":"axios知识点回顾","slug":"AJAX-axios/axios知识点回顾","date":"2023-05-14T20:35:27.000Z","updated":"2024-12-27T17:38:35.753Z","comments":true,"path":"2023/05/15/AJAX-axios/axios知识点回顾/","link":"","permalink":"http://ran-up.github.io/2023/05/15/AJAX-axios/axios%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/","excerpt":"","text":"建议我这里只是列出了一些简单的知识点，方便我的记忆回顾。 建议看 sass 官方文档，里面的内容更加详细和完善，内容也是最新的，网址：https://www.axios-http.cn/docs/intro。 安装使用 npm：$ npm install axios 使用 cdn：&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;（可以在 https://www.bootcdn.cn/ 网站去获取 cdn） 使用 bower：$ bower install axios 使用 yarn：yarn add axios 引入 axios为了在CommonJS中使用 require（） 导入时获得TypeScript类型推断（智能感知&#x2F;自动完成），请使用以下方法： const axios = require(&#x27;axios&#x27;).default axios.&lt;method&gt; 能够提供自动完成和参数类型推断功能 GET 请求GET 请求的参数可以跟在 url 后面，如：?name=&#39;张三&#39;&amp;age=18 。也可以放在第二个参数位，使用 params 请求体，以键值对的形式进行请求。 // 为给定 ID 的 user 创建请求axios.get(&#x27;/user?ID=12345&#x27;)axios.get(&#x27;/user&#x27;, &#123; params: &#123; ID: 12345 &#125;&#125;) axios.get().then().catch()// 支持async/await用法async function getUser() &#123; // 抛出异常 try &#123; const response = await axios.get(&#x27;/user?ID=12345&#x27;) &#125; catch (err) &#123; console.error(err) &#125;&#125; POST 请求POST 请求只能在第二个参数位，以键值对的形式进行请求。 axios.post(&#x27;/user&#x27;, &#123;&#125;).then().catch() 执行多个并发请求function getUserAccount() &#123; return axios.get(&#x27;/user/12345&#x27;)&#125;function getUserPermissions() &#123; return axios.get(&#x27;/user/12345/permissions&#x27;)&#125;axios.all([getUserAccount(), getUserPermissions()]).then() axios API可以通过向 axios 传递相关配置来创建请求 **语法**：axios(config) （config：配置对象） **语法**：axios(url[, config])（默认是发送 GET 请求） // 发送 POST 请求axios(&#123; // 请求类型 method: &#x27;post&#x27;, // URL url: &#x27;/user/12345&#x27;, // 请求体 data: &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;&#125;).then()// 发送 GET 请求（获取远端图片）axios(&#123; method:&#x27;get&#x27;, url:&#x27;http://bit.ly/2mTM3nY&#x27;, responseType:&#x27;stream&#x27;&#125;).then() 并发处理并发请求的函数 axios.all(iterable) axios.spread(callback) 建实例对象可以使用自定义配置新建一个 axios 实例。axios.create([config]) 语法： // 创建一个实例对象 testconst test = axios.create(&#123; // 基础 url baseURL: &#x27;http://127.0.0.1:8000&#x27;, // 超时时间 timeout: 1000, // 携带的请求头 headers: &#123;&#x27;X-Custom-Header&#x27;: &#x27;foobar&#x27;&#125;&#125;);// 这里的 test 与 axios 对象的功能类似// 使用创建的实例对象test(&#123; url: &#x27;/server&#x27; &#125;).then()// 与上面的使用效果一样test.get(&#x27;/server&#x27;).then() 实例方法： axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.options(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 注意：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 // axios.request(config)axios.request(&#123; method: &#x27;GET&#x27;, url: &#x27;&#x27;&#125;).then()// axios.post(url[, data[, config]])axios.post(&#x27;url&#x27;,&#123;&#125;).then() 请求配置这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 GET 方法。 &#123; url: &#x27;/user&#x27;, method: &#x27;get&#x27;, // 默认值 // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 baseURL: &#x27;https://some-domain.com/api/&#x27;, // 自定义请求头 headers: &#123;&#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;&#125;, // `timeout` 指定请求超时的毫秒数。 timeout: 1000, // 默认值是 `0` (永不超时) // `params` 是与请求一起发送的 URL 参数 params: &#123; ID: 12345 &#125;, // `data` 是作为请求体被发送的数据 // 仅适用 &#x27;PUT&#x27;, &#x27;POST&#x27;, &#x27;DELETE 和 &#x27;PATCH&#x27; 请求方法 data: &#123; firstName: &#x27;Fred&#x27; &#125;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 它只能用于 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法 // 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream // 你可以修改请求头。 transformRequest: [function (data, headers) &#123; // 对发送的 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对接收的 data 进行任意转换处理 return data; &#125;], // `auth` HTTP Basic Auth auth: &#123; username: &#x27;janedoe&#x27;, password: &#x27;s00pers3cret&#x27; &#125;, // 选项包括: &#x27;arraybuffer&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27; // 浏览器专属：&#x27;blob&#x27; responseType: &#x27;json&#x27;, // 表示浏览器将要响应的数据类型，默认值为json // `onUploadProgress` 允许为上传处理进度事件 // 浏览器专属 onUploadProgress: function (progressEvent) &#123; // 处理原生进度事件 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 // 浏览器专属 onDownloadProgress: function (progressEvent) &#123; // 处理原生进度事件 &#125;, // `proxy` 定义了代理服务器的主机名，端口和协议。 proxy: &#123; // 代理服务器使用 HTTPS，则必须设置 protocol 为`https` protocol: &#x27;https&#x27;, host: &#x27;127.0.0.1&#x27;, port: 9000, auth: &#123; username: &#x27;mikeymike&#x27;, password: &#x27;rapunz3l&#x27; &#125; &#125;,&#125; 响应结构服务器返回的响应信息： &#123; data: &#123;&#125;, status: 200, statusText: &#x27;OK&#x27;, // `headers` 是服务器响应头 // 所有的 header 名称都是小写，而且可以使用方括号语法访问 // 例如: `response.headers[&#x27;content-type&#x27;]` headers: &#123;&#125;, // `config` 是 `axios` 请求的配置信息 config: &#123;&#125;, // `request` 是生成此响应的请求 request: &#123;&#125;&#125; 当使用 then 时，您将接收如下响应: axios.get(&#x27;/user/12345&#x27;) .then(function (response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;) 默认配置全局 axios 默认配置： // 请求基础urlaxios.defaults.baseURL = &#x27;https://api.example.com&#x27;;// 请求头设置axios.defaults.headers.common[&#x27;Authorization&#x27;] = AUTH_TOKEN;axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27;; 自定义实例默认值： // 创建实例时配置默认值const instance = axios.create(&#123; baseURL: &#x27;https://api.example.com&#x27;&#125;);// 创建实例后修改默认值instance.defaults.headers.common[&#x27;Authorization&#x27;] = AUTH_TOKEN; // 原请求方式axios(&#123; method:&#x27;GET&#x27;, url:&#x27;http://127.0.0.1:8000/server&#x27;, data:&#123; xxx &#125;).then()// 现请求方式// 设置默认的请求方式为 GETaxios.default.method = &#x27;GET&#x27;// 设置默认的请求路径axios.default.baseURL = &#x27;http://127.0.0.1:8000&#x27;// 设置默认的请求 url 参数axios.default.params = &#123;id:100&#125;// 设置默认的超时时间axios.default.timeout = 3000 拦截器在请求或响应被 then 或 catch 处理前拦截它们。 // 设置请求拦截器// config 配置对象axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 // 可以修改 config 中的参数 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 设置响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;) 如果你想在稍后移除拦截器，可以这样： const myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 const instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;);","categories":[{"name":"AJAX-axios","slug":"AJAX-axios","permalink":"http://ran-up.github.io/categories/AJAX-axios/"}],"tags":[{"name":"AJAX-axios","slug":"AJAX-axios","permalink":"http://ran-up.github.io/tags/AJAX-axios/"}]},{"title":"git知识点","slug":"git相关/git知识点","date":"2023-05-13T15:05:40.000Z","updated":"2024-12-27T18:01:10.561Z","comments":true,"path":"2023/05/13/git相关/git知识点/","link":"","permalink":"http://ran-up.github.io/2023/05/13/git%E7%9B%B8%E5%85%B3/git%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"初始化设置用户名和邮箱git config --global --list git config --global user.name &quot;xxx&quot; git config --global user.email &quot;xxx&quot; 克隆现有的仓库git clone &lt;url&gt; 如果我们想获得一份已经存在仓库，那么我们可以使用 git clone &lt;url&gt;。（url 项目路径）比如：git clone https://github.com/libgit2/libgit2 如果我们想在克隆远程仓库时，自定义自己的本地仓库名，那么我们可以设置参数来指定新的目录名。就比如我们想将克隆的仓库放到 mylibgit 目录中： git clone https://github.com/libgit2/libgit2 mylibgit 初始化仓库git init &lt;project-name&gt; project-name 为初始化目录名称，不设置则在当前目录创建 当我们将目录切换到当前项目目录之后，使用 git init 对仓库进行初始化。 检查当前文件状态 git status git status -s 输出简洁信息 我们可以用 git status 命令查看文件分别哪些状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出： $ git statusOn branch masterYour branch is up-to-date with &#x27;origin/master&#x27;.nothing to commit, working directory clean 这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是“master”，这是默认的分支名。 跟踪新文件（添加）git add &lt;file&gt; file 文件名，添加一个文件到仓库 git add . 添加所有文件到仓库 git add &lt;file&gt; 跟踪新文件、把已跟踪的文件放到暂存区域、用于合并时把有冲突的文件标记为已解决状态等。 当然当我们运行了 git add 命令之后，又对文件进行了修改的话，那么就需要重新运行 git add ，把现在最新的版本重新暂存起来。 提交更新（将暂存区提交到版本库） git commit -m &lt;message&gt; 提交暂存区的文件到仓库 git commit -am &lt;message&gt; 提交暂存区所有的文件到仓库 现在的暂存区已经准备就绪，可以提交了。 在此之前，请务必确认还有什么已修改或新建的文件还没有 git add 过， 否则提交的时候不会记录这些尚未暂存的变化。 这些已修改但未暂存的文件只会保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 git commit。也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行：git commit –m &quot;描述&quot;。 提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较 跳过使用暂存区域 尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：git commit -a 回顾提交历史git log 命令回顾提交历史 分支创建分支：git branch &lt;branch-name&gt; branch-name 分支名 切换分支：git checkout &lt;branch-name&gt; 合并分支：git merge &lt;branch-name&gt; 删除分支：git branch -d &lt;branch-name&gt; 强制删除分：git branch -D &lt;branch-name&gt; 打标签：git tag &lt;tag-name&gt; 给当前的提交打上标签，通常用于版本发布 查看分支列表：git branch 查看分支指向的最新的提交：git branch -v 查看合并到当前分支的分支列表：git branch --merged 查看没有合并到当前分支的分支列表: git branch --no-merged 在指定的提交对象上创建新分支：git branch 文件名 commithash 查看每一个分支的最后一次提交：git branch -v 撤销移动一个文件到新位置：git mv &lt;file&gt; &lt;new-file&gt; 从工作区和暂存区删除一个文件，然后暂存删除操作：git rm &lt;file&gt; 只从暂存区删除一个文件，工作区中的文件没有变化：git rm --cached &lt;file&gt; 恢复一个文件到之前的版本：git checkout &lt;file&gt; &lt;commit-id&gt; 创建一个新的提交，用来撤销指定的提交，后者的所有变化都会被前者抵消，并且应用到当前分支：git revert &lt;commit-id&gt; 撤销暂存区的文件，重新放回工作区（git add 的反向操作）：git restore --staged &lt;file&gt; 查看查看未暂存的修改：git diff 查看未提交的暂存：git diff --cache 查看提交记录（–oneline可以省略）：git log --oneline 查看两个提交之间的差异：git diff &lt;commit-id&gt; &lt;commit-id&gt; 远程仓库添加：git remote add &lt;remote-name&gt; &lt;remote-url&gt; 查看：git remote -v 删除：git remote rm &lt;remote-name&gt; 重命名：git remote rename &lt;old-name&gt; &lt;new-name&gt; 拉取代码：git pull &lt;remote-name&gt; &lt;branch-name&gt; 推送代码：git push 查看远程分支：git branch -r 获取所有远程分支：git fetch &lt;remote-name&gt; fetch某一个特定的远程分支：git fetch &lt;remote-name&gt; &lt;branch-name&gt; 其他删除：git rm 要删除的文件 重命名：git mv 老文件 新文件 推送：git push 别名 分支 拉取：git pull 查看项目分叉历史git log –oneline –decorate –graph –all 给命令设置一个别名git config --global alias.别名 命令 如果命令是单个则不需用加引号，如果命令很长有空格就需要加引号，比如查看项目分支历史这个命令就需要加引号包裹起来。 遇到了本地未同步远程仓库的情况时比如，终端出现这种提示： 我们应该这样做： git stash – 保存自己的代码 git pull origin dev – 拉取代码（dev 是远程仓库的名字） git stash pop – 恢复自己的代码 因为上面的错误是我们将代码提交到本地仓库后，准备提交到远程仓库去才会报的错。 所以在进行 git stash 和 git stash pop 时，会显示：No local changes to save。 也就是说本地已经提交了，就直接pull就行，本地没有提交，又想拉取最新代码，就stash保存。 修改最新的commit文字命令：git commit –amend 以下是使用：phpstorm 软件的操作，其他软件应该类似: 按下 i 进入 vim 编辑器，编辑完成，按下 alt + enter 退出 vim 编辑效果，输入 :wq 保存。 回退版本git reset --hard &#39;版本commit id&#39; 直接去仓库复制要回退版本的提交 id 就可以了。 再次提交需要强制推送git push -f","categories":[{"name":"git相关","slug":"git相关","permalink":"http://ran-up.github.io/categories/git%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"git","slug":"git","permalink":"http://ran-up.github.io/tags/git/"}]},{"title":"继承的方式","slug":"JavaScript/继承的方式","date":"2023-05-10T14:52:49.000Z","updated":"2024-12-27T17:38:35.758Z","comments":true,"path":"2023/05/10/JavaScript/继承的方式/","link":"","permalink":"http://ran-up.github.io/2023/05/10/JavaScript/%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"原型链继承子类的原型指向父类的一个实例。 function Parent(age) &#123; this.name = &#x27;parent&#x27; this.isShow = true this.colors = [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;] this.age = age&#125;Parent.prototype.getInfo = function () &#123; console.log(this.name, this.isShow, this.colors, this.age)&#125;function Child(age) &#123; &#125;// 核心代码，创建 Parent 的实例，并将该实例赋值给S Child.prototypeChild.prototype = new Parent()const children1 = new Child(18)children1.name = &#x27;newName&#x27;children1.isShow = falsechildren1.colors.push(&#x27;black&#x27;)children1.getInfo() // newName false [ &#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;black&#x27; ] undefinedconst children2 = new Child(20)children2.getInfo() // parent true [ &#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;black&#x27; ] undefined 优点：父类方法可以复用 缺点： 父类中的引用类型属性会被篡改。 子类实例不能给父类构造函数传参。 借用构造函数继承使用 call() 和 apply() 方法，在子类构造函数中调用父类构造函数。 function Parent(age) &#123; this.name = &#x27;parent&#x27; this.isShow = true this.colors = [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;] this.age = age this.say = () =&gt; &#123; console.log(this.name + &#x27; 说了你好！&#x27;) &#125;&#125;function Child(age) &#123; // 核心代码 Parent.call(this, age)&#125;const children1 = new Child(18)children1.name = &#x27;newName&#x27;children1.isShow = falsechildren1.colors.push(&#x27;black&#x27;)children1.say() // newName 说了你好！console.log(children1.name, children1.isShow, children1.age, children1.colors) // newName false 18 [ &#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;black&#x27; ]const children2 = new Child(20)children1.say() // newName 说了你好！console.log(children2.name, children2.isShow, children2.age, children2.colors) // parent true 20 [ &#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27; ] 优点： 父类中的引用类型属性不会被篡改。 子类实例可以给父类构造函数传参。 缺点： 不能复用，每个子类都有父类实例的副本，影响性能。 只能继承父类实例的 属性和方法，不能继承原型上的属性和方法，因此所有方法都写在构造函数中，每次创建实例都会初始化。 组合继承组合继承综合了 原型链继承 和 构造函数继承，将两者的优点结合了起来。 基本的思路：使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性，这样既可以把方法定义在原型上以实现复用，还能让属性不被共享。 function Parent(age) &#123; this.name = &#x27;parent&#x27; this.isShow = true this.colors = [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;] this.age = age this.say = () =&gt; &#123; console.log(this.name + &#x27; 说了你好！&#x27;) &#125;&#125;Parent.prototype.getInfo = function () &#123; console.log(this.name, this.isShow, this.age, this.colors)&#125;function Child(age) &#123; // 核心代码，继承父类属性 Parent.call(this, age)&#125;// 核心代码，继承父类的方法Child.prototype = new Parent()// 核心代码，重写 Child.prototype 的 constructor 属性，指向自己的构造函数 ChildChild.prototype.constructor = Childconst children1 = new Child(18)children1.name = &#x27;newName&#x27;children1.isShow = falsechildren1.colors.push(&#x27;black&#x27;)children1.getInfo() // newName false 18 [ &#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;black&#x27; ]const children2 = new Child(20)children2.getInfo() // parent true 20 [ &#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27; ] 优点： 父类方法可以复用 父类中的引用类型属性不会被篡改。 子类实例可以给父类构造函数传参。 原型式继承利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。 function object(obj) &#123; function F() &#123; &#125; F.prototype = obj return new F()&#125; object()对传入其中的对象执行了一次 浅复制，将构造函数 F 的原型直接指向传入的对象。 function object(obj) &#123; function F() &#123; &#125; F.prototype = obj return new F()&#125;const obj = &#123; name: &#x27;张三&#x27;, colors: [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;], say() &#123; console.log(this.name + &#x27; 说了你好！&#x27; + &#x27;颜色有：&#x27; + this.colors) &#125;&#125;const obj1 = object(obj)obj1.name = &#x27;newName&#x27;obj1.colors.push(&#x27;black&#x27;)obj1.say() // newName 说了你好！颜色有：red,pink,blue,blackconst obj2 = object(obj)obj2.say() // 张三 说了你好！颜色有：red,pink,blue,black 优点：父类方法可以复用 缺点： 父类中的引用类型属性会被篡改。 子类实例不能给父类构造函数传参。 ES5 中存在 Object.create() 的方法，能够代替上面的object方法。 const obj = &#123; name: &#x27;张三&#x27;, colors: [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;], say() &#123; console.log(this.name + &#x27; 说了你好！&#x27; + &#x27;颜色有：&#x27; + this.colors) &#125;&#125;const obj1 = Object.create(obj)obj1.name = &#x27;newName&#x27;obj1.colors.push(&#x27;black&#x27;)obj1.say() // newName 说了你好！颜色有：red,pink,blue,blackconst obj2 = Object.create(obj)obj2.say() // 张三 说了你好！颜色有：red,pink,blue,black 寄生式继承使用原型式继承对一个目标对象进行浅复制，增强这个浅复制的能力，返回构造函数。 function object(obj) &#123; function F() &#123; &#125; F.prototype = obj return new F()&#125;function createAnother(original) &#123; const clone = object(original) // 通过调用 object() 函数创建一个新对象 clone.getName = function () &#123; // 以某种方式来增强对象 console.log(this.name) &#125; return clone // 返回这个对象&#125;const obj = &#123; name: &#x27;张三&#x27;, colors: [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;], say() &#123; console.log(this.name + &#x27; 说了你好！&#x27; + &#x27;颜色有：&#x27; + this.colors) &#125;&#125;const obj1 = createAnother(obj)obj1.name = &#x27;newName&#x27;obj1.colors.push(&#x27;black&#x27;)obj1.say() // newName 说了你好！颜色有：red,pink,blue,blackobj1.getName() // newNameconst obj2 = createAnother(obj)obj2.say() // 张三 说了你好！颜色有：red,pink,blue,blackobj2.getName() // 张三 优点：父类方法可以复用 缺点： 父类中的引用类型属性会被篡改。 子类实例不能给父类构造函数传参。 寄生组合式继承组合继承综合了 构造函数传递参数 和 寄生模式 实现继承。 寄生式组合继承可以算是引用类型继承的最佳模式，是最成熟的方法，也是现在库实现的方法。 function object(obj) &#123; function F() &#123; &#125; F.prototype = obj return new F()&#125;function inheritPrototype(child, parent) &#123; const prototype = object(parent.prototype) prototype.constructor = child Child.prototype = prototype&#125;function Parent(age) &#123; this.isShow = true this.name = &#x27;parent&#x27; this.colors = [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;] this.age = age this.say = () =&gt; &#123; console.log(this.name + &#x27; 说了你好！&#x27;) &#125;&#125;Parent.prototype.getInfo = function () &#123; console.log(this.name, this.isShow, this.colors, this.age)&#125;function Child(age) &#123; // 核心代码 Parent.call(this, age)&#125;inheritPrototype(Child, Parent)const child1 = new Child(18)child1.name = &#x27;newName&#x27;child1.colors.push(&#x27;black&#x27;)child1.say() // newName 说了你好！child1.getInfo() // newName true [ &#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;black&#x27; ] 18const child2 = new Child(20)child2.say() // parent 说了你好child2.getInfo() // parent true [ &#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27; ] 20 ES6类继承extendsclass Parent &#123; constructor(age) &#123; this.name = &#x27;张三&#x27; this.age = age this.colors = [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;] &#125; getInfo() &#123; console.log(this.name, this.age, this.colors) &#125;&#125;class Child extends Parent &#123; constructor(age) &#123; super(age) &#125;&#125;const child = new Child(18)child.getInfo() // 张三 18 [ &#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27; ]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/tags/JavaScript/"}]},{"title":"this指向问题讲解","slug":"JavaScript/this指向问题讲解","date":"2023-05-10T14:27:04.000Z","updated":"2024-12-27T17:38:35.756Z","comments":true,"path":"2023/05/10/JavaScript/this指向问题讲解/","link":"","permalink":"http://ran-up.github.io/2023/05/10/JavaScript/this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%E8%AE%B2%E8%A7%A3/","excerpt":"","text":"牢记一点this 永远指向最终调用它的对象 当然这话的前提条件是：不能是箭头函数。箭头函数没有 this、argument等。 实战训练简单例1function example() &#123; const test = &#x27;hahaha&#x27; console.log(this.test) // undefined console.log(this) // Window&#125;example(); 这里调用 example() 实际上就是 window.example() ，我们通常将 window 进行省略。 符合 this 永远指向最终调用它的对象 这个概念。 例2const person = &#123; name: &quot;张三&quot;, say: function () &#123; console.log(this.name) // 张三 &#125;&#125;person.say() 同上，这里实际上是 window.person.say()，我们通常将 window 进行省略。 最后调用的是 person ，所以 this 指向的是 person 对象，输出 张三。 符合 this 永远指向最终调用它的对象 这个概念。 例3const example = &#123; a: 10, b: &#123; a: 12, fn: function () &#123; console.log(this.a) &#125; &#125;&#125;example.b.fn() // 12 同上，这里实际上是 window.example.b.fn()，我们通常将 window 进行省略。 最后调用的是 b ，所以 this 指向的是 b 对象，输出 12。 符合 this 永远指向最终调用它的对象 这个概念。 中等例1const example = &#123; a: 10, b: &#123; // a: 12, fn: function () &#123; console.log(this.a) &#125; &#125;&#125;example.b.fn() // undefined 这个和【简单】中的【例3】有一点细微的区别，但这一个细微的区别却导致了不同的结果。 原理很简单，最后调用的是 b ，所以 this 指向的是 b 对象，但是 b 中并没有想要的属性，所以输出 undefined。 符合 this 永远指向最终调用它的对象 这个概念。 注意：即使 example 对象中拥有属性 a ，但是在 b 对象中它是访问不到的。不要用之前的局部函数能访问到外部属性的理解，这里处在的环境不一样。 例2const example = &#123; a: 10, b: &#123; a: 12, fn: function () &#123; console.log(this.a) &#125; &#125;&#125;const result = example.b.fnresult() // undefined 这里我们用了一个新属性来接收 example.b.fn ，然后对新属性进行了调用，这时候其实是 window.result() ，最终调用的是 window，所以输出了 undefined。 符合 this 永远指向最终调用它的对象 这个概念。 困难（函数有 return 返回值）function Example() &#123; this.name = &quot;张三&quot; return &#123;&#125;&#125;const result = new Example()console.log(result.name) // undefined function Example() &#123; this.name = &quot;张三&quot; return &#123; hh: &#x27;hh&#x27; &#125;&#125;const result = new Example()console.log(result.name) // undefined 如果返回值是一个对象，那么 this 指向的就是那个返回的对象。 function Example() &#123; this.name = &quot;张三&quot; return function () &#123; &#125;&#125;const result = new Example()console.log(result.name) // 无输出 如果返回值是一个对象，且为函数，会无输出。 function Example() &#123; this.name = &quot;张三&quot; return &#123; name: &#x27;hh&#x27; &#125;&#125;const result = new Example()console.log(result.name) // hh 如果返回值是一个对象，且包含有相应的属性，则输出这个属性值。 function Example() &#123; this.name = &quot;张三&quot; return 123&#125;const result = new Example()console.log(result.name) // 张三 function Example() &#123; this.name = &quot;张三&quot; return &#x27;function () &#123; &#125;&#x27;&#125;const result = new Example()console.log(result.name) // 张三 function Example() &#123; this.name = &quot;张三&quot; return undefined&#125;const result = new Example()console.log(result.name) // 张三 如果返回值不是一个对象那么 this 还是指向函数的实例。 function Example() &#123; this.name = &quot;张三&quot; return null&#125;const result = new Example()console.log(result.name) // 张三 这是一个特例：函数返回值是 null，this 还是指向函数的实例。 function Example() &#123; this.name = &quot;张三&quot; return Symbol&#125;const result = new Example()console.log(result.name) // Symbol function Example() &#123; this.name = &quot;张三&quot; return BigInt&#125;const result = new Example()console.log(result.name) // BigInt 如果返回值是 Number、String、BigInt等，会输出对应的返回值。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/tags/JavaScript/"}]},{"title":"reduce的妙用","slug":"JavaScript/reduce的妙用","date":"2023-05-03T12:08:08.000Z","updated":"2024-12-27T17:38:35.755Z","comments":true,"path":"2023/05/03/JavaScript/reduce的妙用/","link":"","permalink":"http://ran-up.github.io/2023/05/03/JavaScript/reduce%E7%9A%84%E5%A6%99%E7%94%A8/","excerpt":"","text":"计算数组的总和const arr = [1, 2, 3, 4, 5]const result = arr.reduce((accumulator, currentValue) =&gt; accumulator += currentValue)console.log(result) // 15 计算数组的平均数const arr = [1, 2, 3, 4, 5]const result = arr.reduce((accumulator, currentValue, currentIndex, array) =&gt; &#123; accumulator += currentValue if (currentIndex === array.length - 1) &#123; return accumulator / array.length &#125; return accumulator&#125;)console.log(result) // 3 求数组的最大值const arr = [1, 2, 3, 4, 5]const result = arr.reduce((previousValue, currentValue) =&gt; Math.max(previousValue, currentValue))console.log(result) // 5 求数组的最小值const arr = [1, 2, 3, 4, 5]const result = arr.reduce((previousValue, currentValue) =&gt; Math.min(previousValue, currentValue))console.log(result) // 1 数值去重const arr = [1, 2, 3, 4, 5, 5, 6, 3, 4, 1, 19]const result = arr.reduce((accumulator, currentValue) =&gt; &#123; if (!accumulator.includes(currentValue)) &#123; accumulator.push(currentValue) &#125; return accumulator&#125;, [])console.log(result) // [1, 2, 3, 4, 5, 6, 19] 计算数组中每个元素出现的次数const arr = [1, 2, 3, 4, 5, 5, 6, 3, 4, 1, 19]const result = arr.reduce((accumulator, currentValue) =&gt; &#123; if (!accumulator[currentValue]) &#123; accumulator[currentValue] = 1 &#125; else &#123; accumulator[currentValue]++ &#125; return accumulator&#125;, &#123;&#125;)console.log(result) // &#123;1: 2, 2: 1, 3: 2, 4: 2, 5: 2, 6: 1, 19: 1&#125; 实现数组分组const arr = [1, 2, 3, 4, 5, 5, 6, 3, 4, 1, 19]const result = arr.reduce((accumulator, currentValue) =&gt; &#123; if (currentValue % 2 === 0) &#123; accumulator.even.push(currentValue) &#125; else &#123; accumulator.odd.push(currentValue) &#125; return accumulator&#125;, &#123; even: [], odd: [] &#125;)console.log(result) /* even: (4) [2, 4, 6, 4] odd: (7) [1, 3, 5, 5, 3, 1, 19]*/ 计算数组中连续递增数字的长度const arr = [1, 2, 3, 4, 5, 5, 6, 3, 4, 1, 19]const result = arr.reduce((accumulator, currentValue, currentIndex, array) =&gt; &#123; if (currentIndex === 0 || currentValue !== array[currentIndex - 1] + 1) &#123; accumulator.push([currentValue]) &#125; else &#123; accumulator[accumulator.length - 1].push(currentValue) &#125; return accumulator&#125;, [])/* result 输出结果 0: (5) [1, 2, 3, 4, 5] 1: (2) [5, 6] 2: (2) [3, 4] 3: [1] 4: [19]*/const maxLength = result.reduce((previousValue, currentValue) =&gt; Math.max(previousValue, currentValue.length), 0)console.log(maxLength) // 5 计算对象数组的属性求和const arr = [ &#123; name: &#x27;张三1&#x27;, age: 28 &#125;, &#123; name: &#x27;张三2&#x27;, age: 24 &#125;, &#123; name: &#x27;张三3&#x27;, age: 17 &#125;, &#123; name: &#x27;张三4&#x27;, age: 30 &#125;]const result = arr.reduce((accumulator, currentValue) =&gt; accumulator += currentValue.age, 0)console.log(result) // 99 将对象数组转换为键值对对象const arr = [ &#123; name: &#x27;张三1&#x27;, age: 28 &#125;, &#123; name: &#x27;张三2&#x27;, age: 24 &#125;, &#123; name: &#x27;张三3&#x27;, age: 17 &#125;, &#123; name: &#x27;张三4&#x27;, age: 30 &#125;]const result = arr.reduce((accumulator, currentValue) =&gt; &#123; accumulator[currentValue.name] = currentValue.age return accumulator&#125;, &#123;&#125;)console.log(result) // &#123;张三1: 28, 张三2: 24, 张三3: 17, 张三4: 30&#125; 计算数组中出现够次数最多的元素const arr = [1, 2, 3, 4, 5, 5, 5, 6, 3, 4, 1, 19]const result = arr.reduce((accumulator, currentValue) =&gt; &#123; accumulator[currentValue] = (accumulator[currentValue] || 0) + 1 return accumulator&#125;, &#123;&#125;)const maxCount = Math.max(...Object.values(result))const res = Object.keys(result).filter(key =&gt; result[key] === maxCount).map(Number)console.log(res) // [5] 实现Promise串行执行const promise1 = () =&gt; Promise.resolve(&#x27;one&#x27;)const promise2 = (input) =&gt; Promise.resolve(input + &#x27; two&#x27;)const promise3 = (input) =&gt; Promise.resolve(input + &#x27; three&#x27;)const result = [promise1, promise2, promise3].reduce((accumulator, currentValue) =&gt; &#123; return accumulator.then(currentValue)&#125;, Promise.resolve(&#x27;start&#x27;))result.then(console.log) // one two three 按属性对数组分组const arr = [ &#123; name: &#x27;张三1&#x27;, age: 28 &#125;, &#123; name: &#x27;张三2&#x27;, age: 24 &#125;, &#123; name: &#x27;张三3&#x27;, age: 17 &#125;, &#123; name: &#x27;张三1&#x27;, age: 30 &#125;]const result = arr.reduce((accumulator, currentValue) =&gt; &#123; const key = currentValue.name if (!accumulator[key]) &#123; accumulator[key] = [] &#125; accumulator[key].push(currentValue) return accumulator&#125;, &#123;&#125;)console.log(result)/* 张三1: Array(2) 0: &#123;name: &#x27;张三1&#x27;, age: 28&#125; 1: &#123;name: &#x27;张三1&#x27;, age: 30&#125;张三2: Array(1) 0: &#123;name: &#x27;张三2&#x27;, age: 24&#125;张三3: Array(1) 0: &#123;name: &#x27;张三3&#x27;, age: 17&#125;*/ 扁平化数组 不适合多层嵌套 const arr = [1, 2, [3, 4, 5, 5], 5, [6, 3, 4], 1, 19]const result = arr.reduce((accumulator, currentValue) =&gt; &#123; if (Array.isArray(currentValue)) &#123; return accumulator.concat(currentValue) &#125; accumulator.push(currentValue) return accumulator&#125;, [])console.log(result) // [1, 2, 3, 4, 5, 5, 5, 6, 3, 4, 1, 19] 合并对象const arr1 = &#123; a: &#x27;张三1&#x27;, c: 17 &#125;const arr2 = &#123; b: &#x27;张三2&#x27;, d: 27 &#125;const arr3 = &#123; a: &#x27;张三3&#x27;, g: 37 &#125;const result = [arr1, arr2, arr3].reduce((accumulator, currentValue) =&gt; Object.assign(accumulator, currentValue), &#123;&#125;)console.log(result) // &#123;a: &#x27;张三3&#x27;, c: 17, b: &#x27;张三2&#x27;, d: 27, g: 37&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/categories/JavaScript/"}],"tags":[{"name":"reduce的妙用","slug":"reduce的妙用","permalink":"http://ran-up.github.io/tags/reduce%E7%9A%84%E5%A6%99%E7%94%A8/"}]},{"title":"安装nrm出错","slug":"项目bug/安装依赖出错/安装nrm出错","date":"2023-04-02T10:20:18.000Z","updated":"2024-12-27T17:38:35.773Z","comments":true,"path":"2023/04/02/项目bug/安装依赖出错/安装nrm出错/","link":"","permalink":"http://ran-up.github.io/2023/04/02/%E9%A1%B9%E7%9B%AEbug/%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%87%BA%E9%94%99/%E5%AE%89%E8%A3%85nrm%E5%87%BA%E9%94%99/","excerpt":"","text":"简介很多时候安装依赖都报： npm ERR! code E404npm ERR! 404 Not Found - GET https://registry.npmjs.org/uni-id - Not found 这就很烦，然后正好看到一个这方面的依赖包 —&gt; nrm 就想着下载一个，npm i nrm -g 的过程没什么问题，但使用 nrm ls 有问题 报错为： 解决办法在网上找了些答案，然后花了很多时间，这里备份一下，然后也可以帮大家节约时间。 这里可以使用：npm i nrm -g &#111;&#x70;&#101;&#110;&#64;&#56;&#x2e;&#52;&#x2e;&#x32; 然后就可以安装并使用成功了。 后面使用 nrm ls 也可以成功。","categories":[{"name":"安装依赖出错","slug":"安装依赖出错","permalink":"http://ran-up.github.io/categories/%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%87%BA%E9%94%99/"}],"tags":[{"name":"项目bug","slug":"项目bug","permalink":"http://ran-up.github.io/tags/%E9%A1%B9%E7%9B%AEbug/"}]},{"title":"swiper分页器数量与轮播图数量不对应，轮播有次抽搐，鼠标移入不暂停","slug":"项目bug/使用swiper出现的bug/swiper分页器数量与轮播图数量不对应，轮播有次抽搐，鼠标移入不暂停","date":"2023-03-19T06:42:33.000Z","updated":"2024-12-27T17:38:35.772Z","comments":true,"path":"2023/03/19/项目bug/使用swiper出现的bug/swiper分页器数量与轮播图数量不对应，轮播有次抽搐，鼠标移入不暂停/","link":"","permalink":"http://ran-up.github.io/2023/03/19/%E9%A1%B9%E7%9B%AEbug/%E4%BD%BF%E7%94%A8swiper%E5%87%BA%E7%8E%B0%E7%9A%84bug/swiper%E5%88%86%E9%A1%B5%E5%99%A8%E6%95%B0%E9%87%8F%E4%B8%8E%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%95%B0%E9%87%8F%E4%B8%8D%E5%AF%B9%E5%BA%94%EF%BC%8C%E8%BD%AE%E6%92%AD%E6%9C%89%E6%AC%A1%E6%8A%BD%E6%90%90%EF%BC%8C%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%85%A5%E4%B8%8D%E6%9A%82%E5%81%9C/","excerpt":"","text":"简介这几天遇到了swiper轮播组件自动轮播到某些图片时，就会抽搐（一窜就过去了），也就是延迟时间没有生效。 然后今天突然发现分页器的数量和轮播图片的数量不对应。（因为网页是响应式的，在pc端的分页器部分被遮挡了） 还有就是鼠标移入进去后不暂停自动轮播，后面设置了好像也无效（有点忘记了）。 然后就弄了很久，之前以为是因为版本问题，然后就把最初的&#115;&#x77;&#x69;&#x70;&#101;&#x72;&#64;&#x36;&#46;&#56;&#46;&#x34;换成了&#x73;&#119;&#105;&#x70;&#x65;&#114;&#x40;&#53;&#x2e;&#52;&#x2e;&#x35;，网上说这个版本的兼容 最好，具体我也不知道，哈哈哈~~~ 然后还是有问题，之后我就把官方的代码弄过来了，也不行，嗯…就很离谱。 后面我就突然发现，可能是我的swiper轮播组件太多了，造成了冲突。 然后就把这部分的swiper初始化的容器名改了： 之前是：new Swiper(&#39;.swiper-containe&#39; , &#123;&#125;) 现在是：new Swiper(&#39;.swiper1&#39; , &#123;&#125;) 总结： 其实我这些bug的原因就是：一个页面有多个swiper轮播组件，然后每个都需要初始化，而初始化时的容器名都是相同的，造成了冲突。 只要是最后展示在一个页面中，不管是在父组件还是说在子组件中，都会造成swiper轮播组件冲突问题（我的猜测^_^） 解决办法解决swiper分页器数量与轮播图数量不对应，轮播有次抽搐的现象根据上面的内容，我们只要解决了同一个页面中的swiper初始化所造成的冲突，就能够解决这个问题。 简单粗暴的方法：每次初始化swiper组件时，都重新将容器名重新命名，不让其swiper组件都是一个容器名。 这样就成功的解决了：swiper分页器数量与轮播图数量不对应，轮播有次抽搐的现象了。 之前的代码： 第一个组件： &lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;3&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-prev d-none d-md-inline-block&quot; ref=&quot;swiperBtnPrev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next d-none d-md-inline-block&quot; ref=&quot;swiperBtnNext&quot;&gt;&lt;/div&gt;&lt;/div&gt;const mySwiper = new Swiper(&#x27;.swiper-container&#x27;, &#123; pagination: &#123; el: &#x27;.swiper-pagination&#x27;, clickable: true &#125;, navigation: &#123; nextEl: &#x27;.swiper-button-next&#x27;, prevEl: &#x27;.swiper-button-prev&#x27; &#125;, // 自动切换 autoplay: &#123; delay: 3000, stopOnLastSlide: false, // 播放完最后一张图片后是否停留在最后一张图片上，停止继续轮播。默认false disableOnInteraction: false // 用户操作轮播图后，比如点击轮播按钮或小圆点，继续自动轮播 &#125;, loop: true&#125;)mySwiper.el.onmouseover = function () &#123; mySwiper.autoplay.stop()&#125;mySwiper.el.onmouseout = function () &#123; mySwiper.autoplay.start()&#125; 第二个组件： &lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;3&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-prev d-none d-md-inline-block&quot; ref=&quot;swiperBtnPrev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next d-none d-md-inline-block&quot; ref=&quot;swiperBtnNext&quot;&gt;&lt;/div&gt;&lt;/div&gt;const mySwiper = new Swiper(&#x27;.swiper-container&#x27;, &#123; pagination: &#123; el: &#x27;.swiper-pagination&#x27;, clickable: true &#125;, navigation: &#123; nextEl: &#x27;.swiper-button-next&#x27;, prevEl: &#x27;.swiper-button-prev&#x27; &#125;, // 自动切换 autoplay: &#123; delay: 3000, stopOnLastSlide: false, // 播放完最后一张图片后是否停留在最后一张图片上，停止继续轮播。默认false disableOnInteraction: false // 用户操作轮播图后，比如点击轮播按钮或小圆点，继续自动轮播 &#125;, loop: true&#125;)mySwiper.el.onmouseover = function () &#123; mySwiper.autoplay.stop()&#125;mySwiper.el.onmouseout = function () &#123; mySwiper.autoplay.start()&#125; 现在的代码： 第一个组件： &lt;div class=&quot;swiper-container swiper1&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;3&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-prev d-none d-md-inline-block&quot; ref=&quot;swiperBtnPrev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next d-none d-md-inline-block&quot; ref=&quot;swiperBtnNext&quot;&gt;&lt;/div&gt;&lt;/div&gt;const mySwiper = new Swiper(&#x27;.swiper1&#x27;, &#123; pagination: &#123; el: &#x27;.swiper-pagination&#x27;, clickable: true &#125;, navigation: &#123; nextEl: &#x27;.swiper-button-next&#x27;, prevEl: &#x27;.swiper-button-prev&#x27; &#125;, // 自动切换 autoplay: &#123; delay: 3000, stopOnLastSlide: false, // 播放完最后一张图片后是否停留在最后一张图片上，停止继续轮播。默认false disableOnInteraction: false // 用户操作轮播图后，比如点击轮播按钮或小圆点，继续自动轮播 &#125;, loop: true&#125;)mySwiper.el.onmouseover = function () &#123; mySwiper.autoplay.stop()&#125;mySwiper.el.onmouseout = function () &#123; mySwiper.autoplay.start()&#125; 第二个组件： &lt;div class=&quot;swiper-container swiper2&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;3&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-prev d-none d-md-inline-block&quot; ref=&quot;swiperBtnPrev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next d-none d-md-inline-block&quot; ref=&quot;swiperBtnNext&quot;&gt;&lt;/div&gt;&lt;/div&gt;const mySwiper = new Swiper(&#x27;.swiper2&#x27;, &#123; pagination: &#123; el: &#x27;.swiper-pagination&#x27;, clickable: true &#125;, navigation: &#123; nextEl: &#x27;.swiper-button-next&#x27;, prevEl: &#x27;.swiper-button-prev&#x27; &#125;, // 自动切换 autoplay: &#123; delay: 3000, stopOnLastSlide: false, // 播放完最后一张图片后是否停留在最后一张图片上，停止继续轮播。默认false disableOnInteraction: false // 用户操作轮播图后，比如点击轮播按钮或小圆点，继续自动轮播 &#125;, loop: true&#125;)mySwiper.el.onmouseover = function () &#123; mySwiper.autoplay.stop()&#125;mySwiper.el.onmouseout = function () &#123; mySwiper.autoplay.start()&#125; 解决鼠标移入不暂停的现象这个问题，其实有可能是你没有设置，或者是你设置的属性不在这个版本生效。 这个问题在swiper官网也有说，链接：https://www.swiper.com.cn/api/autoplay/474.html （若链接失效，可以直接搜索swiper，相应内容是Autoplay自动切换的pauseOnMouseEnter属性） 这里也简单说一下： autoplay: &#123; // 鼠标置于swiper时暂停自动切换，鼠标离开时恢复自动切换 pauseOnMouseEnter: true&#125; 如果开启了disableOnInteraction，那么自动切换不会恢复。 所以我们一般这样写： autoplay: &#123; delay: 3000, // 用户操作轮播图后，比如点击轮播按钮或小圆点，继续自动轮播 disableOnInteraction: false, // 鼠标置于swiper时暂停自动切换，鼠标离开时恢复自动切换 pauseOnMouseEnter: true&#125; 注意：上面的版本只在&#115;&#x77;&#105;&#x70;&#x65;&#114;&#64;&#x36;&#x2e;&#56;&#x2e;&#x34;之后生效，在其之前的需要使用其他的代码: （但我这里使用&#x73;&#x77;&#105;&#112;&#x65;&#114;&#64;&#54;&#46;&#x38;&#46;&#52;还是没生效所以用的&#115;&#119;&#x69;&#112;&#x65;&#114;&#x40;&#x35;&#46;&#x34;&#46;&#53;） mySwiper.el.onmouseover = function()&#123; mySwiper.autoplay.stop();&#125;mySwiper.el.onmouseout = function()&#123; mySwiper.autoplay.start();&#125; 总结问题1：swiper分页器数量与轮播图数量不对应，轮播有次抽搐的现象 解决方法是：当页面有多个swiper轮播组件时，需要将每个swiper组件在初始化时取不同的容器名 问题2：解决鼠标移入不暂停的现象 解决办法：可能是你没有设置相应的属性；或者你设置了相应的属性，但是你的版本并不支持这个方式，具体可以看官网的描述。 全部的代码版本是&#x73;&#119;&#x69;&#x70;&#x65;&#114;&#x40;&#53;&#46;&#52;&#x2e;&#53; &lt;div class=&quot;swiper-container swiper1&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;3&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-prev d-none d-md-inline-block&quot; ref=&quot;swiperBtnPrev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next d-none d-md-inline-block&quot; ref=&quot;swiperBtnNext&quot;&gt;&lt;/div&gt;&lt;/div&gt;const mySwiper = new Swiper(&#x27;.swiper1&#x27;, &#123; pagination: &#123; el: &#x27;.swiper-pagination&#x27;, clickable: true &#125;, navigation: &#123; nextEl: &#x27;.swiper-button-next&#x27;, prevEl: &#x27;.swiper-button-prev&#x27; &#125;, // 自动切换 autoplay: &#123; delay: 3000, stopOnLastSlide: false, // 播放完最后一张图片后是否停留在最后一张图片上，停止继续轮播。默认false disableOnInteraction: false // 用户操作轮播图后，比如点击轮播按钮或小圆点，继续自动轮播 &#125;, loop: true&#125;)mySwiper.el.onmouseover = function () &#123; mySwiper.autoplay.stop()&#125;mySwiper.el.onmouseout = function () &#123; mySwiper.autoplay.start()&#125;","categories":[{"name":"使用swiper出现的bug","slug":"使用swiper出现的bug","permalink":"http://ran-up.github.io/categories/%E4%BD%BF%E7%94%A8swiper%E5%87%BA%E7%8E%B0%E7%9A%84bug/"}],"tags":[{"name":"项目bug","slug":"项目bug","permalink":"http://ran-up.github.io/tags/%E9%A1%B9%E7%9B%AEbug/"}]},{"title":"map后用solice取不到数组最后一个元素","slug":"项目bug/vue项目/map后用solice取不到数组最后一个元素","date":"2023-03-09T03:44:54.000Z","updated":"2024-12-27T17:38:35.772Z","comments":true,"path":"2023/03/09/项目bug/vue项目/map后用solice取不到数组最后一个元素/","link":"","permalink":"http://ran-up.github.io/2023/03/09/%E9%A1%B9%E7%9B%AEbug/vue%E9%A1%B9%E7%9B%AE/map%E5%90%8E%E7%94%A8solice%E5%8F%96%E4%B8%8D%E5%88%B0%E6%95%B0%E7%BB%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0/","excerpt":"","text":"简介今天对数组使用slice取出需要的值后，再用map进行遍历循环，最后使用splice将数组中的值分批取出， 又因为数组中的数据比较多，所以又在splice外面加了一个map循环。然后出现的问题是：只能取到数组前三者的值 从而合为一个数组。然后最后一个值，是后面输出的。（总共是12个数据，使用splice取，分成4个数组，每个数组包含3个元素） 然后就搞了很久，反正是知道是splice这里的问题。因为我单独拿出来也是取不到最后一个值的。 之前的完整数据： 进行上面操作之后的数据： 单独将splice数据拿出来： 现在知道了问题，然后我们就可以对齐下手，然后找了很久，就试着使用了原生的for循环，结果成了，哈哈哈。 在这里记录一下，给自己弄个备份，也给遇到这个问题的小伙伴一个解决问题的参考。 解决办法后面我就没有使用map+splice的方法了，而是使用的传统for循环来进行循环输出。 前提是你要知道你需要循环的次数，而这里我恰好可以算出来。 // slice是取出这个范围的数据，map是将这些属性进行相同的操作（循环遍历） wechatDataArr.slice(1, wechatDataArr.length - 2).map((wechatItem, index, wechatArr) =&gt; &#123; // 将遍历取出的数据托送到这个新的数组中 const adminImgDataList = [] for (let i = wechatArr.length / 3; i &gt; 0; i--) &#123; adminImgDataList.push(wechatArr.splice(0, 3)) &#125; console.log(adminImgDataList)&#125; 然后就成功的解决了，完结。撒花~~~~","categories":[{"name":"vue项目","slug":"vue项目","permalink":"http://ran-up.github.io/categories/vue%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目bug","slug":"项目bug","permalink":"http://ran-up.github.io/tags/%E9%A1%B9%E7%9B%AEbug/"}]},{"title":"控制台报GET http://localhost:8080/4 404 (Not Found)","slug":"项目bug/vue项目/控制台报404","date":"2023-03-07T06:59:59.000Z","updated":"2024-12-27T17:38:35.772Z","comments":true,"path":"2023/03/07/项目bug/vue项目/控制台报404/","link":"","permalink":"http://ran-up.github.io/2023/03/07/%E9%A1%B9%E7%9B%AEbug/vue%E9%A1%B9%E7%9B%AE/%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%8A%A5404/","excerpt":"","text":"简介今天做一个vue的项目，之前是一个组件包含有很多的内容，然后，连接真实接口之后，我就将他们拆分出来了， 每一个模块是作为一个组件，然后就很神奇，页面能成功的渲染，但是在控制台报：GET http://localhost:8080/4 404 (Not Found) 这就让我很疑惑，然后我就看之前的按个大组件是不是有错误，排查了并没有，之后我就把我新创建的这个组件的内容全部进行了剪切， 然后在根据报错，逐步的解决，最后发现控制台没有报错了，从而得出就是新组件的错误。 后面看了一篇博客：原地址是 – https://blog.csdn.net/weixin_46258925/article/details/123890919 上面说他出现这个问题是因为:src&#x3D;””的动态图片设置，然后我就去看了我的，哈哈哈，我也是和他一样的错误。 之后把src的动态地址改正确就可以了。 解决办法将那个:src&#x3D;””的动态数据改正确即可。 原来： 现在： 原因是：只是获取到了数组最后一个元素的索引，但是并没有在数组中去找。","categories":[{"name":"vue项目","slug":"vue项目","permalink":"http://ran-up.github.io/categories/vue%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目bug","slug":"项目bug","permalink":"http://ran-up.github.io/tags/%E9%A1%B9%E7%9B%AEbug/"}]},{"title":"项目中使用的正则","slug":"正则/项目中使用的正则","date":"2023-03-06T03:20:46.000Z","updated":"2024-12-27T17:38:35.769Z","comments":true,"path":"2023/03/06/正则/项目中使用的正则/","link":"","permalink":"http://ran-up.github.io/2023/03/06/%E6%AD%A3%E5%88%99/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99/","excerpt":"","text":"匹配标签中的内容这里我要匹配：&lt;h1 style=&quot;text-align: center;&quot;&gt;导航模块&lt;/h1&gt; 中的内容 所以使用的是：/&lt;h1+.*?&gt;([\\s\\S]*?)&lt;\\/h1*?&gt;/ig","categories":[{"name":"正则","slug":"正则","permalink":"http://ran-up.github.io/categories/%E6%AD%A3%E5%88%99/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://ran-up.github.io/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"uniapp开发运行到微信小程序报游客身份","slug":"项目bug/uniapp项目/uniapp开发运行到微信小程序报游客身份","date":"2023-02-22T03:42:59.000Z","updated":"2024-12-27T17:38:35.771Z","comments":true,"path":"2023/02/22/项目bug/uniapp项目/uniapp开发运行到微信小程序报游客身份/","link":"","permalink":"http://ran-up.github.io/2023/02/22/%E9%A1%B9%E7%9B%AEbug/uniapp%E9%A1%B9%E7%9B%AE/uniapp%E5%BC%80%E5%8F%91%E8%BF%90%E8%A1%8C%E5%88%B0%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%A5%E6%B8%B8%E5%AE%A2%E8%BA%AB%E4%BB%BD/","excerpt":"","text":"简介使用uniapp开发微信小程序，需要获取用户信息，但是用微信开发者工具一直报：游客身份。 解决办法我们打开 HBuilder 的 manifest.json，找到【微信小程序配置】当中的【微信小程序AppID】 然后将我们自己的AppID填入就可以了。 如果没有自己的AppID，可以在网上搜一搜，有很多教程。","categories":[{"name":"uniapp项目","slug":"uniapp项目","permalink":"http://ran-up.github.io/categories/uniapp%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目bug","slug":"项目bug","permalink":"http://ran-up.github.io/tags/%E9%A1%B9%E7%9B%AEbug/"}]},{"title":"引人iconfont图标无效","slug":"项目bug/uniapp项目/引人iconfont图标无效","date":"2023-02-20T13:33:03.000Z","updated":"2024-12-27T17:38:35.771Z","comments":true,"path":"2023/02/20/项目bug/uniapp项目/引人iconfont图标无效/","link":"","permalink":"http://ran-up.github.io/2023/02/20/%E9%A1%B9%E7%9B%AEbug/uniapp%E9%A1%B9%E7%9B%AE/%E5%BC%95%E4%BA%BAiconfont%E5%9B%BE%E6%A0%87%E6%97%A0%E6%95%88/","excerpt":"","text":"简介前两天在另一个页面成功的引入并显示出来阿里巴巴的iconfont图标，但今天在另一个页面不能够显示新的图标，但原页面不受影响。 注意：如果你是最初引入的不成功，可以看我另外一篇博客。 我出现这个原因是在最初引入了iconfont.css到项目中，当添加了新图标也进行更新了引入的iconfont.css文件。 然后，按照之前的操作进行了设置，但是页面依旧没有出现内容，调试了两天，然后网上也没用明确的教程，但是今天一下子就找到了。 在这里记录一下，方便后面出现问题的查找，避免浪费大家的时间，也防止忘记。 解决办法 首先打开阿里巴巴图标网站: https://www.iconfont.cn/ 选择导航【资源管理】-&gt; 【我的项目】-&gt;【这里选择你自己的项目名】 然后选择 Unicode，然后点击 查看在线连接 这一步就非常关键了，点击 查看在线连接后会出现点击更新代码，默认不在生成......，点击这个选项，然后会出现一个弹出框，点击确定就可以了。 最后一步就是将更新后的代码，复制到iconfont.css中对应的位置。","categories":[{"name":"uniapp项目","slug":"uniapp项目","permalink":"http://ran-up.github.io/categories/uniapp%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目bug","slug":"项目bug","permalink":"http://ran-up.github.io/tags/%E9%A1%B9%E7%9B%AEbug/"}]},{"title":"同时上传到github和gitee","slug":"git相关/同时上传到github和gitee","date":"2023-02-19T09:22:19.000Z","updated":"2024-12-27T17:38:35.761Z","comments":true,"path":"2023/02/19/git相关/同时上传到github和gitee/","link":"","permalink":"http://ran-up.github.io/2023/02/19/git%E7%9B%B8%E5%85%B3/%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E5%88%B0github%E5%92%8Cgitee/","excerpt":"","text":"同时上传到github和gitee操作当前远程仓库首先查看当前的远程仓库：git remote -v 然后重命名：git remote rename origin gitee 注意 -&gt; 我这里的远程仓库是gitee 这里进行重命名，是为了方便后面的新加远程仓库，因为一般默认为origin，重名就不能进行添加了； 这样进行了重命名，不但方便辨认不同的远程仓库，也方面后面添加新的远程仓库。 添加另一个远程仓库这个时候我们就可以添加另一个远程仓库了， 输入：git remote add github &#x67;&#105;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;:ran-up&#x2F;wechat_xiaotaoji.git 然后，我们可以输入：git remote -v 来查看是否添加成功 如果输出下面的内容，则添加成功。 gitee https://gitee.com/ran-xing/wechat_xiaotaoji.git (fetch)gitee https://gitee.com/ran-xing/wechat_xiaotaoji.git (push)github https://github.com/ran-up/wechat_xiaotaoji.git (fetch)github https://github.com/ran-up/wechat_xiaotaoji.git (push) 多个远程仓库的推送&#x2F;拉取其实和一个远程仓库类似的，只是后面加上那个远程仓库的名称即可 比如： git push github devgit pull github devgit push gitee devgit pull gitee dev 移除远程仓库如果想要移除一个远程仓库，可以使用下面命令： git remote remove gitee","categories":[{"name":"git相关","slug":"git相关","permalink":"http://ran-up.github.io/categories/git%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"git","slug":"git","permalink":"http://ran-up.github.io/tags/git/"}]},{"title":"如何更换git中gitee的信息","slug":"git相关/如何更换git中gitee的信息","date":"2023-02-19T08:27:52.000Z","updated":"2024-12-27T17:38:35.761Z","comments":true,"path":"2023/02/19/git相关/如何更换git中gitee的信息/","link":"","permalink":"http://ran-up.github.io/2023/02/19/git%E7%9B%B8%E5%85%B3/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%8D%A2git%E4%B8%ADgitee%E7%9A%84%E4%BF%A1%E6%81%AF/","excerpt":"","text":"简介有时候我们可能需要在公司和私人之间进行git中gitee的账号信息切换。 然后，这里给自己记一个笔记，防止后期遗忘。 切换方法替换全局的user和email 查看项目git信息 输入: git config --global --list 查看全局的git信息 如果只是想查看当前项目的git信息，可以去掉其中的 –global 如果与刚才的信息不符合，则使用下面的命令修改 修改用户名：git config --global user.name &quot;新用户名&quot; 修改邮箱：git config --global user.email &quot;新邮箱&quot; 清除之前在git中设置的gitee信息 打开 windows 凭据 方法1：可以在电脑右下角的输入框内输入：管理 Windows 凭据，然后选择打开 方法2：如果电脑有控制面板，也可以选择：用户账号-&gt;凭证管理器-&gt;管理 Windows 凭据 点击：git.https://gitee.com 点击弹出的删除选项 设置git中的gitee信息 绑定gitee的远程仓库，输入：git remote add origin 远程仓库地址 其中的 origin 是远程仓库的重命名名称。 如果想同时上传gitee或github，就可以根据不同的仓库，填写不同的重命名名称，方便分辨。 可以输入：git remote -v 查看当前绑定的远程仓库地址 也可以给其仓库重命名：git remote rename origin gitee 输入：git push，在弹出的Git Credential Manager 中填入自己gitee的信息。 就是自己在gitee中的邮箱和密码。 成功 如果出现这样的信息就是成功了。 这里我是同时上传到gitee和github的，所以后面需要跟上相对于的仓库别名。 如果想像我这样同时上传到gitee和github中，可以看我的另一个博客内容。 注意事项如果直接在windows 凭据中修改邮箱地址，是无效的（信息没有更新），因为没有修改掉c盘中ssh的信息。","categories":[{"name":"git相关","slug":"git相关","permalink":"http://ran-up.github.io/categories/git%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"git","slug":"git","permalink":"http://ran-up.github.io/tags/git/"}]},{"title":"引入iconfont图标报错","slug":"项目bug/uniapp项目/引入iconfont图标报错","date":"2023-02-18T07:54:16.000Z","updated":"2024-12-27T17:38:35.771Z","comments":true,"path":"2023/02/18/项目bug/uniapp项目/引入iconfont图标报错/","link":"","permalink":"http://ran-up.github.io/2023/02/18/%E9%A1%B9%E7%9B%AEbug/uniapp%E9%A1%B9%E7%9B%AE/%E5%BC%95%E5%85%A5iconfont%E5%9B%BE%E6%A0%87%E6%8A%A5%E9%94%99/","excerpt":"","text":"简介这几天做毕设，需要用到iconfont图标，我使用的是uniapp+uview来做，但是呢使用uview自带的icon图标不行。 所以就打算引入阿里巴巴的iconfont图标。 不过在其中遇到一些问题。 其中的一些问题，我本人都不能说怎么解决的。 解决办法解决报unexpected @ 错误这个路径是报unexpected@ 但是我不知道怎么解决的，很离谱 我就操作了这些 首先就是，我把iconfont文件下下来了，放在了static/iconfont文件夹中， 然后将iconfont.css文件的src中的url换成了在线的。 在线链接查看方式： 然后在需要使用的组件的style中引入iconfont.css 注意：引入方式两种都可以，但是官方推荐使用~@这种形式。 这个时候，其实应该就可以了（我猜测），后面我把其他操作删除了，但是没有这个报错。 （后面的是我当时的操作，问题应该都解决了。）如果没有的话，可以把我这些步骤都来一下 但这个时候，我打开微信开发者工具还是有这个报错，嗯，就又去网上冲浪了。 比如： 在index.html中引入iconfont.css，不在当前组件总引入。 把app.vue中的引入scss的方式删除掉。 但是没有效果，然后，我就把软件关了（其实，之前我就关了很多次），这次奇迹发生了，没有报错了。 解决渲染层错误报错信息是这样的 然后又是在网上冲浪，嘿嘿，又被我找到了，刚刚我们在做这一步操作时，没有添加完成： 就是这个：将iconfont.css文件的src中的url换成了在线的。 我们需要把每个url开头加上: https:","categories":[{"name":"uniapp项目","slug":"uniapp项目","permalink":"http://ran-up.github.io/categories/uniapp%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目bug","slug":"项目bug","permalink":"http://ran-up.github.io/tags/%E9%A1%B9%E7%9B%AEbug/"}]},{"title":"修改commit的内容","slug":"git相关/修改commit的内容","date":"2023-02-15T09:02:56.000Z","updated":"2024-12-27T17:38:35.761Z","comments":true,"path":"2023/02/15/git相关/修改commit的内容/","link":"","permalink":"http://ran-up.github.io/2023/02/15/git%E7%9B%B8%E5%85%B3/%E4%BF%AE%E6%94%B9commit%E7%9A%84%E5%86%85%E5%AE%B9/","excerpt":"","text":"简介有时候，因为疏忽或者不细心，会在保存到本地仓库时写错描述信息。 有些公司可能会要求必须描述清楚，不能出现错别字等要求。 然后呢，这个时候就会比较焦灼。 解决办法我们可以使用：git commit --amend来修改 输入了上面的命令后，我们就可以按下键盘中的 i，然后去修改出错的描述。 最后我们修改完成，需要退出时，就可以先按两次 ctrl + c，然后输入 :qa。 这样我们就成功的退出，并且修改成功了。","categories":[],"tags":[]},{"title":"js计算元素距离顶部的高度及元素是否在可视区判断","slug":"JavaScript/js计算元素距离顶部的高度及元素是否在可视区判断","date":"2023-02-14T02:25:56.000Z","updated":"2024-12-27T17:38:35.755Z","comments":true,"path":"2023/02/14/JavaScript/js计算元素距离顶部的高度及元素是否在可视区判断/","link":"","permalink":"http://ran-up.github.io/2023/02/14/JavaScript/js%E8%AE%A1%E7%AE%97%E5%85%83%E7%B4%A0%E8%B7%9D%E7%A6%BB%E9%A1%B6%E9%83%A8%E7%9A%84%E9%AB%98%E5%BA%A6%E5%8F%8A%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%88%A4%E6%96%AD/","excerpt":"","text":"简介：原文章地址https://developer.aliyun.com/article/618566 前言： 在业务当中，我们经常要计算元素的大小和元素在页面的位置信息。比如说，在一个滚动区域内，我要知道元素A是在可视区内，还是在隐藏内容区（滚动到外边看不到了）。有时还要进一步知道，元素是全部都显示在可视区，还是有部分在可视区部分在隐藏内容区。有时还要进一步知道，在隐藏内容区的那一部分是占多大的大小。so，来聊聊如何获取元素的大小和位置信息。 计算元素距离顶部的高度：偏移量 在二维的世界里，可以想象成一个二维坐标系。每一个元素在坐标系内都有两个基本的属性：大小和位置。 大小： dom元素在页面的大小有两个属性：offsetWidth 、offsetHeight， offsetHeight：元素在垂直方向上的占用空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。（我的理解：盒模型包括border内的高度总和） offsetWidth： （同理） 位置： offsetParent 是一个只读属性，返回一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素。如果没有定位的元素，则 offsetParent 为最近的 table, table cell 或根元素 offsetTop：元素相对于其 offsetParent 元素的顶部的距离 offsetLeft：（同理） 元素大小和位置信息图解 原理： 计算元素距离顶部的高度：将元素的offsetTop与其offsetParent的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值。封装如下函数（开箱即用，函数返回值即为元素距离顶部高度） function getElementTop (el) { var actualTop &#x3D; el.offsetTop var current &#x3D; el.offsetParent while (current !&#x3D;&#x3D; null) { actualTop +&#x3D; current.offsetTop current &#x3D; current.offsetParent } return actuanlTop } 分析一下代码： 计算元素距离左部的高度：（同理可得） 元素是否在可视区判断：结合scrollTop 假如这样的业务场景：有一个wrap滚动容器，wrap的内容区content的高度超过wrap的高度，则出现纵向滚动条。随意拖动滚动条到某个位置，要判断content里面的子元素input输入框是否在可视区内，若不在可视区内，自动拖动滚动条，使其进入可视区。这样的业务场景其实经常有遇到。 原理： 首先，根据以上getElementTop(domInput)函数，得到元素input距离顶部的高度elementTop。再结合滚动容器domWrap的scrollTop属性得到滚动条高度scrollTop（被隐藏在内容区域上方的像素数），进行比较，即可判断 scrollTop &gt; elementTop： 滚动条高度大于元素离顶部高度，说明元素进入了隐藏内容区，进入的量为 scrollTop - elementTop scrollTop &lt; elementTop：滚动条高度小于元素的离顶部高度，说明元素还没进入上方的隐藏内容区，如要保证元素在可视区内，则必须同时满足条件，元素不在下方的隐藏内容区： elementTop - scrollTop &lt; document.documentElemnt.clientHeight 结论： 所以，元素在可视区的初步判断条件为：scrollTop &lt; elementTop &amp;&amp; elementTop - scrollTop &lt; document.documentElemnt.clientHeight 以上判断还不太严谨，如果wrap还同时存在横向滚动条，还得再判断是否元素在横向的可视区内，如果要判断元素是否完全在可视区，还得加上自身的高度值，即为：scrollTop &lt; elementTop &amp;&amp; elementTop + input.offsetHeight - scrollTop &lt; document.documentElemnt.clientHeight。 通过设置scrollTop属性的值domWrap.scrollTop &#x3D; elementTop 可以让滚动条自动滚动，且input元素刚好在可视区的上方。 ps：书上是这么说的，对于简单的CSS布局的页面，getElementTop函数可以得到非常精确的结果。对于使用表格和内嵌框架布局的页面，由于不同浏览器实现这些元素的方式不同，因此得到的结果就不太精确。在我的业务中，我没有用到表格和内嵌框架的布局，计算结果确实是精确的，可放心使用。如果使用表格和内嵌框架布局的页面，Keeping a eye on it。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/categories/JavaScript/"}],"tags":[{"name":"js实操","slug":"js实操","permalink":"http://ran-up.github.io/tags/js%E5%AE%9E%E6%93%8D/"}]},{"title":"对象转为字符串","slug":"JavaScript/对象转为字符串","date":"2023-02-07T13:14:39.000Z","updated":"2024-12-27T17:38:35.757Z","comments":true,"path":"2023/02/07/JavaScript/对象转为字符串/","link":"","permalink":"http://ran-up.github.io/2023/02/07/JavaScript/%E5%AF%B9%E8%B1%A1%E8%BD%AC%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"对象转为字符串对象转为字符串，首先会先尝试调用 valueOf()，再尝试 toString()。 但 Date类 是一个特例，它会执行 toString() 转换。 简单总结（需要验证）不能直接判断的，最后都是转为数值，再判断。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/categories/JavaScript/"}],"tags":[{"name":"类型转换","slug":"类型转换","permalink":"http://ran-up.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"}]},{"title":"查看或修改git配置","slug":"git相关/查看或修改配置","date":"2023-02-04T14:44:54.000Z","updated":"2024-12-27T17:38:35.762Z","comments":true,"path":"2023/02/04/git相关/查看或修改配置/","link":"","permalink":"http://ran-up.github.io/2023/02/04/git%E7%9B%B8%E5%85%B3/%E6%9F%A5%E7%9C%8B%E6%88%96%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE/","excerpt":"","text":"查看Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 查看git配置# 显示当前的Git配置$ git config --list# 查看提交代码时的用户信息$ git config user.name$ git config user.email 查看远程仓库$ git remote// 输出：origin// 查看origin指向的远程仓库地址$ git remote -v/*输出： gitee https://gitee.com/ran-xing/wechat_xiaotaoji.git (fetch) gitee https://gitee.com/ran-xing/wechat_xiaotaoji.git (push)*/ 修改git config --global user.name &quot;新用户名&quot;git config --global user.email &quot;新邮箱&quot;git config --global user.password &quot;新密码&quot; 同时上传到github和gitee操作当前远程仓库首先查看当前的远程仓库：git remote -v 然后重命名：git remote rename origin gitee 注意 -&gt; 我这里的远程仓库是gitee 这里进行重命名，是为了方便后面的新加远程仓库，因为一般默认为origin，重名就不能进行添加了； 这样进行了重命名，不但方便辨认不同的远程仓库，也方面后面添加新的远程仓库。 添加另一个远程仓库这个时候我们就可以添加另一个远程仓库了， 输入：git remote add github &#x67;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#117;&#98;&#46;&#99;&#x6f;&#109;:ran-up&#x2F;wechat_xiaotaoji.git 然后，我们可以输入：git remote -v 来查看是否添加成功 如果输出下面的内容，则添加成功。 gitee https://gitee.com/ran-xing/wechat_xiaotaoji.git (fetch)gitee https://gitee.com/ran-xing/wechat_xiaotaoji.git (push)github https://github.com/ran-up/wechat_xiaotaoji.git (fetch)github https://github.com/ran-up/wechat_xiaotaoji.git (push) 多个远程仓库的推送&#x2F;拉取其实和一个远程仓库类似的，只是后面加上那个远程仓库的名称即可 比如： git push github devgit pull github devgit push gitee devgit pull gitee dev 移除远程仓库如果想要移除一个远程仓库，可以使用下面命令： git remote remove gitee","categories":[{"name":"git相关","slug":"git相关","permalink":"http://ran-up.github.io/categories/git%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"git","slug":"git","permalink":"http://ran-up.github.io/tags/git/"}]},{"title":"vant-require-is-not-defined","slug":"vant相关/vant-require-is-not-defined","date":"2023-01-23T10:12:48.000Z","updated":"2024-12-27T17:38:35.763Z","comments":true,"path":"2023/01/23/vant相关/vant-require-is-not-defined/","link":"","permalink":"http://ran-up.github.io/2023/01/23/vant%E7%9B%B8%E5%85%B3/vant-require-is-not-defined/","excerpt":"","text":"简介今天用 uniapp 使用 vant2 碰到的一个小坑： 我使用的是官方的安装结束：npm i vant@latest-v2 -S 但是呢，最后运行报错： Uncaught ReferenceError: require is not defined 猜测是 vant 过高会报这个错，使得各种导入组件无效。 解决办法然后，通过降低版本解决：npm i &#118;&#x61;&#x6e;&#x74;&#64;&#50;&#46;&#x31;&#48;","categories":[{"name":"vant相关","slug":"vant相关","permalink":"http://ran-up.github.io/categories/vant%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"vant的坑","slug":"vant的坑","permalink":"http://ran-up.github.io/tags/vant%E7%9A%84%E5%9D%91/"}]},{"title":"引用的图标不能正常显示","slug":"Bootstrap相关/引用的图标不能正常显示","date":"2023-01-16T08:32:20.000Z","updated":"2024-12-27T17:38:35.753Z","comments":true,"path":"2023/01/16/Bootstrap相关/引用的图标不能正常显示/","link":"","permalink":"http://ran-up.github.io/2023/01/16/Bootstrap%E7%9B%B8%E5%85%B3/%E5%BC%95%E7%94%A8%E7%9A%84%E5%9B%BE%E6%A0%87%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/","excerpt":"","text":"简介今天使用 Bootstrap4 做项目，引用了 Bootstrap 的官方图标库，首先进行了安装：npm i bootstrap-icons 然后打开自己想要的图标，查看右侧的图标使用方法，比如： 之后复制到自己项目的相应位置上，这些步骤并没有什么错误，但浏览器中却没有显示出来刚刚的图标。 这就很让我不解，经过一番查询，看到了一个博客说：Bootstrap4 将这两者分离开了，可以去看看：https://blog.csdn.net/weixin_38997311/article/details/80673047 然后，他博客提到说:这些内容是官网说了的，所以还是要多看官方文档，视频那些不是最新的，官方博客才是实时更新的！！！ 这个官网的github地址：https://github.com/iconic/open-iconic 友情提醒，大家还是多背单词吧，我就是个英语学渣，看到就打脑壳。唉，谁叫我喜欢这个岗位呢。 解决方法直接使用 那个图标左侧下面的 svg 图标代码，而不要使用图标字体。 当我们把 svg 的图标代码 粘贴到项目中去，就可以在浏览器中刷新看到结果了。","categories":[{"name":"Bootstrap相关","slug":"Bootstrap相关","permalink":"http://ran-up.github.io/categories/Bootstrap%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Bootstrap错误","slug":"Bootstrap错误","permalink":"http://ran-up.github.io/tags/Bootstrap%E9%94%99%E8%AF%AF/"}]},{"title":"报错:fetch first","slug":"git相关/报错-fetch first","date":"2023-01-16T03:04:48.000Z","updated":"2024-12-27T17:38:35.762Z","comments":true,"path":"2023/01/16/git相关/报错-fetch first/","link":"","permalink":"http://ran-up.github.io/2023/01/16/git%E7%9B%B8%E5%85%B3/%E6%8A%A5%E9%94%99-fetch%20first/","excerpt":"","text":"简介当我进行 git pull -u origin dev 时，报的错是： ! [rejected] dev -&gt; dev (fetch first)error: failed to push some refs to &#x27;https://gitee.com/&#x27;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details. 解决方案其实就是你当前的仓库和远程仓库中的数据没有同步，并且推送的时候有冲突，说明别的开发者已经更新了仓库，但你没有及时的拉取。 首先先 git pull 同步代码，然后再推送 不推荐暴力推送：git push -f，这样会导致远程仓库同步成你的仓库文件，别人在最近更新而没有被你捕捉到的都会被覆盖。","categories":[{"name":"git相关","slug":"git相关","permalink":"http://ran-up.github.io/categories/git%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"git报错","slug":"git报错","permalink":"http://ran-up.github.io/tags/git%E6%8A%A5%E9%94%99/"}]},{"title":"报错:non-fast-forward","slug":"git相关/报错-non-fast-forward","date":"2023-01-16T03:04:48.000Z","updated":"2024-12-27T17:38:35.762Z","comments":true,"path":"2023/01/16/git相关/报错-non-fast-forward/","link":"","permalink":"http://ran-up.github.io/2023/01/16/git%E7%9B%B8%E5%85%B3/%E6%8A%A5%E9%94%99-non-fast-forward/","excerpt":"","text":"简介当我进行 git pull origin dev 时，报的错是： PS E:\\company&gt; git pushTo push the current branch and set the remote as upstream, use git push --set-upstream origin devTo have this happen automatically for branches without a trackingupstream, see &#x27;push.autoSetupRemote&#x27; in &#x27;git help config&#x27;.To https://gitee.com/xxx ! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to &#x27;https://gitee.com/xxx&#x27;hint: its remote counterpart. Integrate the remote changes (e.g.hint: &#x27;git pull ...&#x27;) before pushing again. 解决方案其实这个就是我们使用的新建的分支，而这个分支中的内容和 master 中的内容没有合并，所以造成的这个内容。 我这里是 dve 推送，所以合并 master 的内容 ：git dev master 然后在推送：git pull origin dev","categories":[{"name":"git相关","slug":"git相关","permalink":"http://ran-up.github.io/categories/git%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"git报错","slug":"git报错","permalink":"http://ran-up.github.io/tags/git%E6%8A%A5%E9%94%99/"}]},{"title":"npm下载报npm ERR code ERESOLVE","slug":"Vue/npm下载报npm ERR code ERESOLVE","date":"2023-01-12T14:24:14.000Z","updated":"2024-12-27T17:38:35.759Z","comments":true,"path":"2023/01/12/Vue/npm下载报npm ERR code ERESOLVE/","link":"","permalink":"http://ran-up.github.io/2023/01/12/Vue/npm%E4%B8%8B%E8%BD%BD%E6%8A%A5npm%20ERR%20code%20ERESOLVE/","excerpt":"","text":"简介： npm下载报错npm ERR code ERESOLVE 报错： npm ERR! code ERESOLVEnpm ERR! ERESOLVE could not resolvenpm ERR! npm ERR! While resolving: @vue/eslint-config-standard@6.1.0npm ERR! Found: eslint-plugin-vue@8.7.1npm ERR! node_modules/eslint-plugin-vuenpm ERR! peer eslint-plugin-vue@&quot;^8.0.1&quot; from @vue/eslint-config-typescript@9.1.0npm ERR! node_modules/@vue/eslint-config-typescriptnpm ERR! dev @vue/eslint-config-typescript@&quot;^9.1.0&quot; from the root projectnpm ERR! dev eslint-plugin-vue@&quot;^8.0.3&quot; from the root projectnpm ERR! npm ERR! Could not resolve dependency:npm ERR! peer eslint-plugin-vue@&quot;^7.0.0&quot; from @vue/eslint-config-standard@6.1.0npm ERR! node_modules/@vue/eslint-config-standardnpm ERR! dev @vue/eslint-config-standard@&quot;^6.1.0&quot; from the root projectnpm ERR!npm ERR! Conflicting peer dependency: eslint-plugin-vue@7.20.0 t projectnpm ERR!npm ERR! Fix the upstream dependency conflict, or retrynpm ERR! this command with --force, or --legacy-peer-depsnpm ERR! to accept an incorrect (and potentially broken) dependency resolution.npm ERR!npm ERR! See C:\\Users\\danxibao\\AppData\\Local\\npm-cache\\eresolve-report.txt for a full report.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\danxibao\\AppData\\Local\\npm-cache\\_logs\\2022-05-29T07_02_09_565Z-debug-0.log 解决： npm下载时在最后加上：–legacy-peer-deps 在很多情况下，npm版本问题会导致下载冲突，从而中断安装过程。 –legacy-peer-deps标志是在v7中引入的，目的是绕过peerDependency自动安装；它告诉 NPM 忽略项目中引入的各个modules之间的相同modules但不同版本的问题并继续安装，保证各个引入的依赖之间对自身所使用的不同版本modules共存。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://ran-up.github.io/categories/Vue/"}],"tags":[{"name":"npm报错","slug":"npm报错","permalink":"http://ran-up.github.io/tags/npm%E6%8A%A5%E9%94%99/"}]},{"title":"搭建vue2","slug":"Vue/搭建vue2项目","date":"2023-01-12T13:03:44.000Z","updated":"2024-12-27T17:38:35.760Z","comments":true,"path":"2023/01/12/Vue/搭建vue2项目/","link":"","permalink":"http://ran-up.github.io/2023/01/12/Vue/%E6%90%AD%E5%BB%BAvue2%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"安装脚手架使用安装命令安装脚手架 $ npm install -g @vue/cli# 或者$ yarn global add @vue/cli 安装后可以使用这个命令检查其版本是否正确： $ vue --version 安装项目脚手架安装好后就可以执行安装命令进行项目安装了 其中的 vue-cli 是项目名称，可以自行更改$ vue create vue-cli 选择配置并安装看个人需求选择，这里我需要vue2，所以选择的Default ([Vue 2] babel, eslint) 选择默认配置这里先选择默认配置 Default ([Vue 2] babel, eslint) ，选择之后，按回车键就会进入安装过程 进入项目输入图片中最后的两行命令中的第一条 $ cd 项目名 运行输入图片中最后的两行命令中的最后一条 $ yarn serve 手动配置如果你是选择的 Manually select features 这个是手动配置。 通过键盘 上↑下↓ 键可以上下移动活动光标，空格选中&#x2F;取消，回车完成，选择完后直接回车。 这里我选择了：Babel, Router, CSS Pre-processors, Linter ? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)( ) Babel //转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。 ( ) TypeScript// TypeScript是一个JavaScript（后缀.js）的超集（后缀.ts）包含并扩展了 JavaScript 的语法，需要被编译输出为 JavaScript在浏览器运行，目前较少人再用( ) Progressive Web App (PWA) Support// 渐进式Web应用程序( ) Router // vue-router（vue路由）( ) Vuex // vuex（vue的状态管理模式）( ) CSS Pre-processors // CSS 预处理器（如：less、sass）( ) Linter / Formatter // 代码风格检查和格式化（如：ESlint）( ) Unit Testing // 单元测试（unit tests）( ) E2E Testing // e2e（end to end） 测试 选择完后按回车，会让你继续选择 vue 版本，默认选中vue3，这里我改成了vue2 回车进行安装后，会提示你是否 使用 history 模式路由 Use history mode for router? (Requires proper server setup for index fallback in production) (Y&#x2F;n) 这里我们选择确认即可，确认之后进行后续配置。 选择css 预处理器（Sass&#x2F;SCSS）： 选择eslint 配置（ESLint + Standard config）： 选择什么时候执行eslint校验（Lint on save）： 如何存放配置: 我选In package.json 我都统一集成在package.json文件 是否将之前的设置保存为一个预设模板（n）：不保存配置。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://ran-up.github.io/categories/Vue/"}],"tags":[{"name":"vue2","slug":"vue2","permalink":"http://ran-up.github.io/tags/vue2/"}]},{"title":"你所不知道的el-table表格设置","slug":"使用某些库所得到的知识点/ElementUI/你所不知道的el-table表格设置","date":"2023-01-09T07:34:12.000Z","updated":"2024-12-27T17:38:35.764Z","comments":true,"path":"2023/01/09/使用某些库所得到的知识点/ElementUI/你所不知道的el-table表格设置/","link":"","permalink":"http://ran-up.github.io/2023/01/09/%E4%BD%BF%E7%94%A8%E6%9F%90%E4%BA%9B%E5%BA%93%E6%89%80%E5%BE%97%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/ElementUI/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84el-table%E8%A1%A8%E6%A0%BC%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"el-empty当我们使用 el-button 时，如果表格中没有数据，就会显示：暂无数据 这样不是很具体，暂无什么数据呢？那我们可以不可以自定义设个内容呢？ 是可以的，我们可以使用 el-empty 来自定义当表格中没有内容时，所提示的文字。 使用方法： el-empty 标签 description：无数据时的提示信息 slot: 需要设置为 empty 才能在表格数据为空时显示 然后官网说也可以使用 empty-text，但是这个没弄懂怎么用，等我在研究研究，或者知道的大哥留留言，感谢。 &lt;!-- 方法1 --&gt;&lt;el-empty description=&quot;您搜索的数据不存在&quot; slot=&quot;empty&quot;&gt;&lt;/el-empty&gt;&lt;!-- 方法2 --&gt;&lt;template slot=&quot;empty&quot;&gt; 您搜索的数据不存在&lt;/template&gt;&lt;!-- 方法3 --&gt;&lt;template v-slot:empty&gt; 您搜索的数据不存在&lt;/template&gt;","categories":[{"name":"ElementUI","slug":"ElementUI","permalink":"http://ran-up.github.io/categories/ElementUI/"}],"tags":[{"name":"el-table","slug":"el-table","permalink":"http://ran-up.github.io/tags/el-table/"}]},{"title":"软件的快捷键","slug":"软件/软件的快捷键","date":"2023-01-06T09:43:24.000Z","updated":"2024-12-27T17:38:35.770Z","comments":true,"path":"2023/01/06/软件/软件的快捷键/","link":"","permalink":"http://ran-up.github.io/2023/01/06/%E8%BD%AF%E4%BB%B6/%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"VScode 选择多个重复单词：Ctrl + F2 (Mac: command + F2) 重复的行(复制)： Shift + Alt + 向下箭头 (Mac: command + Shift + 向下箭头) 光标放在文本中，按 ctrl+v 写 md 文档实现实时预览：Ctrl + Shift + P，在出现界面输入 mark，在出现的下拉项中选择“Open Preview to the side” 选择多行输入&#x2F;修改数据：按住 alt，用鼠标左键点击，可以出现多个光标，输入的代码可以在光标处同时增加。（光标可以不在同一列） 折叠所有区域代码：Ctrl + k Ctrl + 0 (先后按) 展开多有区域代码：Ctrl + k Ctrl + j (先后按) 去掉 vscode 当中烦人的非必要的代码提示： 打开设置，输入 editor.snippetSuggestions 选择 none 或者 bottom 就可以将这些代码提示隐藏 或 放在最后面 如果设置了 none ，那自己设置的 用户代码块就没有用了 去掉 vscode 当中烦人的 abc 文字提示 打开设置，输入 Word Based Suggestions 取消复选框的勾选即可 预览.md 文件：ctrl+shift+v 搜索内容： 单个文件内：ctrl + f 全部文件：ctrl + shift + f 替换： 单个文件内：ctrl + h 全部文件：ctrl + shift + h 搜索某个文件：chtrl + p HBuilder 选中两个重复词：ctrl+d 选择多行输入&#x2F;修改数据：ctrl+鼠标点击 phpstrom 复制此行内容：ctrl+d 选中多个重复词：ctrl+alt+shift+j 跳转到某个函数或属性：ctrl+鼠标单击 WPS.pdf 文件 画某部分的背景色(类似划线)：ctrl+F2 下划线：ctrl+5 删除下划线或背景色：delete 文本框：ctrl+F3 删除线：ctrl+d 箭头：alt+2 （1-4 都可以） Chrome 删除输入框历史输入：ctrl + shift + delete","categories":[{"name":"软件","slug":"软件","permalink":"http://ran-up.github.io/categories/%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"快捷键","slug":"快捷键","permalink":"http://ran-up.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}]},{"title":"观看Promise相关视频笔记","slug":"看到视频/文章的笔记(杂记)/观看Promise相关视频笔记","date":"2023-01-02T14:15:45.000Z","updated":"2024-12-27T17:38:35.769Z","comments":true,"path":"2023/01/02/看到视频/文章的笔记(杂记)/观看Promise相关视频笔记/","link":"","permalink":"http://ran-up.github.io/2023/01/02/%E7%9C%8B%E5%88%B0%E8%A7%86%E9%A2%91/%E6%96%87%E7%AB%A0%E7%9A%84%E7%AC%94%E8%AE%B0(%E6%9D%82%E8%AE%B0)/%E8%A7%82%E7%9C%8BPromise%E7%9B%B8%E5%85%B3%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/","excerpt":"","text":"善用Promise.all()下面这种会打破两个函数的并行，第二个任务会等到第一个任务结束才去执行。 async function hh() &#123; const a = await aa() const b = await bb()&#125; 我们可以使用 Promise.all() 包裹： async function hh() &#123; const promiseA = aa() const promiseB = bb() const [a, b] = await Promise.all([promiseA, promiseB])&#125; 循环中的异步我们不能在 forEach map 等中去执行异步操作。即使我们在其中使用了 await&#x2F;async ，它也不会暂停等所有的异步操作都执行完毕。 function hh() &#123; [1, 2, 3].forEach(async item =&gt; &#123; await getData() &#125;)&#125; 如果我们想要等待异步操作都完成后才返回，则可以使用传统的for循环： async function hh() &#123; for (let i of [1, 2, 3]) &#123; await getData() &#125;&#125; 如果我们还想循环中的所有异步操作都是并发执行，则可以使用 async function hh() &#123; const promises = [ promiseA(), promiseB(), promiseC() ] for await (let i of promises) &#123; &#125;&#125;","categories":[{"name":"看视频/文章笔记","slug":"看视频-文章笔记","permalink":"http://ran-up.github.io/categories/%E7%9C%8B%E8%A7%86%E9%A2%91-%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://ran-up.github.io/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"观看渡一web前端大师课笔记","slug":"看到视频/文章的笔记(杂记)/观看渡一web前端大师课笔记","date":"2022-12-31T13:40:57.000Z","updated":"2024-12-27T17:38:35.769Z","comments":true,"path":"2022/12/31/看到视频/文章的笔记(杂记)/观看渡一web前端大师课笔记/","link":"","permalink":"http://ran-up.github.io/2022/12/31/%E7%9C%8B%E5%88%B0%E8%A7%86%E9%A2%91/%E6%96%87%E7%AB%A0%E7%9A%84%E7%AC%94%E8%AE%B0(%E6%9D%82%E8%AE%B0)/%E8%A7%82%E7%9C%8B%E6%B8%A1%E4%B8%80web%E5%89%8D%E7%AB%AF%E5%A4%A7%E5%B8%88%E8%AF%BE%E7%AC%94%E8%AE%B0/","excerpt":"","text":"icon图标说不建议将favicon.ico图标放在根路径，可以使用： &lt;link rel=&quot;shortcut icon&quot; href=&quot;路径/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt; href 中放存放 favicon.ico 的路径就可以了。 快捷方式：输入 link:favicon 就会有提示，然后回车就行了。 乱序假文输入: lorem 比如：lorem*3 就会生成3个乱序假文 重构我们使用某些属性时，会引发网页的重构。 比如说：margin padding 等等 而这类位移有时候又是比不可免的，这时候我们可以使用css3中的一个属性：transform 比如： 1.要移动：transform: translate(10px, 10px); translateY(); trnaslateX(); 2.要放大字体：transform: scale(); js添加类名我所知道的使用JavaScript添加类名是： p.className = &#x27;active&#x27; 而老师说还有一种： p.classList.add(&#x27;active&#x27;)p.classList.remove(&#x27;active&#x27;)p.classList.replace(&quot;foo&quot;, &quot;bar&quot;) // 将类foo替换成类barp.classList.toggle(&#x27;active&#x27;) // 如果active类存在则移除，否则添加 上面的类的内容可以去 MDN看classList。","categories":[{"name":"看视频/文章笔记","slug":"看视频-文章笔记","permalink":"http://ran-up.github.io/categories/%E7%9C%8B%E8%A7%86%E9%A2%91-%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://ran-up.github.io/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"字符串相关","slug":"JavaScript/字符串相关","date":"2022-12-01T04:20:54.000Z","updated":"2024-12-27T17:38:35.757Z","comments":true,"path":"2022/12/01/JavaScript/字符串相关/","link":"","permalink":"http://ran-up.github.io/2022/12/01/JavaScript/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/","excerpt":"","text":"原生charAt() 返回给定索引位置的字符。 友情提示，索引从0开始的。 let msg = &quot;abcd&quot;;console.log(msg.charAt(2)); // &quot;c&quot; charCodeAt() 查看指定码元的字符编码。 如果想把很多的字符都正确的转换为对应的码点，那可以使用 codePointAt() let msg = &quot;abcd&quot;;console.log(msg.charCodeAt(2)); // 99 codePointAt() 接收 16 位码元的索引并返回该索引位置上的码点。 下面的是将 “ab😊d” 字符串转换为字符编码，对比了 charAt()、charCodeAt()、codePointAt()，后面两个可以把这个字符串转化为对应的字符编码，但 charAt() 不行。 这里要注意：不能输成 “ab☺d”，这玩意上面三个都能实现。 但《JavaScript高级开发》第四版上说 charCodeAt() 不行，猜测可能是浏览器进行了设置。 let msg = &quot;ab😊d&quot;;console.log(msg.charAt(0)); // aconsole.log(msg.charAt(1)); // b console.log(msg.charAt(2)); // ?console.log(msg.charAt(3)); // ? console.log(msg.charAt(4)); // econsole.log(msg.charCodeAt(0)); // 97 console.log(msg.charCodeAt(1)); // 98 console.log(msg.charCodeAt(2)); // 55357console.log(msg.charCodeAt(3)); // 56842console.log(msg.charCodeAt(4)); // 100console.log(msg.codePointAt(0)); // 97 console.log(msg.codePointAt(1)); // 98 console.log(msg.codePointAt(2)); // 55357 console.log(msg.codePointAt(3)); // 56842 console.log(msg.codePointAt(4)); // 100 fromCharCode() 根据给定的 UTF-16 码点返回对应字符。 可以接收多个值，将其拼接成一个字符串。 如果想把很多的码点都正确的转换为对应的字符，那可以使用 fromCodePoint() console.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64)); // &quot;abcd&quot; fromCodePoint() 接收任意的码点，返回对应字符。 可以接收多个值，将其拼接成一个字符串。 console.log(String.fromCharCode(97, 98, 55357, 56842, 100)); // ab😊dconsole.log(String.fromCodePoint(97, 98, 128522, 100)); // ab😊d normalize() 4种”NFD”、”NFC”、”NFKD”或”NFKC”。 // 未使用规范let a1 = String.fromCharCode(0x00C5), a2 = String.fromCharCode(0x212B), a3 = String.fromCharCode(0x0041, 0x030A); // U+00C5 是对 0+212B 进行 NFC/NFKC 规范化之后的结果console.log(a1 === a1.normalize(&quot;NFD&quot;)); // false console.log(a1 === a1.normalize(&quot;NFC&quot;)); // true console.log(a1 === a1.normalize(&quot;NFKD&quot;)); // false console.log(a1 === a1.normalize(&quot;NFKC&quot;)); // true // U+212B 是未规范化的console.log(a2 === a2.normalize(&quot;NFD&quot;)); // false console.log(a2 === a2.normalize(&quot;NFC&quot;)); // false console.log(a2 === a2.normalize(&quot;NFKD&quot;)); // false console.log(a2 === a2.normalize(&quot;NFKC&quot;)); // false // U+0041/U+030A 是对 0+212B 进行 NFD/NFKD 规范化之后的结果console.log(a3 === a3.normalize(&quot;NFD&quot;)); // true console.log(a3 === a3.normalize(&quot;NFC&quot;)); // false console.log(a3 === a3.normalize(&quot;NFKD&quot;)); // true console.log(a3 === a3.normalize(&quot;NFKC&quot;)); // false// 使用规范let a1 = String.fromCharCode(0x00C5), a2 = String.fromCharCode(0x212B), a3 = String.fromCharCode(0x0041, 0x030A); console.log(a1.normalize(&quot;NFD&quot;) === a2.normalize(&quot;NFD&quot;)); // true console.log(a2.normalize(&quot;NFKC&quot;) === a3.normalize(&quot;NFKC&quot;)); // true console.log(a1.normalize(&quot;NFC&quot;) === a3.normalize(&quot;NFC&quot;)); // true concat() 将一个或多个字符串拼接成一个新字符串。 接收一或两个参数，省略第二个参数都意味着提取到字符串末尾。 不修改原数据。 slice() 从字符串中提取子字符串。 接收一或两个参数，省略第二个参数都意味着提取到字符串末尾。 不修改原数据。 将所有负值参数都当成字符串长度加上负参数值。 substr() 从字符串中提取子字符串。 接收一或两个参数，省略第二个参数都意味着提取到字符串末尾。 不修改原数据。 将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0。 substring() 从字符串中提取子字符串。 接收一或两个参数，省略第二个参数都意味着提取到字符串末尾。 不修改原数据。 将所有负值参数都当成字符串长度加上负参数值。 indexOf() 从字符串开头开始查找子字符串，并返回位置（如果没找到，则返回-1）。 lastIndexOf() 从字符串末尾开始查找子字符串，并返回位置（如果没找到，则返回-1）。 startsWith() 检测字符串中是否包含另一个字符串。 从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。 可选的第二个参数，表示开始搜索的位置。则指：从指定位置向着字符串末尾搜索。 const msg = &quot;foobarbaz&quot;;console.log(msg.startsWith(&quot;foo&quot;)); // true console.log(msg.startsWith(&quot;bar&quot;)); // falseconsole.log(msg.startsWith(&quot;foo&quot;, 1)); // false endsWith() 检测字符串中是否包含另一个字符串。 从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。 可选的第二个参数，表示应该当作字符串末尾的位置。如 const msg = &quot;foobarbaz&quot;;console.log(msg.endsWith(&quot;baz&quot;)); // true console.log(msg.endsWith(&quot;bar&quot;)); // false console.log(message.endsWith(&quot;bar&quot;, 6)); // true includes() 检测字符串中是否包含另一个字符串。 从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。 可选的第二个参数，表示开始搜索的位置。则指：从指定位置向着字符串末尾搜索。 const msg = &quot;foobarbaz&quot;;console.log(msg.includes(&quot;bar&quot;)); // true console.log(msg.includes(&quot;aaa&quot;)); // falseconsole.log(msg.includes(&quot;bar&quot;, 4)); // false trim() 删除前、后所有空格符，再返回结果。 const msg = &quot; hello &quot;;console.log(msg.trim()) // &quot;hello&quot; trimLeft() 和 trimRight()方法分别用于从字符串开始和末尾清理空格符。 repeat() 接收一个整数参数，将字符串复制多少次，然后返回拼接所有副本后的结果。 const msg = &quot;hello&quot;;console.log(msg.repeat(5)) // &quot;hellohellohellohellohello&quot; padStart() 和 padEnd() 复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。 第一个参数是长度，第二个参数是可选的填充字符串，默认为空格。 浏览器上没效果。 toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase() toLocaleLowerCase()和 toLocaleUpperCase()方法旨在基于特定地区实现。在不知道代码设计什么语言时使用。 localeCompare() 比较两个字符串。 相等返回0，字符串比字符串参数小返回-1，字符串比字符串参数大返回1。 let stringValue = &quot;yellow&quot;; console.log(stringValue.localeCompare(&quot;brick&quot;)); // 1 console.log(stringValue.localeCompare(&quot;yellow&quot;)); // 0 console.log(stringValue.localeCompare(&quot;zoo&quot;)); // -1","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/categories/JavaScript/"}],"tags":[{"name":"杂糅","slug":"杂糅","permalink":"http://ran-up.github.io/tags/%E6%9D%82%E7%B3%85/"}]},{"title":"数值相关","slug":"JavaScript/数值相关","date":"2022-12-01T04:20:54.000Z","updated":"2024-12-27T17:38:35.757Z","comments":true,"path":"2022/12/01/JavaScript/数值相关/","link":"","permalink":"http://ran-up.github.io/2022/12/01/JavaScript/%E6%95%B0%E5%80%BC%E7%9B%B8%E5%85%B3/","excerpt":"","text":"原生parseInt()parseFloat()isFinite()isNaN()toFixed() 返回包含指定小数点位数的数值字符串。 接收一个参数，表示结果中小数的位数。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位。 let num = 10; console.log(num.toFixed(2)); // &quot;10.00&quot; toExponential() 返回以科学记数法（也称为指数记数法）表示的数值字符串。 接收一个参数，表示结果中小数的位数。 let num = 10; console.log(num.toExponential(1)); // &quot;1.0e+1&quot; toPrecision() 会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法。 接收一个参数，表示结果中数字的总位数（不包含指数）。 toPrecision()方法会根据数值和精度来决定调用 toFixed()还是 toExponential()。 let num = 88;console.log(num.toPrecision(1)); // &quot;9e+2&quot; console.log(num.toPrecision(2)); // &quot;88&quot; console.log(num.toPrecision(3)); // &quot;88.0&quot; Number.isInteger() 辨别一个数值是否保存为整数。 console.log(Number.isInteger(1)); // true console.log(Number.isInteger(1.00)); // true console.log(Number.isInteger(1.1)); // false Number.isSafeInteger() 鉴别整数是否在-2^53 + 1到2^53-1这个范围内，左闭右闭。 console.log(Number.isSafeInteger(-1 * (2 ** 53))); // false console.log(Number.isSafeInteger(-1 * (2 ** 53) + 1)); // true console.log(Number.isSafeInteger(-1 * (2 ** 50))); // true console.log(Number.isSafeInteger(2 ** 53)); // false console.log(Number.isSafeInteger((2 ** 53) - 1)); // trueconsole.log(Number.isSafeInteger((2 ** 50))); // true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/categories/JavaScript/"}],"tags":[{"name":"杂糅","slug":"杂糅","permalink":"http://ran-up.github.io/tags/%E6%9D%82%E7%B3%85/"}]},{"title":"正则表达式笔记","slug":"JavaScript/正则表达式笔记","date":"2022-12-01T04:20:54.000Z","updated":"2024-12-27T17:38:35.758Z","comments":true,"path":"2022/12/01/JavaScript/正则表达式笔记/","link":"","permalink":"http://ran-up.github.io/2022/12/01/JavaScript/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/","excerpt":"","text":"基础字面量形式定义: &#x2F;正则&#x2F;使用 RegExp 构造函数：new Regexp(正则) RegExp 的两个参数都是字符串。 全局模式 – g 忽略大小写 – i 查找其中的某个 – []，如&#x2F;[ab]c&#x2F;，查找ac或bc RegExp()方法： exec() exec()属性： index：字符串中匹配模式的起始位置 input：要查找的字符串 let text = &quot;cat, bat, sat, fat&quot;;let pattern = /.at/g;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches[0]); // cat 返回第一个匹配项console.log(pattern.lastIndex); // 3 如果在后面再调用 exec() 那么输出的数据就会发送改变。因为在这个模式上设置了 g 标记，所以每次调用 exec()都会在字符串中向前搜索下一个匹配项。 matches = pattern.exec(text);console.log(matches.index); // 5console.log(matches[0]); // bat 返回第一个匹配项console.log(pattern.lastIndex); // 8","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/categories/JavaScript/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://ran-up.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"微信小程序常用知识点","slug":"微信小程序/微信小程序常用知识点","date":"2022-11-26T09:08:27.000Z","updated":"2024-12-27T17:38:35.768Z","comments":true,"path":"2022/11/26/微信小程序/微信小程序常用知识点/","link":"","permalink":"http://ran-up.github.io/2022/11/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"方法点击事件使用bindtap=&quot;xxx&quot;，xxx为方法名 &lt;button bindtap=&quot;loginBtn&quot;&gt;点击登录&lt;/button&gt;","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://ran-up.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"常用知识点","slug":"常用知识点","permalink":"http://ran-up.github.io/tags/%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"tabBar跳转失败+颜色双击才改变","slug":"微信小程序/微信小程序tabBar跳转问题","date":"2022-11-26T06:02:26.000Z","updated":"2024-12-27T17:38:35.767Z","comments":true,"path":"2022/11/26/微信小程序/微信小程序tabBar跳转问题/","link":"","permalink":"http://ran-up.github.io/2022/11/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FtabBar%E8%B7%B3%E8%BD%AC%E9%97%AE%E9%A2%98/","excerpt":"","text":"tabBar跳转失败昨天将效果做出来了，然后今天做页面的时候，突然发现页面不能进行切换，原来是压根没有设置，看了官网，应该使用 wx.switchTab() 进行tabbar的跳转。 按照官网的方法进行了配置，但是页面并未跳转，控制台输出的错误是： 我的custom-tab-bar文件夹中的index.js中的代码是： // pages/custom-tab-bar/index.jsComponent(&#123; data: &#123; active: 0, &quot;list&quot;: [ &#123; &quot;pagePath&quot;: &quot;/pages/shou/shou&quot;, &quot;iconPath&quot;: &quot;/images/tabbar/shou.png&quot;, &quot;selectedIconPath&quot;: &quot;/images/tabbar/shou1.png&quot;, &quot;text&quot;: &quot;首页&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;/pages/gou/gou&quot;, &quot;iconPath&quot;: &quot;/images/tabbar/gou.png&quot;, &quot;selectedIconPath&quot;: &quot;/images/tabbar/gou1.png&quot;, &quot;text&quot;: &quot;收购&quot; &#125;]&#125;, methods: &#123; onChange(event) &#123; // event.detail 的值为当前选中项的索引 let index = event.detail // 切换tabBar switch(index)&#123; case 0: wx.switchTab(&#123; url: &quot;../pages/shou/shou&quot; &#125;); break; case 1: wx.switchTab(&#123; url: &quot;../pages/gou/gou&quot;, &#125;); break; &#125; this.setData(&#123;active: index&#125;) &#125;,&#125;,&#125;) 错误的原因是路径不对。 然后我就去掉了前面方法中路径前的**..**，奇迹的事情发生了，点击可以实现跳转了。 methods: &#123; onChange(event) &#123; // event.detail 的值为当前选中项的索引 let index = event.detail // 切换tabBar switch(index)&#123; case 0: wx.switchTab(&#123; url: &quot;/pages/shou/shou&quot; &#125;); break; case 1: wx.switchTab(&#123; url: &quot;/pages/gou/gou&quot;, &#125;); break; &#125; this.setData(&#123;active: index&#125;) &#125;&#125; 颜色双击才改变然后有出现了一个新的问题，那就是，点击可以跳转了，但是颜色会点击两次才显示。 这个的问题其实官方说了的，然后我们也可以去官网的自定义tabBar看。 如上如，官网是这么说的，然后我看了它的示例代码，发现其中有一个这样的代码： onShow: function () &#123; if (typeof this.getTabBar === &#x27;function&#x27; &amp;&amp; this.getTabBar()) &#123; this.getTabBar().setData(&#123; active: 1 // 这里是放每个tabbar的索引值 // 第一个是0 // 第二个是1 // 以此类推 &#125;) &#125;&#125;, 我们需要在每个tabbar文件夹中的 .js 都添加上这些代码！！！ 然后你就可以实现页面切换和颜色的切换同步了。 展示下我的代码： custom-tab-bar&#x2F;index.js Component(&#123; data: &#123; active: 0, &quot;list&quot;: [ &#123; &quot;pagePath&quot;: &quot;/pages/shou/shou&quot;, &quot;iconPath&quot;: &quot;/images/tabbar/shou.png&quot;, &quot;selectedIconPath&quot;: &quot;/images/tabbar/shou1.png&quot;, &quot;text&quot;: &quot;首页&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;/pages/gou/gou&quot;, &quot;iconPath&quot;: &quot;/images/tabbar/gou.png&quot;, &quot;selectedIconPath&quot;: &quot;/images/tabbar/gou1.png&quot;, &quot;text&quot;: &quot;收购&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;/pages/fa/fa&quot;, &quot;iconPath&quot;: &quot;/images/tabbar/fa.png&quot;, &quot;selectedIconPath&quot;: &quot;/images/tabbar/fa.png&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;/pages/xiao/xiao&quot;, &quot;iconPath&quot;: &quot;/images/tabbar/xiao.png&quot;, &quot;selectedIconPath&quot;: &quot;/images/tabbar/xiao1.png&quot;, &quot;text&quot;: &quot;消息&quot;, &quot;info&quot;:1 &#125;, &#123; &quot;pagePath&quot;: &quot;/pages/wo/wo&quot;, &quot;iconPath&quot;: &quot;/images/tabbar/wo.png&quot;, &quot;selectedIconPath&quot;: &quot;/images/tabbar/wo1.png&quot;, &quot;text&quot;: &quot;我的&quot; &#125;]&#125;, methods: &#123; onChange(event) &#123; // event.detail 的值为当前选中项的索引 let index = event.detail // 切换tabBar switch(index)&#123; case 0: wx.switchTab(&#123; url: &quot;/pages/shou/shou&quot; &#125;); break; case 1: wx.switchTab(&#123; url: &quot;/pages/gou/gou&quot;, &#125;); break; case 2: wx.switchTab(&#123; url: &quot;/pages/fa/fa&quot; &#125;); break; case 3: wx.switchTab(&#123; url: &quot;/pages/xiao/xiao&quot; &#125;); break; case 4: wx.switchTab(&#123; url: &quot;/pages/wo/wo&quot; &#125;); break; &#125; // 这时候会发现需要点击两次才能改变tabBar的颜色 // 解决办法是去每个tabbar页面加一些代码（官网也说了的） // https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html // 加了上面的代码之后，下面这一行代码就没必要了 // 但通常还是会留着 this.setData(&#123;active: index&#125;) &#125;,&#125;,&#125;) custom-tab-bar&#x2F;index.wxml &lt;van-tabbar class=&quot;vantTabbar&quot; active=&quot;&#123;&#123; active &#125;&#125;&quot; active-color=&quot;#07c160&quot; inactive-color=&quot;#000&quot; bind:change=&quot;onChange&quot;&gt; &lt;van-tabbar-item wx:for=&quot;&#123;&#123;list&#125;&#125;&quot; wx:key=&quot;index&quot; info=&quot;&#123;&#123; item.info ? item.info : &#x27;&#x27;&#125;&#125;&quot;&gt; &lt;image slot=&quot;icon&quot; src=&quot;&#123;&#123; item.iconPath &#125;&#125;&quot; mode=&quot;contain&quot; style=&quot;width: 55rpx; height: 55rpx;&quot; /&gt; &lt;image slot=&quot;icon-active&quot; src=&quot;&#123;&#123; item.selectedIconPath &#125;&#125;&quot; mode=&quot;aspectFit&quot; style=&quot;width: 55rpx; height: 55rpx;&quot; /&gt; &#123;&#123;item.text&#125;&#125; &lt;/van-tabbar-item&gt;&lt;/van-tabbar&gt; custom-tab-bar&#x2F;index.wxss .vantTabbar &#123; display: flex;&#125; gou&#x2F;gou.js // pages/gou/gou.jsPage(&#123; onShow: function () &#123; if (typeof this.getTabBar === &#x27;function&#x27; &amp;&amp; this.getTabBar()) &#123; this.getTabBar().setData(&#123; active: 1 &#125;) &#125; &#125;,&#125;) shou&#x2F;shou.js Page(&#123; onShow: function () &#123; if (typeof this.getTabBar === &#x27;function&#x27; &amp;&amp; this.getTabBar()) &#123; this.getTabBar().setData(&#123; active: 0 &#125;) &#125; &#125;,&#125;)","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://ran-up.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序tabBar跳转问题","slug":"微信小程序tabBar跳转问题","permalink":"http://ran-up.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FtabBar%E8%B7%B3%E8%BD%AC%E9%97%AE%E9%A2%98/"}]},{"title":"微信小程序使用vantweapp问题","slug":"微信小程序/微信小程序使用npm构建问题","date":"2022-11-25T12:39:31.000Z","updated":"2024-12-27T17:38:35.768Z","comments":true,"path":"2022/11/25/微信小程序/微信小程序使用npm构建问题/","link":"","permalink":"http://ran-up.github.io/2022/11/25/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8npm%E6%9E%84%E5%BB%BA%E9%97%AE%E9%A2%98/","excerpt":"","text":"构建错误今天用微信小程序配合 Vant Weapp 时遇到了一些问题。 就是在【构建npm】时一直不成功，错误是： 导致这样的原因是，先安装的第三方包，然后再进行的初始化。 解决办法就是，先初始化，然后再安装第三方包，就可以了。 也就是顺序是： 初始化：npm init，连续回车就行 – 生成 package.json 安装第三方包：npm i vant-weapp -S --production – 自动生成 node_modules文件夹 修改 app.json：将 app.json 中的 “style”: “v2” 去除 修改 project.config.json： &#123; ... &quot;setting&quot;: &#123; ... &quot;packNpmManually&quot;: true, &quot;packNpmRelationList&quot;: [ &#123; &quot;packageJsonPath&quot;: &quot;./package.json&quot;, &quot;miniprogramNpmDistDir&quot;: &quot;./miniprogram/&quot; &#125; ] &#125;&#125; 构建npm：工具 -&gt; 构建 npm 注意：需要在小程序根目录下执行 npm init 这几步缺一不可，不然就不能使用 vant Weapp 中的组件了。 其中的2-3步可以去官网看。 路径错误如果你按照 Vant Weapp 官网的方法使用某个组件，路径什么的，代码什么的都没错，但就是报错，还是路径错误。比如： 这个时候其实就是自己的操作问题（我目前遇到的是，现在是2022.11.25），时间久了问题会变，这个操作不能保证一定能解决问题。不过可以试试。 — 就是没有在工具中构建npm 如果你完全按照上面的步骤来实现npm的建构的话，那会生成一个文件夹，如下： 如果没有的话，就将 package.json 文件和 node_modules文件夹 都删除了，之后重新按照上面的步骤构建npm，切记最后不要忘记再次在工具中构建npm。 因为，不构建npm，就不会生成 miniprogram_npm 文件夹，也就会路径报错了。","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://ran-up.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"vantweapp问题","slug":"vantweapp问题","permalink":"http://ran-up.github.io/tags/vantweapp%E9%97%AE%E9%A2%98/"}]},{"title":"微信小程序云开发指南","slug":"微信小程序/微信小程序云开发指南","date":"2022-11-17T12:14:19.000Z","updated":"2024-12-27T17:38:35.767Z","comments":true,"path":"2022/11/17/微信小程序/微信小程序云开发指南/","link":"","permalink":"http://ran-up.github.io/2022/11/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/","excerpt":"","text":"创建项目项目名和文件夹最好是英文的，如果是中文的，可能后面会乱码。 AppID，在微信公众号官网可以申请。 勾选微信云开发、左下方的我已阅读并同意。 模板看你情况，一般设置为云开发-基础模板。 最后点击确定按钮即可。 创建云环境初次进行云开发，进入到开发界面，会显示一个【已创建云环境】 点击【云开发】可以创建云开发环境。 选择环境如果cloudfunctions文件夹显示未选择环境，那么可以单机鼠标右键选择【当前环境】，进行环境的选择。","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://ran-up.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"云开发使用概括","slug":"云开发使用概括","permalink":"http://ran-up.github.io/tags/%E4%BA%91%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E6%A6%82%E6%8B%AC/"}]},{"title":"了解vue的插槽","slug":"Vue/了解vue的插槽","date":"2022-11-09T13:26:06.000Z","updated":"2024-12-27T17:38:35.759Z","comments":true,"path":"2022/11/09/Vue/了解vue的插槽/","link":"","permalink":"http://ran-up.github.io/2022/11/09/Vue/%E4%BA%86%E8%A7%A3vue%E7%9A%84%E6%8F%92%E6%A7%BD/","excerpt":"","text":"基础概念插槽一般是在子组件中设置一个坑，这个坑就是插槽，在父组件中设置内容，将此内容插入到插槽中。 插槽有三种： 单个插槽 具名插槽 作用域插槽 单个插槽就是子组件中设置了一个单一的插槽。 &lt;!-- Child.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;Child&gt; &lt;span&gt;我是一个单一插槽&lt;/span&gt; &lt;/Child&gt; &lt;/div&gt;&lt;/template&gt; 具名插槽上面是比较单一的，每个插槽的内容都是一样的，如果我们想要给不同的插槽都设置不同的内容，那么，我们就可以给插槽定义一个名字：name&#x3D;”xxx”，然后在父组件中使用 template 包裹内容，并添加 v-slot:xxx 属性来将内容指定给相应的插槽。 &lt;!-- Child.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;Child&gt; &lt;template v-slot:header&gt; &lt;span&gt;我是头部&lt;/span&gt; &lt;/template&gt; &lt;!-- &lt;template v-slot:default&gt; --&gt; &lt;template&gt; &lt;span&gt;我是主体&lt;/span&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;span&gt;我是尾部&lt;/span&gt; &lt;/template&gt; &lt;/Child&gt; &lt;/div&gt;&lt;/template&gt; 现在 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 v-slot 的 中的内容都会被视为默认插槽的内容。 然而，如果你希望更明确一些，仍然可以在一个 中包裹默认插槽的内容。 上面的 v-slot 属性是 2.6.0+ 的属性，之前的属性被废除了，但是还可以使用。 可能你在一些以vue2搭建的项目时，还是会看到就属性，所以在这里简单介绍一下. 我们可以使用 slot&#x3D;”xxx” 将 template 中的 v-slot 属性。 &lt;template&gt; &lt;div&gt; &lt;Child&gt; &lt;template slot=&quot;header&quot;&gt; &lt;span&gt;我是头部&lt;/span&gt; &lt;/template&gt; &lt;template&gt; &lt;span&gt;我是主体&lt;/span&gt; &lt;/template&gt; &lt;template slot=&quot;footer&quot;&gt; &lt;span&gt;我是尾部&lt;/span&gt; &lt;/template&gt; &lt;/Child&gt; &lt;/div&gt;&lt;/template&gt; 作用域插槽前两种的插槽都是不能访问到子组件的数据的，那么有时候我们需要传递一个数据，比如一个链接时，那该怎么办呢，用vuex吗？这就太浪费性能了。 所以说，作用域插槽就出来了，方便我们使用子组件的数据。 &lt;!-- Child.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;slot :url=&quot;url&quot;&gt;我是头部&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; url: &quot;https://www.baidu.com&quot;, &#125;; &#125;,&#125;;&lt;/script&gt;&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;Child&gt; &lt;template v-slot=&quot;url&quot;&gt; &lt;a :href=&quot;url.url&quot;&gt;这是百度，路径为&#123;&#123; url.url &#125;&#125;&lt;/a&gt; &lt;/template&gt; &lt;/Child&gt; &lt;/div&gt;&lt;/template&gt; 我们也可以使用 ES6 的解构赋值 &lt;Child&gt; &lt;template v-slot=&quot;&#123;url&#125;&quot;&gt; &lt;a :href=&quot;url&quot;&gt;这是百度，路径为&#123;&#123; url &#125;&#125;&lt;/a&gt; &lt;/template&gt;&lt;/Child&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://ran-up.github.io/categories/Vue/"}],"tags":[{"name":"插槽","slug":"插槽","permalink":"http://ran-up.github.io/tags/%E6%8F%92%E6%A7%BD/"}]},{"title":"网上视频不说的css变量设置","slug":"CSS/网上视频不说的css变量设置","date":"2022-10-28T13:43:34.000Z","updated":"2024-12-27T17:38:35.753Z","comments":true,"path":"2022/10/28/CSS/网上视频不说的css变量设置/","link":"","permalink":"http://ran-up.github.io/2022/10/28/CSS/%E7%BD%91%E4%B8%8A%E8%A7%86%E9%A2%91%E4%B8%8D%E8%AF%B4%E7%9A%84css%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"说明有很多css基础视频，都没有讲到css中也可以设置变量。那我是怎么知道的呢？嘿嘿，面试官会给你交流的嘛。 这个学习可以去看MDN，也可以去看阮一峰的博客。 设置变量在css中我们可以使用 -- 两个连续的减号来设置变量，那如何引用呢？我们可以使用 var() 来引用。 不过呢我们设置变量的时候，需要放在规则集里面。通常的最佳实践是定义在根伪类 :root 下，这样就可以在 HTML 文档的任何地方访问到它了。 :root &#123; --bg-color: red;&#125;input &#123; background-color: var(--bg-color);&#125; 上面的代码可以将 input 输入框背景颜色设置为红色。 在css中设置的变量名会大小写敏感的，如果上面写成 --Bg-color，那么它和 --bg-color就是两个不同的变量。 可以放入很多值，比如： :root &#123; --color: red; --bg-color: rgb(255, 255, 255); --height: 68px; --padding: 10px 20px; --duration: .35s; --font-family: &quot;external link&quot;; --margin-top: calc(2vh + 20px);&#125; 这里提醒一下：在css中设置变量是 --，less中是 @，sass 中是$。 获取css变量我们上面已经说到了，读取变量使用 var()。 :root &#123; --bg-color: red;&#125;input &#123; background-color: var(--bg-color);&#125; 我们还可以在变量声明中嵌套声明变量。 :root&#123; --color: red; --bg-color: var(--color);&#125; 我们还可以传入第二个参数，它表示变量的默认值。如果该变量不存在，就会使用这个默认值。 color: var(--bg-color, tomato);padding: var(--padding, 20px 30px);font-family: var(--font-family, &#x27;Courier New&#x27;, Courier, monospace); 可以看到上面的代码中，第二个参数有的是空格、有的是逗号分隔，这是因为第二个参数不会处理他自身的空格和逗号的。 注意：我们设置变量时只能使用变量值，而不能使用变量名。没有效果，也不会报错。 :root &#123; --bg-color: background-color&#125;input &#123; /* 这是没有效果的 */ --bg-color: var(--bg-color, tomato);&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://ran-up.github.io/categories/CSS/"}],"tags":[{"name":"css设置变量","slug":"css设置变量","permalink":"http://ran-up.github.io/tags/css%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F/"}]},{"title":"网络","slug":"前端面试集锦/网络","date":"2022-10-27T02:03:53.000Z","updated":"2024-12-27T17:38:35.767Z","comments":true,"path":"2022/10/27/前端面试集锦/网络/","link":"","permalink":"http://ran-up.github.io/2022/10/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/%E7%BD%91%E7%BB%9C/","excerpt":"","text":"什么是HTTP? HTTP 和 HTTPS 的区别?概念HTTP 是超文本传输协议，默认使用 80 端口，是互联网上应用最为广泛的一种网络协议。是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS：安全超文本传输协议，默认使用 443 端口。简单讲是 HTTP 的安全版，通过 SSL 加密。 区别 HTTP 协议的数据传输是明文的，是不安全的，而 HTTPS 使用了 SSL 进行加密传输。 HTTP 和 HTTPS 的连接方式不同，默认端口也不同，HTTP 是80端口，HTTPS 是443端口。 HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP。 HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费。 为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？因为 HTTPS 使用了 SSL 对内容使用了加密处理，从而保证了传输安全。可以防止数据在传输过程中被监听和被窃取，从而确认网站的真实性。 用了 HTTPS 就一定安全吗？不一定，因为 HTTPS 保证的只是传输过程的安全。但本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。 如何理解 UDP 和 TCP? 区别? 应用场景?UDP 是用户数据包协议，是一个简单的「面向数据报的通信协议」，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层。TCP 是传输控制协议，是一种可靠的、「面向字节流的通信协议」，把上面应用层交下来的数据看成无结构的字节流来发送。 区别 TCP UDP 可靠性 可靠 不可靠 连接性 面向连接 无连接 报文 面向字节流 面向报文 效率 传输效率低 传输效率高 双共性 全双工 一对一、一对多、多对一、多对多 流量控制 滑动窗口 无 拥塞控制 慢开始、拥塞避免、快重传、快恢复 无 传输效率 慢 快 TCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取。TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方。TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用。TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信。 应用场景 http1.0 1.1 2.0的区别 HTTP1.0：默认不支持长连接，需要设置keep-alive参数指定，缓存有一定的缺陷。 HTTP1.1：默认长连接(keep-alive)，http请求可以复用Tcp连接，但同一时间只能对应一个http请求，也就是一个Tcp中http请求时串行的，还对缓存进行了优化。 HTTP2.0：采用二进制格式而非文本格式；能实现多路复用，一个Tcp中多个http请求是并行的；可以将报头数据进行压缩，提高了传输速度；在请求数据时，服务器能主动将一些资源“推送”到客户端中。 状态码 100 - 客户端应继续其请求 101 - 切换协议 200 - 请求成功 201 - 请求成功并创建了新的资源 202 - 已经接受了请求，但还没有处理完成 203 - 非授权信息。 204 - 服务器处理成功，但未返回内容。 205 - 重置内容（清除表单内容） 206 - 部分内容（处理了部分GET请求） 301 - 永久重定向（强制get） 302 - 临时重定向（强制get） 307 - 临时重定向（说了是GET请求的） 400 - 请求错误。 401 - 请求身份验证。（未授权） 403 - 服务器拒绝请求。 404 - 服务器没找到资源。 408 - 超时 500 - 服务器错误 501 - 服务器不支持请求 502 - 网关错误 504 - 网关超时 说一下 GET 和 POST 的区别？ GET参数通过URL传递(以?分隔，参数之间以&amp;相连)，POST放在Request body中。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET请求的数据有大小限制，因为浏览器对url的长度有限制，而POST没有。 GET请求会被浏览器缓存，而POST需要手动设置。 GET一般用于查询，POST一般用于提交对信息修改的操作。 GET在浏览器回退不需要请求，而POST会再次提交请求。 浏览器从输入url到渲染页面，发生了什么？ 缓存查找 浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求； 操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存) 路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存； ISP缓存：若上述均失败，继续向ISP搜索 DNS域名解析 建立TCP连接(三次握手) 发送HTTP请求，服务器处理请求，返回响应结果 浏览器解析渲染页面 解析html，构建DOM树 解析css，构建CSS树 合并DOM树和CSS规则，生成render树 布局render树(Layout&#x2F;reflow)，负责各元素尺寸、位置的计算（样式计算） 绘制render树（paint），绘制页面像素信息 断开连接(四次挥手) 浏览器渲染机制（浏览器绘制过程） 将 HTML 解析构建成 DOM 树 将 CSS 解析构建成 CSS 树（CSSOM） 合并 DOM 树和 CSS 树，生成一棵渲染树 (render) 生成布局（Layout），计算出每个节点在屏幕中的位置 显示（paint）在屏幕上 重新渲染就是重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五步(重新绘制)。 什么是重绘与重排？有什么区别？重排(回流): 当 DOM 的变化影响了元素的几何信息 (DOM 对象的位置和尺寸大小)，导致浏览器需要重新计算时，这个过程叫做重排。表现为重新生成布局，重新排列元素。 重绘：当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。 触发：改变元素的color、background、box-shadow等属性 『重排』必定会发生『重绘』，『重绘』不一定会引发『重排』。重排成本高于重绘。 改变父节点中的子节点也可能导致父节点发生重排。 如何触发重排和重绘？任何改变用来构建渲染树的信息都会导致一次重排或重绘： 添加、删除、更新DOM节点 通过 display: none 隐藏一个DOM节点-触发重排和重绘 通过 visibility: hidden 隐藏一个DOM节点-只触发重绘，因为没有几何变化 移动或者给页面中的DOM节点添加动画 调整样式属性(元素尺寸改变——边距、填充、边框、宽度和高度 ) 用户行为，例如调整窗口大小(resize事件)，改变字号，或者滚动。 内容变化，比如用户在 input 框中输入文字 计算 offsetWidth 和 offsetHeight 属性 如何避免重绘或者重排？ 集中改变样式，不要一条一条地修改 DOM 的样式。 不要把 DOM 结点的属性值放在循环里当成循环里的变量。 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。 不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。 把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM 尽量只修改position：absolute或fixed元素，对其他元素影响不大 动画开始GPU加速，translate使用3D变化。transform 不重绘、不回流，是因为transform属于合成属性，对合成属性进行transition&#x2F;animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧。 提升为合成层将元素提升为合成层有以下优点： 合成层的位图，会交由 GPU 合成，比 CPU 处理要快 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层 对于 transform 和 opacity 效果，不会触发 layout 和 paint提升合成层的最好方式是使用 CSS 的 will-change 属性： #target {will-change: transform; } 浏览器乱码的原因是什么？如何解决？产生乱码的原因：网页中的编码和我们编写代码文字使用的编码不同，或者和数据库导出的文字编码不同；还有就是浏览器检测不到网页的编码，也会出现乱码的情况。 网页是gbk，而代码中的文字是utf-8，反之也会出现乱码； 网页编码是gbk，而数据库导出的文字是utf-8，这样也会造成乱码； 浏览器不能自动检测网页编码，造成网页乱码。 解决办法：如果是编写问题，则在编辑HTML网页时自己设置编码格式；如果是数据库编码问题，则在查询数据库时设置相应的编码格式；如果是浏览器自身问题，则在转换编码的菜单中进行转换。 编辑HTML网页时自己设置编码格式； 如果网页编码是gbk，而数据库数据编码是UTF-8，则查询数据库数据时对程序转码； 如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。 html 规范中为什么要求引用资源不加协议头http或者https？如果使用 http 或 https 协议来浏览，那么网页中的资源也只能通过相应协议来引用，否则就会出现警告信息，而且不同浏览器的警告信息展现形式不同。为了解决这个问题，我们可以省略 URL 的协议声明，无论是使用哪一个协议访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出警告信息，同时还可以节省5字节的数据量。 为什么css放在顶部而js写在后面 浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了。 HTML渲染是一边解析DOM一边渲染，并不会等到完全加载完才渲染页面。 js写在尾部，主要是：一方面是js主要对事件进行处理，很多操作都是在页面渲染后才执行的。另一方面能节省加载时间，提高用户的体验。 但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面 常见的浏览器端的存储技术有哪些？浏览器常见的存储技术有 cookie、localStorage 和 sessionStorage。 还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。 IE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ 它们都存储在客户端，但 cookie 的数据会自动传递到服务器。（同源的http请求中携带） 大小限制不同；cookie 数据大小不能超过4k；sessionStorage 和 localStorage 的存储比 cookie 大得多，可以达到5M。 数据有效期不同；cookie 在过期时间之前一直有效，即使窗口和浏览器关闭；sessionStorage数据只在当前浏览器窗口有效，关闭了就会被销毁；而 localStorage 永久存储，即使关闭浏览器，也不会消失，除非主动删除数据。 token、cookie、session三者的理解1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的） 用户身份的验证方式 2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名 服务器生成，发送到浏览器，浏览器会保存，下次请求再次发送给服务器（存放着登录信息） 3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁。cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。 服务器和客户端的一次会话过程 cookie与session区别 cookie 数据存放在客户端上，session 数据放在服务器上。 cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗，考虑到安全应当使用 session。 session 会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能，考虑到减轻服务器性能方面，应当使用 COOKIE。 单个 cookie 保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个 cookie。 session与token区别 session 只是存储了一些简单的用户信息，且 sessionID 是不可预测的，一种认证手段。只存在服务端，不能与其他的网站或App共享 token 提供认证和授权，认证针对用户，授权针对App，目的是让某APP有权访问某用户的信息。Token是唯一的，token不能转移到其他的App，也不能转到其他用户上。（适用于App） session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客户端的 TCP 三次握手 客户端发送 syn 包到服务器，等待服务器确认接收。 服务器确认接收 syn 包并确认客户的 syn，并发送一个 syn+ack 的包给客户端。 客户端确认接收服务器的 syn+ack 包，并向服务器发送确认包 ack，二者相互建立联系后，完成 tcp 三次握手。 TCP 四次挥手 客户端发送一个 FIN 报文并指定一个序列号到服务器，等待服务端的确认，然后进入 FIN_WAIT1 状态。 服务端收到 FIN 报文后，会发送一个 ACK 报文给客户端，表明已经收到客户端的报文了，然后进入 CLOSE_WAIT 状态 服务端发送一个 FIN 报文并指定一个序列号，等待客户端的确认，然后进入 LAST_ACK 状态。 客户端收到 FIN 报文后，会发送一个 ACK 报文给服务端，然后进入 TIME_WAIT 状态。过一阵子后进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态","categories":[{"name":"前端面试集锦","slug":"前端面试集锦","permalink":"http://ran-up.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://ran-up.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"手写数组去重","slug":"前端面试集锦/手写数组去重","date":"2022-10-26T07:55:58.000Z","updated":"2024-12-27T17:38:35.765Z","comments":true,"path":"2022/10/26/前端面试集锦/手写数组去重/","link":"","permalink":"http://ran-up.github.io/2022/10/26/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"","text":"// 数组去重 const arr = [1, 2, 3, 1, 2, 3, 4, 5, 6, 2, 3, 45, 5, 66, 723, 234, 56, 3, 6] // 使用es6 // new Set() let result = [...new Set(arr)] console.log(\"new Set():\", result) // 使用 filter()+indexOf()/includes() let filterArr = [] filterArr = arr.filter(function (item, index, arr) { // return arr.indexOf(item) === index ? filterArr.push(item) : null return !filterArr.includes(item) ? filterArr.push(item) : null }) console.log(\"filter()+indexOf()/includes():\", filterArr) // 使用 reduce()+indexOf()/includes() let reduceArr = arr.reduce((pre, next) => { /* if (!pre.includes(next)) { pre.push(next) } */ if (pre.indexOf(next) === -1) { pre.push(next) } return pre }, []) console.log(\"reduce()+indexOf()/includes():\", reduceArr) // 上面的 reduce() 和 filter() 其实就是能够遍历数组 // 所以我们可以使用for循环+indexOf()/includes() let forArr = [] for (let i = 0; i < arr.length; i++) { /* if (!forArr.includes(arr[i])) { forArr.push(arr[i]) } */ if (forArr.indexOf(arr[i]) === -1) { forArr.push(arr[i]) } } console.log(\"for循环+indexOf()/includes():\", forArr) // 前面的是单循环和indexOf，其实indexOf也有遍历，所以我们可以双层循环 // 双层for循环+slice()/split() let twoForArr = [1, 2, 3, 1, 2, 3, 4, 5, 6, 2, 3, 45, 5, 66, 723, 234, 56, 3, 6] for (let i = 0; i < twoForArr.length; i++) { for (let j = i + 1; j < twoForArr.length; j++) { if (twoForArr[i] === twoForArr[j]) { twoForArr.splice(j, 1) j-- } } } console.log(\"双层for循环+slice()/split():\", twoForArr) // 使用排序 // 普通排序 let sortArr = [1, 2, 3, 1, 2, 3, 4, 5, 6, 2, 3, 45, 5, 66, 723, 234, 56, 3, 6], newSortArr = [] sortArr = sortArr.sort() for (let i = 0; i < sortArr.length; i++) { if (sortArr[i] !== sortArr[i + 1]) newSortArr.push(sortArr[i]) } console.log(\"普通排序\", newSortArr) // 定制排序 let sortArr1 = [1, 2, 3, 1, 2, 3, 4, 5, 6, 2, 3, 45, 5, 66, 723, 234, 56, 3, 6], newSortArr1 = [] sortArr1 = sortArr1.sort((a, b) => a - b === 0 ? 0 : a - b > 0 ? 1 : -1) for (let i = 0; i < sortArr1.length; i++) { if (sortArr1[i] !== sortArr1[i + 1]) newSortArr1.push(sortArr1[i]) } console.log(\"定制排序\", newSortArr1) // 不使用ES6","categories":[{"name":"前端面试集锦","slug":"前端面试集锦","permalink":"http://ran-up.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/"}],"tags":[{"name":"js手写题--数组去重","slug":"js手写题-数组去重","permalink":"http://ran-up.github.io/tags/js%E6%89%8B%E5%86%99%E9%A2%98-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"}]},{"title":"手写防抖与节流","slug":"前端面试集锦/手写防抖与节流","date":"2022-10-26T03:47:51.000Z","updated":"2024-12-27T17:38:35.765Z","comments":true,"path":"2022/10/26/前端面试集锦/手写防抖与节流/","link":"","permalink":"http://ran-up.github.io/2022/10/26/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖 – debounce先知道它做了那些工作： 是一个函数 在同一个时间中，再次点击会重新计时，只有一个时间结束才输出数据，然后清空定时器。 &lt;input type=&quot;text&quot; id=&quot;txt&quot;/&gt;let txt = document.getElementById(&#x27;txt&#x27;)// 防抖，同一时间内再次触发重新计时，只要最后那一次function debounce(fn, wait) &#123; let timer = null // 除了这个不能是箭头函数，其他都行 return function () &#123; let self = this, args = arguments if (timer) &#123; clearTimeout(timer) timer = null &#125; timer = setTimeout(() =&gt; &#123; fn.apply(self, args) &#125;, wait) &#125;&#125;txt.addEventListener(&#x27;keyup&#x27;, debounce(e =&gt; &#123; console.log(e.target.value)&#125;, 2000)) 这里可能有些同学比较疑惑，为啥子里面要用一个return来返回函数？ 在这里介绍一下我的理解：如果不设置那个 return ，那么在页面上你还没有进行输入，它就会自动执行。嗯，这我也不知道原因是啥，反正测试出来是这样的。有知道的老哥可以留言，学习学习。 还有就是使用 return 返回的函数不能使用箭头函数，这是因为箭头函数的this是指向定义时候的上下文，也就是window了，而且无法更改。而我们是需要 txt 的，所以这里不能设置为箭头函数，其他地方都可以。 节流 – throttle这两个函数差不多，相差不大，所以疑问都类似，这里就不会做概述了。 先知道它做了那些工作： 是一个函数 设置一个时间，函数以这个时间为基准，来取数据，如果没有到达这个时间，则不会重复取数据，只有大于或等于才能取数据。 &lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;let txt = document.getElementById(&#x27;txt&#x27;)// 节流，设置一个时间，然后以该时间为基础进行重复调用，取数据。function throttle(fn, delay) &#123; // 知道最初的时间 let preTime = Date.now() // 除了这个不能是箭头函数，其他都行 return function () &#123; let self = this, args = arguments, // 知道现在的时间 newTime = Date.now() if (newTime - preTime &gt;= delay) &#123; fn.apply(self, args) // 将现在的时变为旧时间 preTime = Date.now() &#125; &#125;&#125;txt.addEventListener(&#x27;keyup&#x27;, throttle(e =&gt; &#123; console.log(e.target.value)&#125;, 2000)) 我们还可以使用定时器的方式实现节流。 // 定时器的方式实现function throttle(fn, delay) &#123; let timer = null, flag = true; return function () &#123; let args = arguments if (!flag) return; clearTimeout(timer); flag = false; timer = setTimeout(() =&gt; &#123; fn.apply(this, args); flag = true; &#125;, delay) &#125;&#125; 代码汇总有注释的&lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;let txt = document.getElementById(&#x27;txt&#x27;)// 防抖，同一时间内再次触发重新计时，只要最后那一次function debounce(fn, wait) &#123; let timer = null // 除了这个不能是箭头函数，其他都行 return function () &#123; let self = this, args = arguments if (timer) &#123; clearTimeout(timer) timer = null &#125; timer = setTimeout(() =&gt; &#123; fn.apply(self, args) &#125;, wait) &#125;&#125;// txt.addEventListener(&#x27;keyup&#x27;, debounce(e =&gt; &#123;// console.log(e.target.value)// &#125;, 2000))// 节流，设置一个时间，然后以该时间为基础进行重复调用，取数据。function throttle(fn, delay) &#123; // 知道最初的时间 let preTime = Date.now() // 除了这个不能是箭头函数，其他都行 return function () &#123; let self = this, args = arguments, // 知道现在的时间 newTime = Date.now() if (newTime - preTime &gt;= delay) &#123; fn.apply(self, args) // 将现在的时变为旧时间 preTime = Date.now() &#125; &#125;&#125;txt.addEventListener(&#x27;keyup&#x27;, throttle(e =&gt; &#123; console.log(e.target.value)&#125;, 2000))","categories":[{"name":"前端面试集锦","slug":"前端面试集锦","permalink":"http://ran-up.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/"}],"tags":[{"name":"js手写题--防抖与节流","slug":"js手写题-防抖与节流","permalink":"http://ran-up.github.io/tags/js%E6%89%8B%E5%86%99%E9%A2%98-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"}]},{"title":"手写call、apply、bind","slug":"前端面试集锦/手写call-apply-bind","date":"2022-10-25T15:42:39.000Z","updated":"2024-12-27T17:38:35.765Z","comments":true,"path":"2022/10/25/前端面试集锦/手写call-apply-bind/","link":"","permalink":"http://ran-up.github.io/2022/10/25/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/%E6%89%8B%E5%86%99call-apply-bind/","excerpt":"","text":"前言大家都进入到手写代码的环节了，我想都明白它们各自的用法和含义了吧。 那么这里就不在啰嗦了，如果不明白的，可以去看看MDN，了解了之后再回来继续读。这样容易理解一些。 下面就开始进入正题！！！ 实现 call() 方法首先我们要知道，call方法实现的内容： 能够设置 this 的指向； 接收多个参数，可能一个或多个，也可能一个也没有； 需要把参数传递给函数； 操作完后要把函数给删除掉。 // 可以先看下面的 手写call 的内容// 生成独一无二的函数名function mySymbol(obj) &#123; // new Date().getTime() 获取现在时间到1970.1.1的时间戳 let uniq = (Math.random() + new Date().getTime()).toString(32).slice(0, 8) if (obj.hasOwnProperty(uniq)) &#123; return mySymbol(obj) // 相同就再调用，直到生成不同的 &#125; else &#123; return uniq &#125;&#125;// 手写callFunction.prototype.myCall = function (context) &#123; // 如果没传入 this 指向，就将其指向 window context = context || window // 给 context 添加一个方法指向 this // 这个方法要是独一无二的，防止已经被占用的可能 let func = mySymbol(context) context[func] = this // 取出传入的参数 // slice(1) 取出该数组中从下标1到末尾的所有元素 let args = [...arguments].slice(1) context[func](...args) // 执行方法 delete context[func] // 删除方法&#125;name = &#x27;李四&#x27;let obj = &#123; name: &#x27;张三&#x27;, hh(age) &#123; console.log(`我叫$&#123;this.name&#125;,今年$&#123;age&#125;`) &#125;&#125;let obj1 = &#123; name: &#x27;王麻子&#x27;&#125;obj.hh.myCall(obj1, 18) // 我叫王麻子,今年18obj.hh.myCall(window, 20) // 我叫李四,今年20 实现 apply() 方法首先我们要知道，apply 方法实现的内容： 能够设置 this 的指向； 接收多个参数，可能一个或多个，也可能一个也没有，其中参数是一个整体的数组； 需要把参数传递给函数； 操作完后要把函数给删除掉。 // 可以先看下面的 手写apply 的内容// 生成独一无二的函数名function mySymbol(obj) &#123; // new Date().getTime() 获取现在时间到1970.1.1的时间戳 let uniq = (Math.random() + new Date().getTime()).toString(32).slice(0, 8) if (obj.hasOwnProperty(uniq)) &#123; return mySymbol(obj) // 相同就再调用，直到生成不同的 &#125; else &#123; return uniq &#125;&#125;// 手写applyFunction.prototype.myApply = function (context) &#123; context = context || window let func = mySymbol(context) context[func] = this let args = [...arguments][1] context[func](...args) delete context[func]&#125;obj.hh.myApply(obj1, [18]) // 我叫王麻子,今年18obj.hh.myApply(window, [20]) // 我叫李四,今年20 实现 bind() 方法首先我们要知道，bind 方法实现的内容： 能够设置 this 的指向； 接收多个参数，可能一个或多个，也可能一个也没有； 需要返回一个函数，所以需要在之前将 this 指向 和参数收集好； 调用这个函数的时候，有可能会传参，我们有需要收集好，然后同之前的参数进行合并； 这个时候就可以进行函数的调用和传参了。 // 手写bindFunction.prototype.myBind = function (context) &#123; console.log(context, this) // 保存当前的 this 和 参数 let self = this, args = [...arguments].slice(1) // 返回一个绑定 this 的函数 return function () &#123; // 因为调用返回的函数，可能会传参 let newArgs = [...arguments] // 合并两次的参数 args = args.concat(newArgs) return self.myApply(context, args) &#125;&#125;let obj2 = &#123; name: &#x27;张三&#x27;, hh(age, sex) &#123; console.log(`我叫$&#123;this.name&#125;,今年$&#123;age&#125;,性别$&#123;sex&#125;`) &#125;&#125;let obj3 = &#123; name: &#x27;王麻子&#x27;&#125;obj2.hh.myBind(obj3, 18)(&#x27;男&#x27;) // 我叫王麻子,今年18,性别男obj2.hh.myBind(window, 20)() // 我叫李四,今年20,性别undefined 总的代码有注释的代码// 生成独一无二的函数名function mySymbol(obj) &#123; // new Date().getTime() 获取现在时间到1970.1.1的时间戳 let uniq = (Math.random() + new Date().getTime()).toString(32).slice(0, 8) if (obj.hasOwnProperty(uniq)) &#123; return mySymbol(obj) // 相同就再调用，直到生成不同的 &#125; else &#123; return uniq &#125;&#125;// 手写callFunction.prototype.myCall = function (context) &#123; // 如果没传入 this 指向，就将其指向 window context = context || window // 给 context 添加一个方法指向 this // 这个方法要是独一无二的，防止已经被占用的可能 let func = mySymbol(context) context[func] = this // 取出传入的参数 // slice(1) 取出该数组中从下标1到末尾的所有元素 let args = [...arguments].slice(1) context[func](...args) // 执行方法 delete context[func] // 删除方法&#125;name = &#x27;李四&#x27;let obj = &#123; name: &#x27;张三&#x27;, hh(age) &#123; console.log(`我叫$&#123;this.name&#125;,今年$&#123;age&#125;`) &#125;&#125;let obj1 = &#123; name: &#x27;王麻子&#x27;&#125;obj.hh.myCall(obj1, 18) // 我叫王麻子,今年18obj.hh.myCall(window, 20) // 我叫李四,今年20// 手写applyFunction.prototype.myApply = function (context) &#123; context = context || window let func = mySymbol(context) context[func] = this let args = [...arguments][1] context[func](...args) delete context[func]&#125;obj.hh.myApply(obj1, [18]) // 我叫王麻子,今年18obj.hh.myApply(window, [20]) // 我叫李四,今年20// 手写bindFunction.prototype.myBind = function (context) &#123; // 保存当前的 this 和 参数 let self = this, args = [...arguments].slice(1) // 返回一个绑定 this 的函数 return function () &#123; // 因为调用返回的函数，可能会传参 let newArgs = [...arguments] // 合并两次的参数 args = args.concat(newArgs) return self.myApply(context, args) &#125;&#125;let obj2 = &#123; name: &#x27;张三&#x27;, hh(age, sex) &#123; console.log(`我叫$&#123;this.name&#125;,今年$&#123;age&#125;,性别$&#123;sex&#125;`) &#125;&#125;let obj3 = &#123; name: &#x27;王麻子&#x27;&#125;obj2.hh.myBind(obj3, 18)(&#x27;男&#x27;) // 我叫王麻子,今年18,性别男obj2.hh.myBind(window, 20)() // 我叫李四,今年20,性别undefined 无注释的代码（检验）function mySymbol(obj) &#123; let uniq = (Math.random() * new Date().getTime()).toString(32).slice(0, 8) if (obj.hasOwnProperty(uniq)) &#123; return mySymbol(obj) &#125; else &#123; return uniq &#125;&#125;Function.prototype.myCall = function (context) &#123; context = context || window let fn = mySymbol(context) context[fn] = this let args = [...arguments].slice(1) context[fn](...args) delete context[fn]&#125;Function.prototype.myApply = function (context) &#123; context = context || window let fn = mySymbol(context) context[fn] = this let args = [...arguments][1] context[fn](...args) delete context[fn]&#125;Function.prototype.myBind = function (context) &#123; context = context || window let self = this, args = [...arguments].slice(1) return function () &#123; let newArgs = [...arguments] args = args.concat(newArgs) return self.apply(context, args) &#125;&#125;name = &quot;张三&quot;let obj = &#123; getPerson(age) &#123; console.log(`我叫$&#123;this.name&#125;,今年$&#123;age&#125;`) &#125;&#125;let obj1 = &#123; name: &quot;李四&quot;&#125;obj.getPerson.myCall(obj1, 18) // 我叫李四,今年18obj.getPerson.myCall(window, 19) // 我叫张三,今年19obj.getPerson.myApply(obj1, [20]) // 我叫李四,今年20obj.getPerson.myApply(window, [21]) // 我叫张三,今年21obj.getPerson.myBind(obj1, 22)() // 我叫李四,今年22obj.getPerson.myBind(window, 23)() // 我叫张三,今年23","categories":[{"name":"前端面试集锦","slug":"前端面试集锦","permalink":"http://ran-up.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/"}],"tags":[{"name":"js手写题--call、apply、bind","slug":"js手写题-call、apply、bind","permalink":"http://ran-up.github.io/tags/js%E6%89%8B%E5%86%99%E9%A2%98-call%E3%80%81apply%E3%80%81bind/"}]},{"title":"冒泡与捕获事件介绍","slug":"JavaScript/冒泡与捕获事件介绍","date":"2022-10-25T02:24:50.000Z","updated":"2024-12-27T17:38:35.756Z","comments":true,"path":"2022/10/25/JavaScript/冒泡与捕获事件介绍/","link":"","permalink":"http://ran-up.github.io/2022/10/25/JavaScript/%E5%86%92%E6%B3%A1%E4%B8%8E%E6%8D%95%E8%8E%B7%E4%BA%8B%E4%BB%B6%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"事件冒泡IE 事件流被称为事件冒泡，这是因为事件被定义为从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）—-《JavaScript高级程序设计第四版》 举个例子： #outer &#123; width: 120px; height: 90px; background: pink;&#125;#father &#123; margin-left: 10px; width: 100px; height: 60px; background: skyblue;&#125;#son &#123; margin-left: 10px; width: 80px; height: 30px; background: tomato;&#125;&lt;div id=&quot;outer&quot;&gt;我是父亲 &lt;div id=&quot;father&quot;&gt;我是儿子 &lt;div id=&quot;son&quot;&gt;我是孙子&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;let outer = document.getElementById(&#x27;outer&#x27;)let father = document.getElementById(&#x27;father&#x27;)let son = document.getElementById(&#x27;son&#x27;)outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;我是父亲&#x27;)&#125;)father.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;我是儿子&#x27;)&#125;)son.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;我是孙子&#x27;)&#125;) 当我们点击 “我是孙子” 时，页面上会依次输出:我是孙子、我是儿子、我是父亲。在事件冒泡中 “我是孙子” 是最先点击的，所以也就最先触发了，然后在沿着 DOM 树向上层节点依次传递事件。然后就输出了刚刚的效果。 其实我们只给三个 div 设置了点击事件，让我们可以清晰的看到是以冒泡的形式来触发事件的，而在 DOM 节点中真实的样子是：我是孙子、我是儿子、我是父亲、body、html、Document。 注意：所有的现代浏览器都支持事件冒泡。IE5.5及早期版本会跳过元素（从直接到 document）。 事件捕获事件捕获的意思是最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件。—-《JavaScript高级程序设计第四版》 也就是前面事件冒泡的例子如果用的是事件捕获，那么点击 “我是孙子” 页面会依次输出：我是父亲、我是儿子、我是孙子。 而在 DOM 节点中真实的样子是：Document、html、body、我是父亲、我是儿子、我是孙子。 #outer &#123; width: 120px; height: 90px; background: pink;&#125;#father &#123; margin-left: 10px; width: 100px; height: 60px; background: skyblue;&#125;#son &#123; margin-left: 10px; width: 80px; height: 30px; background: tomato;&#125;&lt;div id=&quot;outer&quot;&gt;我是父亲 &lt;div id=&quot;father&quot;&gt;我是儿子 &lt;div id=&quot;son&quot;&gt;我是孙子&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;let outer = document.getElementById(&#x27;outer&#x27;)let father = document.getElementById(&#x27;father&#x27;)let son = document.getElementById(&#x27;son&#x27;)outer.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;我是父亲&#x27;)&#125;, true)father.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;我是儿子&#x27;)&#125;, true)son.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;我是孙子&#x27;)&#125;, true) 你也看到了，也就是在 addEventListener() 函数中配置一个布尔值，那加与不加有什么区别呢？就是使用冒泡事件还是捕获事件。 addEventListener() 函数默认是使用冒泡事件，为 false。如果想使用捕获事件，那么请将布尔值设置为 true。 如果想回顾一下这个函数，可以回顾MDN，或者看我后面的介绍。 事件代理事件代理（事件委托）：原理就是利用事件冒泡。只指定一个事件处理程序，就可以管理某一类型的所有事件。 我任务优点：1.可以大量节省内存占用，减少事件注册。2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适 缺点：事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。 最普遍做法点击li打印事件： window.onload = function()&#123; var oUl = document.getElementById(&quot;ul&quot;); var aLi = oUl.getElementsByTagName(&#x27;li&#x27;); for(var i = 0;i &lt; aLi.length;i++)&#123; aLi[i].onclick = function()&#123; alert(123); &#125; &#125;&#125;s// 用事件委托这么做window.onload = function()&#123; var oUl = document.getElementById(&quot;ul1&quot;); oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == &#x27;li&#x27;)&#123; alert(123); alert(target.innerHTML); &#125; &#125;&#125; 这里借用了 博主中文章的例子 &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;add&quot; value=&quot;添加&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;remove&quot; value=&quot;删除&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;move&quot; value=&quot;移动&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;select&quot; value=&quot;选择&quot; /&gt;&lt;/div&gt;// 通常写法window.onload = function()&#123; var Add = document.getElementById(&quot;add&quot;); var Remove = document.getElementById(&quot;remove&quot;); var Move = document.getElementById(&quot;move&quot;); var Select = document.getElementById(&quot;select&quot;); Add.onclick = function()&#123; alert(&#x27;添加&#x27;); &#125;; Remove.onclick = function()&#123; alert(&#x27;删除&#x27;); &#125;; Move.onclick = function()&#123; alert(&#x27;移动&#x27;); &#125;; Select.onclick = function()&#123; alert(&#x27;选择&#x27;); &#125; &#125;// 运用事件代理window.onload = function()&#123; var oBox = document.getElementById(&quot;box&quot;); oBox.onclick = function (ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLocaleLowerCase() == &#x27;input&#x27;)&#123; switch(target.id)&#123; case &#x27;add&#x27; : alert(&#x27;添加&#x27;); break; case &#x27;remove&#x27; : alert(&#x27;删除&#x27;); break; case &#x27;move&#x27; : alert(&#x27;移动&#x27;); break; case &#x27;select&#x27; : alert(&#x27;选择&#x27;); break; &#125; &#125; &#125; &#125; 点击新增元素节点 &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;btn&quot; value=&quot;添加&quot; /&gt;&lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;// 通常写法window.onload = function()&#123; var oBtn = document.getElementById(&quot;btn&quot;); var oUl = document.getElementById(&quot;ul1&quot;); var aLi = oUl.getElementsByTagName(&#x27;li&#x27;); var num = 4; function mHover () &#123; //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = &#x27;red&#x27;; &#125;; aLi[i].onmouseout = function()&#123; this.style.background = &#x27;#fff&#x27;; &#125; &#125; &#125; mHover (); //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement(&#x27;li&#x27;); oLi.innerHTML = 111*num; oUl.appendChild(oLi); // 必须调用 mHover 函数才能将事件添加到新节点中 mHover (); &#125;;&#125;// 使用事件委托方案window.onload = function()&#123; var oBtn = document.getElementById(&quot;btn&quot;); var oUl = document.getElementById(&quot;ul1&quot;); var aLi = oUl.getElementsByTagName(&#x27;li&#x27;); var num = 4; //事件委托，添加的子元素也有事件 oUl.onmouseover = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == &#x27;li&#x27;)&#123; target.style.background = &quot;red&quot;; &#125; &#125;; oUl.onmouseout = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == &#x27;li&#x27;)&#123; target.style.background = &quot;#fff&quot;; &#125; &#125;; //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement(&#x27;li&#x27;); oLi.innerHTML = 111*num; oUl.appendChild(oLi); &#125;;&#125; 给一个场景 ul &gt; li &gt; div &gt; p，div占满li，p占满div，还是给ul绑定时间，需要判断点击的是不是li（假设li里面的结构是不固定的），那么e.target就可能是p，也有可能是div，这种情况你会怎么处理呢？ &lt;ul id=&quot;test&quot;&gt; &lt;li&gt; &lt;p&gt;11111111111&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt; 22222222 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;3333333333&lt;/span&gt; &lt;/li&gt; &lt;li&gt;4444444&lt;/li&gt;&lt;/ul&gt;var oUl = document.getElementById(&#x27;test&#x27;);oUl.addEventListener(&#x27;click&#x27;,function(ev)&#123; var target = ev.target; while(target !== oUl )&#123; if(target.tagName.toLowerCase() == &#x27;li&#x27;)&#123; console.log(&#x27;li click~&#x27;); break; &#125; target = target.parentNode; &#125;&#125;) addEventListener() 函数addEventListener()和 removeEventListener() 给 DOM 节点添加或移除事件。共有三个参数：事件名、事件处理函数和一个布尔值。true – 采用捕获事件，false（默认值）采用冒泡事件。 使用此函数可以设置多个事件。他们会按顺序执行。 例子可以看上面的 冒泡事件 和 捕获事件 的操作代码。当然这里也有很简单的使用。 let btn1 = document.getElementById(&quot;btn1&quot;); let btn2 = document.getElementById(&quot;btn2&quot;); // 采用冒泡事件，也可以不写 falsebtn1.addEventListener(&quot;click&quot;, () =&gt; &#123; console.log(&#x27;哈哈&#x27;); &#125;, false);// 采用捕获事件btn2.addEventListener(&quot;click&quot;, () =&gt; &#123; console.log(&#x27;哈哈&#x27;); &#125;, true); 注意：通过 addEventListener() 添加的事件处理程序只能使用 removeEventListener() 并传入与添加时同样的参数来移除。 let btn1 = document.getElementById(&quot;btn1&quot;); let btn2 = document.getElementById(&quot;btn2&quot;); btn1.addEventListener(&quot;click&quot;, function() &#123; console.log(&#x27;btn1&#x27;); &#125;, false); btn2.addEventListener(&quot;click&quot;, function() &#123; console.log(&#x27;btn2&#x27;); &#125;, false); // 移除 -- 有效果btn1.removeEventListener(&quot;click&quot;, function() &#123; console.log(&#x27;btn1&#x27;); &#125;, false);// 移除 -- 无效果btn2.removeEventListener(&quot;click&quot;, function() &#123; console.log(&#x27;这是无效移除，因为函数不同&#x27;); &#125;, false); 一个很离谱的浏览器（你懂的）此浏览器需要使用 attachEvent() 和 detachEvent() 来实现添加和移除事件。他们接收两个同样的参数：事件名字和事件处理函数。 注意：IE8 及更早版本只支持事件冒泡，所以使用 attachEvent() 添加的事件处理程序会添加到冒泡阶段。 var btn = document.getElementById(&quot;myBtn&quot;); btn.attachEvent(&quot;onclick&quot;, function() &#123; console.log(&quot;Clicked&quot;); &#125;);btn.attachEvent(&quot;onclick&quot;, function() &#123; console.log(&quot;Hello world!&quot;); &#125;); 同样的可以设置多个事件，但这里的执行顺序是反向触发，也就是先输出”Hello world!”，然后再输出”Clicked”。 注意： attachEvent() 的第一个参数是”onclick”，而不是 DOM 的 addEventListener() 方法的”click”。 使用 attachEvent() 时，事件处理程序是在全局作用域中运行的，因此 this 等于 window。 兼容所有浏览器function addHandler(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125;&#125;function removeHandler(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = null; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/categories/JavaScript/"}],"tags":[{"name":"Event 事件","slug":"Event-事件","permalink":"http://ran-up.github.io/tags/Event-%E4%BA%8B%E4%BB%B6/"}]},{"title":"vue中的懒加载","slug":"Vue/vue中的懒加载","date":"2022-10-24T05:55:37.000Z","updated":"2024-12-27T17:38:35.759Z","comments":true,"path":"2022/10/24/Vue/vue中的懒加载/","link":"","permalink":"http://ran-up.github.io/2022/10/24/Vue/vue%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"我现在所知的 Vue 中的懒加载 路由懒加载将不同路由的组件通过箭头函数引用，而不是直接使用导入过后的组件名来引入。也就是使用 component:() &#x3D;&gt; import(‘..&#x2F;views&#x2F;home’) 替换 component: Home。让路由被访问时才开始加载对应的组件，这样可以提高项目的加载速度和效率。‘ const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/home&#x27;, name: &#x27;Home&#x27;， component:() =&gt; import(&#x27;@/views/Home&#x27;) &#125; ]&#125;) 图片懒加载概念懒加载就是延时加载，也就是当需要用到的时候再去加载 懒加载的优点 可以减少首页首次加载的数量，减少服务器的压力 当网络叫差时，可以提前给这张图片添加一个低像素图片，使页面结构完整，让用户体验更好一点。 懒加载的原理原理：当用户滚动页面时，判断元素是否处于可视区域，而可视区域外的元素资源（如图片）不会加载。\\n简单来说就是会先将 img 标签中的 src 路径设置为一张图片，当进行 v-for 遍历时就可以遍历为同一张图片，将其真正的图片地址存储在其自定义属性中（比如data-src）。当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果。 如何实现懒加载 // 第一步: 安装npm install vue-lazyload --save// 第二步: 全局注册(main.js 文件)import VueLazyload from &#x27;vue-lazyload&#x27;// 无配置项Vue.use(VueLazyload)// 有配置项import loadImg from &#x27;@/assets//load.png&#x27;// const loadImg = require(&#x27;@/assets//load.png&#x27;)// 注册Vue.use(VueLazyload, &#123; preLoad: 1.3, // 预加载的宽高比 loading: loadImg, // 图片加载状态下显示的图片 // error: errorimage, // 图片加载失败时显示的图片 attempt: 1, // 图片加载失败后的重试次数&#125;)// 第三步：img元素上使用&lt;img v-lazy=&quot;图片路径.png&quot;/&gt; 注意上面的 loading 不能写相对路径。因为src中的文件会被 webpack 编译，assets文件夹中的图片地址，会在编译过程中重命名。\\nvue-lazyload 是在 main.js 文件中引入，不会被 webpack 进行编译，这就导致写相对路径 vue-lazyload 会无法获得正确的图片路径。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://ran-up.github.io/categories/Vue/"}],"tags":[{"name":"vue中的懒加载","slug":"vue中的懒加载","permalink":"http://ran-up.github.io/tags/vue%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/"}]},{"title":"一些未在意的隐式转换","slug":"JavaScript/一些未在意的隐式转换","date":"2022-10-20T15:10:45.000Z","updated":"2024-12-27T17:38:35.756Z","comments":true,"path":"2022/10/20/JavaScript/一些未在意的隐式转换/","link":"","permalink":"http://ran-up.github.io/2022/10/20/JavaScript/%E4%B8%80%E4%BA%9B%E6%9C%AA%E5%9C%A8%E6%84%8F%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"有些隐式转换我们没有在意 1 + &#x27;1&#x27;1 * &#x27;1&#x27; '11'、2 加运算中如果只有一个操作符是字符串，则要将另外一个操作数也转换为字符串。 乘运算中如果有一个操作数不是数值，则会调用 Number() 将另一个操作数转换为数值，如果不能转换为数值，则变为 NaN。 [].valueOf(), [1, 2].valueOf() []、[1,2] valueOf()返回对象本身。 &#x27;a&#x27; + + &#x27;b&#x27; 'aNaN' 后面的 + 作为一元运算符使用，如果操作数是字符串，则会调用 Number() 将其转换为数值，如果不能转换为数值，则变为 NaN。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/categories/JavaScript/"}],"tags":[{"name":"代码题","slug":"代码题","permalink":"http://ran-up.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"}]},{"title":"理解一些任务队列","slug":"JavaScript/理解一些任务队列","date":"2022-10-20T14:20:39.000Z","updated":"2024-12-27T17:38:35.758Z","comments":true,"path":"2022/10/20/JavaScript/理解一些任务队列/","link":"","permalink":"http://ran-up.github.io/2022/10/20/JavaScript/%E7%90%86%E8%A7%A3%E4%B8%80%E4%BA%9B%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/","excerpt":"","text":"一些消息队列代码题 console.log(&#x27;a&#x27;)while (true) &#123;&#125;console.log(&#x27;b&#x27;)// 能输出a，但里面的循环是死循环，所以后面的内容不会输出 console.log(&#x27;a&#x27;)setTimeout(() =&gt; &#123; console.log(&#x27;b&#x27;)&#125;)while (true) &#123;&#125; a 能输出a，这里面有异步任务和同步任务，先执行同步任务，后执行异步任务。 同步任务有：console.log('a') 和 while 循环。 异步任务有：定时器。 但while循环是死循环，所以同步任务永远无法执行完毕，异步任务也就不能执行。 console.log(&quot;---start---&quot;)setTimeout(() =&gt; &#123; console.log(&quot;setTimeout&quot;)&#125;)new Promise((resolve, reject) =&gt; &#123; for (var i = 0; i &lt; 5; i++) &#123; console.log(i) &#125; resolve()&#125;).then(() =&gt; &#123; console.log(&quot;Promise&quot;)&#125;)console.log(&quot;---end---&quot;)/* ---start---01234---end---Promise*/// 因为任务分同步任务和异步任务，异步任务又有宏任务和微任务之分。// 执行顺序为：同步任务 &gt; 异步任务（微任务 &gt; 宏任务） function wait() &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, 10 * 1000) &#125;)&#125;async function main() &#123; console.time() const a = await wait() const b = await wait() const c = await wait() console.timeEnd() console.time() const a1 = wait() const b1 = wait() const c1 = wait() await a1 await b1 await c1 console.timeEnd() console.time() const a2 = wait() const b2 = wait() const c2 = wait() a2, b2, c2 console.timeEnd()&#125;main()// default: 31156.48681640625 ms// default: 10006.406982421875 ms// default: 0.07470703125 ms var name = &#x27;Tom&#x27;;console.log(name);(function () &#123; console.log(name) if (typeof name == &#x27;undefined&#x27;) &#123; name = &#x27;Jack&#x27; console.log(&#x27;Goodbye &#x27; + name) &#125; else &#123; console.log(&#x27;Hello &#x27; + name) &#125;&#125;)() Tom、Tom、Hello Tom 先在自执行函数作用域中找name，没找到就去外层找，恰好外层有name，就拿来用了，然后就进入了else语句，输出了 Hello Tom","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/categories/JavaScript/"}],"tags":[{"name":"代码题","slug":"代码题","permalink":"http://ran-up.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"}]},{"title":"Promise的简单概念","slug":"JavaScript/Promise的简单概念","date":"2022-10-19T04:58:54.000Z","updated":"2024-12-27T17:38:35.755Z","comments":true,"path":"2022/10/19/JavaScript/Promise的简单概念/","link":"","permalink":"http://ran-up.github.io/2022/10/19/JavaScript/Promise%E7%9A%84%E7%AE%80%E5%8D%95%E6%A6%82%E5%BF%B5/","excerpt":"","text":"Promise 基本概念了解 概念Promise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。 Safari 9 和 Edge 13 及以下不兼容 使用语法： // 构造 Promise 对象new Promise(function (resolve, reject) &#123; // 要做的事情...&#125;); 在 Promise 中只有一个参数，该参数是一个函数。 这个函数在构造之后会直接被异步运行，所以我们称之为起始函数。该函数可以传入两个参数 resolve 和 reject。 resolve 和 reject 都是函数，前者是运行成功时调用的函数，后者是运行出错时调用的函数。 在 Promise 类中还有三个方法： .then()：正常执行的序列（是异步执行的） .catch()：异常处理的序列 .finally()：最后一定会执行的序列。 我们还可以在 then() 方法中，使用 throw 来自定义错误，从而提交到 catch 方法中输出定义的错误。 注意： resolve 和 reject 的作用域只有起始函数，在其他序列当中不能使用； resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。 &lt;script&gt; new Promise(function (resolve, reject) &#123; console.log(&quot;我是：&quot; + 111) // 调用 resolve 传入参数 222 resolve(222) &#125;).then(function (value) &#123; console.log(&quot;我是：&quot;, value) // 内部使用 reutrn 返回值，传给下一个 then 方法当参数 return 333 &#125;).then(function (value) &#123; console.log(&quot;我是：&quot;, value) throw &quot;我定义一个错误&quot; &#125;).catch(function (err) &#123; console.log(err) &#125;).finally(function () &#123; console.log(&quot;我是都会执行的fanilly方法&quot;) &#125;)&lt;/script&gt;/* 输出： 我是：111 我是：222 我是：333 我定义一个错误 我是都会执行的fanilly方法*/ &lt;script&gt; new Promise(function (resolve, reject) &#123; let a = 4 let b = 2 // 直接调用 reject 去 catch 输出错误 if (b == 0) reject(&quot;除数不能为0&quot;) // 这种方法也可以 // if (b == 0) throw (&quot;除数不能为0&quot;) // 条件成立则调用 resolve 并传入参数 else resolve(a / b) &#125;).then(function (value) &#123; console.log(value) // 输出：2 &#125;).catch(function (err) &#123; console.log(err) &#125;)&lt;/script&gt; 异步函数异步函数（async function）是 ECMAScript 2017 (ECMA-262) 标准的规范，几乎被所有浏览器所支持，除了 Internet Explorer。 在异步函数中可以使用 await 指令，而在其后必须跟着一个 Promise 类，当 Promise 运行时异步函数就会暂停，直至它运行结束后才会继续运行。 其实异步函数实际上原理与 Promise 原生 API 的机制是一模一样的，只不过更便于程序员阅读。 当我们需要对异常进行处理的时候可以使用 try-catch。 &lt;script&gt; async function asyncFunc() &#123; try &#123; await new Promise(function (resolve, reject) &#123; console.log(&quot;我是正确的&quot;) // 执行 resolve throw &quot;我是故意出错的&quot; // 执行 reject // 这种写法也可以 // reject(&quot;我是故意出错的&quot;) &#125;) &#125; catch (err) &#123; console.log(err) &#125; &#125; asyncFunc()&lt;/script&gt;/* 输出： 我是正确的 我是故意出错的*/ 总结 resolve 和 reject 的作用域只有起始函数，在其他序列当中不能使用； resolve 和 reject 并不能够使起始函数停止运行，别忘了 return； then、catch 和 finally 序列顺序可以颠倒，但一般使用 then-catch-finally 的顺序编写程序； then 块默认会向下顺序执行，return 是不能中断的，可以通过 throw 来跳转至 catch 实现中断。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/categories/JavaScript/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://ran-up.github.io/tags/es6/"}]}],"categories":[{"name":"SSR","slug":"SSR","permalink":"http://ran-up.github.io/categories/SSR/"},{"name":"前端面试集锦","slug":"前端面试集锦","permalink":"http://ran-up.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/"},{"name":"typescript","slug":"typescript","permalink":"http://ran-up.github.io/categories/typescript/"},{"name":"网络","slug":"网络","permalink":"http://ran-up.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"webpack","slug":"webpack","permalink":"http://ran-up.github.io/categories/webpack/"},{"name":"vue","slug":"vue","permalink":"http://ran-up.github.io/categories/vue/"},{"name":"pure主题配置","slug":"pure主题配置","permalink":"http://ran-up.github.io/categories/pure%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"name":"CSS预处理器","slug":"CSS预处理器","permalink":"http://ran-up.github.io/categories/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"name":"项目流程记录","slug":"项目流程记录","permalink":"http://ran-up.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"name":"git相关","slug":"git相关","permalink":"http://ran-up.github.io/categories/git%E7%9B%B8%E5%85%B3/"},{"name":"使用swiper出现的bug","slug":"使用swiper出现的bug","permalink":"http://ran-up.github.io/categories/%E4%BD%BF%E7%94%A8swiper%E5%87%BA%E7%8E%B0%E7%9A%84bug/"},{"name":"AJAX-axios","slug":"AJAX-axios","permalink":"http://ran-up.github.io/categories/AJAX-axios/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/categories/JavaScript/"},{"name":"安装依赖出错","slug":"安装依赖出错","permalink":"http://ran-up.github.io/categories/%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%87%BA%E9%94%99/"},{"name":"vue项目","slug":"vue项目","permalink":"http://ran-up.github.io/categories/vue%E9%A1%B9%E7%9B%AE/"},{"name":"正则","slug":"正则","permalink":"http://ran-up.github.io/categories/%E6%AD%A3%E5%88%99/"},{"name":"uniapp项目","slug":"uniapp项目","permalink":"http://ran-up.github.io/categories/uniapp%E9%A1%B9%E7%9B%AE/"},{"name":"vant相关","slug":"vant相关","permalink":"http://ran-up.github.io/categories/vant%E7%9B%B8%E5%85%B3/"},{"name":"Bootstrap相关","slug":"Bootstrap相关","permalink":"http://ran-up.github.io/categories/Bootstrap%E7%9B%B8%E5%85%B3/"},{"name":"Vue","slug":"Vue","permalink":"http://ran-up.github.io/categories/Vue/"},{"name":"ElementUI","slug":"ElementUI","permalink":"http://ran-up.github.io/categories/ElementUI/"},{"name":"软件","slug":"软件","permalink":"http://ran-up.github.io/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"看视频/文章笔记","slug":"看视频-文章笔记","permalink":"http://ran-up.github.io/categories/%E7%9C%8B%E8%A7%86%E9%A2%91-%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://ran-up.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"CSS","slug":"CSS","permalink":"http://ran-up.github.io/categories/CSS/"}],"tags":[{"name":"nuxt","slug":"nuxt","permalink":"http://ran-up.github.io/tags/nuxt/"},{"name":"面试题","slug":"面试题","permalink":"http://ran-up.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"typescript","slug":"typescript","permalink":"http://ran-up.github.io/tags/typescript/"},{"name":"网络","slug":"网络","permalink":"http://ran-up.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"webpack","slug":"webpack","permalink":"http://ran-up.github.io/tags/webpack/"},{"name":"ElementPlus","slug":"ElementPlus","permalink":"http://ran-up.github.io/tags/ElementPlus/"},{"name":"vue3","slug":"vue3","permalink":"http://ran-up.github.io/tags/vue3/"},{"name":"笔试题","slug":"笔试题","permalink":"http://ran-up.github.io/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"},{"name":"pure主题新增时间","slug":"pure主题新增时间","permalink":"http://ran-up.github.io/tags/pure%E4%B8%BB%E9%A2%98%E6%96%B0%E5%A2%9E%E6%97%B6%E9%97%B4/"},{"name":"Sass","slug":"Sass","permalink":"http://ran-up.github.io/tags/Sass/"},{"name":"项目流程记录","slug":"项目流程记录","permalink":"http://ran-up.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"name":"面试","slug":"面试","permalink":"http://ran-up.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"杂糅","slug":"杂糅","permalink":"http://ran-up.github.io/tags/%E6%9D%82%E7%B3%85/"},{"name":"git报错","slug":"git报错","permalink":"http://ran-up.github.io/tags/git%E6%8A%A5%E9%94%99/"},{"name":"项目bug","slug":"项目bug","permalink":"http://ran-up.github.io/tags/%E9%A1%B9%E7%9B%AEbug/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://ran-up.github.io/tags/JavaScript/"},{"name":"AJAX-axios","slug":"AJAX-axios","permalink":"http://ran-up.github.io/tags/AJAX-axios/"},{"name":"git","slug":"git","permalink":"http://ran-up.github.io/tags/git/"},{"name":"reduce的妙用","slug":"reduce的妙用","permalink":"http://ran-up.github.io/tags/reduce%E7%9A%84%E5%A6%99%E7%94%A8/"},{"name":"正则","slug":"正则","permalink":"http://ran-up.github.io/tags/%E6%AD%A3%E5%88%99/"},{"name":"js实操","slug":"js实操","permalink":"http://ran-up.github.io/tags/js%E5%AE%9E%E6%93%8D/"},{"name":"类型转换","slug":"类型转换","permalink":"http://ran-up.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"vant的坑","slug":"vant的坑","permalink":"http://ran-up.github.io/tags/vant%E7%9A%84%E5%9D%91/"},{"name":"Bootstrap错误","slug":"Bootstrap错误","permalink":"http://ran-up.github.io/tags/Bootstrap%E9%94%99%E8%AF%AF/"},{"name":"npm报错","slug":"npm报错","permalink":"http://ran-up.github.io/tags/npm%E6%8A%A5%E9%94%99/"},{"name":"vue2","slug":"vue2","permalink":"http://ran-up.github.io/tags/vue2/"},{"name":"el-table","slug":"el-table","permalink":"http://ran-up.github.io/tags/el-table/"},{"name":"快捷键","slug":"快捷键","permalink":"http://ran-up.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"杂记","slug":"杂记","permalink":"http://ran-up.github.io/tags/%E6%9D%82%E8%AE%B0/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://ran-up.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"常用知识点","slug":"常用知识点","permalink":"http://ran-up.github.io/tags/%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"微信小程序tabBar跳转问题","slug":"微信小程序tabBar跳转问题","permalink":"http://ran-up.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FtabBar%E8%B7%B3%E8%BD%AC%E9%97%AE%E9%A2%98/"},{"name":"vantweapp问题","slug":"vantweapp问题","permalink":"http://ran-up.github.io/tags/vantweapp%E9%97%AE%E9%A2%98/"},{"name":"云开发使用概括","slug":"云开发使用概括","permalink":"http://ran-up.github.io/tags/%E4%BA%91%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E6%A6%82%E6%8B%AC/"},{"name":"插槽","slug":"插槽","permalink":"http://ran-up.github.io/tags/%E6%8F%92%E6%A7%BD/"},{"name":"css设置变量","slug":"css设置变量","permalink":"http://ran-up.github.io/tags/css%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://ran-up.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"js手写题--数组去重","slug":"js手写题-数组去重","permalink":"http://ran-up.github.io/tags/js%E6%89%8B%E5%86%99%E9%A2%98-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"},{"name":"js手写题--防抖与节流","slug":"js手写题-防抖与节流","permalink":"http://ran-up.github.io/tags/js%E6%89%8B%E5%86%99%E9%A2%98-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"},{"name":"js手写题--call、apply、bind","slug":"js手写题-call、apply、bind","permalink":"http://ran-up.github.io/tags/js%E6%89%8B%E5%86%99%E9%A2%98-call%E3%80%81apply%E3%80%81bind/"},{"name":"Event 事件","slug":"Event-事件","permalink":"http://ran-up.github.io/tags/Event-%E4%BA%8B%E4%BB%B6/"},{"name":"vue中的懒加载","slug":"vue中的懒加载","permalink":"http://ran-up.github.io/tags/vue%E4%B8%AD%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"name":"代码题","slug":"代码题","permalink":"http://ran-up.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"},{"name":"es6","slug":"es6","permalink":"http://ran-up.github.io/tags/es6/"}]}