{"meta":{"title":"ranup前端笔记汇总","subtitle":"一个前端小白的苦闷路程","description":"这里是一些前端方面的笔记，知识共享，持续更新","author":"ranup","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-10-16T15:12:04.587Z","updated":"2022-10-16T15:12:04.587Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2022-10-16T15:12:04.589Z","updated":"2022-10-16T15:12:04.589Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-10-18T10:39:44.124Z","updated":"2022-10-18T10:39:44.124Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2022-10-16T15:12:04.589Z","updated":"2022-10-16T15:12:04.589Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"项目介绍","date":"2022-10-18T10:55:05.799Z","updated":"2022-10-18T10:55:05.799Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-10-17T13:25:14.302Z","updated":"2022-10-17T13:25:14.302Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-10-16T15:12:04.590Z","updated":"2022-10-16T15:12:04.590Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"let与const与var整理","slug":"let与const与var整理","date":"2022-10-17T13:15:39.000Z","updated":"2022-10-18T13:28:26.197Z","comments":true,"path":"2022/10/17/let与const与var整理/","link":"","permalink":"http://example.com/2022/10/17/let%E4%B8%8Econst%E4%B8%8Evar%E6%95%B4%E7%90%86/","excerpt":"","text":"Promise知识点概念Promise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。 Safari 9 和 Edge 13 及以下不兼容 使用**语法**： 1234// 构造 Promise 对象new Promise(function (resolve, reject) &#123; // 要做的事情...&#125;); 在 Promise 中只有一个参数，该参数是一个函数。 这个函数在构造之后会直接被异步运行，所以我们称之为起始函数。该函数可以传入两个参数 resolve 和 reject。 resolve 和 reject 都是函数，前者是运行成功时调用的函数，后者是运行出错时调用的函数。 在 Promise 类中还有三个方法： **.then()**：正常执行的序列（是异步执行的） **.catch()**：异常处理的序列 **.finally()**：最后一定会执行的序列。 我们还可以在 then()方法中，使用 throw 来自定义错误，从而提交到 catch 方法中输出定义的错误。 **注意**： resolve 和 reject 的作用域只有起始函数，在其他序列当中不能使用； resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。 12345678910111213141516171819202122232425&lt;script&gt; new Promise(function (resolve, reject) &#123; console.log(&quot;我是：&quot; + 111) // 调用 resolve 传入参数 222 resolve(222) &#125;).then(function (value) &#123; console.log(&quot;我是：&quot;, value) // 内部使用 reutrn 返回值，传给下一个 then 方法当参数 return 333 &#125;).then(function (value) &#123; console.log(&quot;我是：&quot;, value) throw &quot;我定义一个错误&quot; &#125;).catch(function (err) &#123; console.log(err) &#125;).finally(function () &#123; console.log(&quot;我是都会执行的fanilly方法&quot;) &#125;)&lt;/script&gt;/* 输出： 我是：111 我是： 222 我是： 333 我定义一个错误 我是都会执行的fanilly方法*/ 12345678910111213141516&lt;script&gt; new Promise(function (resolve, reject) &#123; let a = 4 let b = 2 // 错误直接调用 reject 去 catch 输出错误 if (b == 0) reject(&quot;除数不能为0&quot;) // 这种方法也可以 // if (b == 0) throw (&quot;除数不能为0&quot;) // 条件成立则调用 resolve 并传入参数 else resolve(a / b) &#125;).then(function (value) &#123; console.log(value) // 输出：2 &#125;).catch(function (err) &#123; console.log(err) &#125;)&lt;/script&gt; 异步函数异步函数（async function）是 ECMAScript 2017 (ECMA-262) 标准的规范，几乎被所有浏览器所支持，除了 Internet Explorer。 在异步函数中可以使用 await 指令，而在其后必须跟着一个 Promise 类，当 Promise 运行时异步函数就会暂停，直至它运行结束后才会继续运行。 其实异步函数实际上原理与 Promise 原生 API 的机制是一模一样的，只不过更便于程序员阅读。 当我们需要对异常进行处理的时候可以使用 try-catch。 12345678910111213141516171819&lt;script&gt; async function asyncFunc() &#123; try &#123; await new Promise(function (resolve, reject) &#123; console.log(&quot;我是正确的&quot;) // 执行 resolve throw &quot;我是故意出错的&quot; // 执行 reject // 这种写法也可以 // reject(&quot;我是故意出错的&quot;) &#125;) &#125; catch (err) &#123; console.log(err) &#125; &#125; asyncFunc()&lt;/script&gt;/* 输出： 我是正确的 我是故意出错的*/ 注意 resolve 和 reject 的作用域只有起始函数，在其他序列当中不能使用； resolve 和 reject 并不能够使起始函数停止运行，别忘了 return； then、catch 和 finally 序列顺序可以颠倒，但一般使用 then-catch-finally 的顺序编写程序； then 块默认会向下顺序执行，return 是不能中断的，可以通过 throw 来跳转至 catch 实现中断。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://example.com/tags/es6/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-11T09:06:05.424Z","updated":"2022-10-11T09:06:05.424Z","comments":true,"path":"2022/10/11/hello-world/","link":"","permalink":"http://example.com/2022/10/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://example.com/tags/es6/"}]}